{
  
    
        "post0": {
            "title": "Transcriptional Target Selection",
            "content": "# imports import os, sys import io import json import requests def flatten(lol): return [x for l in lol for x in l] def chunker(seq, size): return (seq[pos:pos + size] for pos in range(0, len(seq), size)) import pandas as pd import numpy as np import networkx as nx import matplotlib.pyplot as plt import seaborn as sns#; sns.set_theme() plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] plt.rcParams[&#39;figure.dpi&#39;] = 140 plt.rcParams[&#39;agg.path.chunksize&#39;] = 10000 %config InlineBackend.figure_format = &#39;retina&#39; %matplotlib inline import matplotlib_inline matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;svg&#39;) from IPython.display import Image, HTML, IFrame, SVG, display from Bio import SeqIO from Bio.KEGG import REST, Gene from Bio.KEGG.KGML import KGML_parser from Bio.Graphics.KGML_vis import KGMLCanvas from wand.image import Image as WImage def wImage(fn, **kwargs): return WImage(filename=fn, **kwargs) pd.set_option(&#39;display.max_rows&#39;, 200) . # venn diagrams import matplotlib.pyplot as plt from matplotlib_venn import venn2, venn3 import upsetplot import matplotlib_inline.backend_inline matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;svg&#39;) %config InlineBackend.figure_format = &#39;retina&#39; %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = [6, 3] plt.rcParams[&#39;figure.dpi&#39;] = 140 plt.rcParams[&#39;font.size&#39;] = 8 import re import traceback def remove_special_characters(s): return re.sub(&#39;[^a-zA-Z0-9]&#39;, &#39; &#39;, s) def get_strings(stack): filename, lineno, function_name, code = stack[-2] names = [n.strip() for n in code[code.find(&quot;(&quot;)+1:code.rfind(&quot;)&quot;)].split(&#39;,&#39;)] common_prefix = os.path.commonprefix(names) common_suffix = os.path.commonprefix([name[::-1] for name in names])[::-1] if len(common_prefix) &gt; 2: names = [name.removeprefix(common_prefix) for name in names] if len(common_suffix) &gt; 2: names = [name.removesuffix(common_suffix) for name in names] if len(common_prefix) &gt; 2 or len(common_suffix) &gt; 2: names = [remove_special_characters(name) for name in names] return names def form_list_of_tuples(names, iterables): final = [] for name, iterable in zip(names, iterables): len_full = len(iterable) s = set(iterable) len_uniques = len(s) if len_uniques == len_full: name += f&#39; ({len_uniques})&#39; else: name += f&#39; ({len_uniques} unique in {len_full})&#39; final.append((s, name)) return final def venn(*args, **kwargs): if len(args) == 2: method = venn2 elif len(args) == 3: method = venn3 else: print(&#39;incorrect number of args&#39;) names = get_strings(traceback.extract_stack()) final = form_list_of_tuples(names, args) return method(*zip(*final), **kwargs) def upset(*args, **kwargs): names = get_strings(traceback.extract_stack()) final = form_list_of_tuples(names, args) s = upsetplot.from_contents(dict(final)) fig, upsetplot.UpSet(s, subset_size=&#39;count&#39;, show_counts=True).plot() return s, fig . # clustering heatmaps import scipy import scipy.stats from scipy.cluster.hierarchy import dendrogram, linkage from scipy.cluster import hierarchy def sort_df_by_hclust_olo(df, how=&#39;both&#39;, method=&#39;ward&#39;, metric=&#39;euclidean&#39;): &#39;&#39;&#39; how={&#39;index&#39;, &#39;columns&#39;, &#39;both&#39;} &#39;&#39;&#39; df = df.fillna(0) if how in [&#39;index&#39;, &#39;both&#39;]: Z = linkage(df, method=method, metric=metric) order = hierarchy.leaves_list(hierarchy.optimal_leaf_ordering(Z, df)) df = df.iloc[order] if how in [&#39;columns&#39;, &#39;both&#39;]: df = df.T Z = linkage(df, method=method, metric=metric) order = hierarchy.leaves_list(hierarchy.optimal_leaf_ordering(Z, df)) df = df.iloc[order].T return df.replace(0, np.nan) . # scaling SVG from IPython.display import SVG from bs4 import BeautifulSoup import re def scale_svg(svg_object, scale=1.0): soup = BeautifulSoup(svg_object.data, &#39;lxml&#39;) svg_elt = soup.find(&quot;svg&quot;) w = svg_elt.attrs[&quot;width&quot;].rstrip(&quot;pt&quot;) h = svg_elt.attrs[&quot;height&quot;].rstrip(&quot;pt&quot;) ws = float(w)*scale hs = float(h)*scale svg_elt.attrs[&quot;width&quot;] = f&quot;{ws}pt&quot; svg_elt.attrs[&quot;height&quot;] = f&quot;{hs}pt&quot; svg_elt.attrs[&quot;viewbox&quot;] = f&quot;0.00 0.00 {ws} {hs}&quot; g_elt = svg_elt.find(&quot;g&quot;) tf = g_elt.attrs[&quot;transform&quot;] # non-greedy regex-search-and-replace tf2 = re.sub( &quot;scale (.*? )&quot;, f&quot;scale({scale} {scale})&quot;, tf ) g_elt.attrs[&quot;transform&quot;] = tf2 svg_object.data = str(svg_elt) return svg_object . TODO in the future: . check out wikipathways | . KEGG functions . Helpful links: . BioPython KEGG Tutorial | Maybe possible to use matplotlib to draw KEGG pathways instead? | KEGG ortholog table URL | . # load reference genome and KEGG IDs id_mapping = pd.read_csv(&#39;/Users/alex/Documents/scImputation/KEGG_hsa_ncbi_and_ENSG_ID_map.csv&#39;) genome = pd.read_csv(&#39;/Users/alex/Documents/AChroMap/data/processed/GRCh38_V40.csv&#39;) genome[&#39;gene_id&#39;] = genome.gene_id.str.split(&#39;.&#39;).str[0] gene_names = genome[[&#39;gene_id&#39;, &#39;gene_name&#39;]].drop_duplicates(&#39;gene_id&#39;).set_index(&#39;gene_id&#39;) # ko_to_hsa = pd.read_csv(&#39;https://rest.kegg.jp/link/ko/hsa&#39;, sep=&#39; t&#39;, header=None, names=[&#39;hsa&#39;, &#39;ko&#39;]) # ko_to_hsa.to_csv(&#39;ko_to_hsa.csv&#39;, index=False) # id_mapping = id_mapping.merge(ko_to_hsa, how=&#39;left&#39;, left_on=&#39;KEGG_id&#39;, right_on=&#39;hsa&#39;) . # define functions to query KEGG database and process/visualize results def to_df(result, **kwargs): return pd.read_table(io.StringIO(result), header=None, **kwargs) def kegg_find(query): return to_df(REST.kegg_find(&#39;pathway&#39;, query).read(), names=[&#39;pathway_ID&#39;, &#39;pathway_name&#39;]) def kegg2pdf(map_id, fn=None): # Get the background image first pathway = KGML_parser.read(REST.kegg_get(map_id, &quot;kgml&quot;)) canvas = KGMLCanvas(pathway, import_imagemap=True) if isinstance(fn, type(None)): img_filename = &quot;%s.pdf&quot; % map_id else: img_filename = fn canvas.draw(img_filename) return img_filename def get_KEGG_pathway_gene_members(pathway): pathway = KGML_parser.read(REST.kegg_get(pathway, &#39;kgml&#39;)) members = np.unique(flatten([gene.name.strip().split(&#39; &#39;) for gene in pathway.genes])) members = id_mapping[id_mapping.KEGG_id.isin(members)].drop_duplicates(&#39;KEGG_id&#39;).set_index(&#39;KEGG_id&#39;).reindex(members) members[&#39;gene_name&#39;] = gene_names.reindex(members.ENSG).gene_name.values members = members[[&#39;ENSG&#39;, &#39;gene_name&#39;]].dropna() return members def unpack_BRITE_json(d): if &#39;children&#39; in d: return {d[&#39;name&#39;]: [unpack_BRITE_json(child) for child in d[&#39;children&#39;]]} else: if d[&#39;name&#39;].startswith(&#39;K&#39;): tmp = d[&#39;name&#39;].split(&#39;;&#39;) tmp0 = tmp[0].split(&#39; &#39;) return [tmp0[0], [s.strip() for s in tmp0[1].split(&#39;,&#39;)], tmp[1].strip()] else: return d[&#39;name&#39;] def second_parse(d, index=[]): if isinstance(d, dict): return flatten([second_parse(x, index+[k]) for k,v in d.items() for x in v]) else: # print(d) return [[index, d[0], d[1]]] all_gene_symbols_set = set(gene_names.gene_name.values) def get_KEGG_BRITE_entry(brite_id): r = requests.get(f&#39;https://rest.kegg.jp/get/br:{brite_id}/json&#39;) j = unpack_BRITE_json(r.json()) j2 = pd.DataFrame(second_parse(j)) j2 = j2.merge(id_mapping, how=&#39;left&#39;, left_on=1, right_on=id_mapping.ko.str.split(&#39;:&#39;).str[1]) j2.index = pd.MultiIndex.from_tuples([tuple(x) for x in j2[0].values]) brite_id = brite_id.split(&#39;+&#39;)[0] j2 = j2.loc[brite_id].drop([&#39;ncbi_ID&#39;,&#39;KEGG_id&#39;,&#39;ko&#39;], axis=1).rename(columns={1:&#39;KEGG_ortholog_ID&#39;,2:&#39;KEGG_gene_name&#39;}) j2[&#39;KEGG_gene_name&#39;] = j2.KEGG_gene_name.apply(lambda l: [x for x in l if x in all_gene_symbols_set]) j2[&#39;KEGG_gene_name&#39;] = j2.KEGG_gene_name.apply(lambda l: l if len(l) else np.nan) j2[&#39;gene_name&#39;] = gene_names.reindex(j2.ENSG).values j2 = j2.dropna(subset=[&#39;KEGG_gene_name&#39;,&#39;ENSG&#39;,&#39;gene_name&#39;], how=&#39;all&#39;) def newcol(row): if (isinstance(row.KEGG_gene_name, list) and row.gene_name in row.KEGG_gene_name) or (str(row.KEGG_gene_name) == &#39;nan&#39;): return np.nan else: return row.KEGG_gene_name[0] j2[&#39;newcol&#39;] = j2.apply(newcol, axis=1) save_index = j2.index j2 = j2.merge(gene_names.reset_index(), how=&#39;left&#39;, left_on=&#39;newcol&#39;, right_on=&#39;gene_name&#39;) j2.index = save_index j2[&#39;gene_name_x&#39;] = j2.gene_name_x.fillna(j2.gene_name_y) j2[&#39;ENSG&#39;] = j2.ENSG.fillna(j2.gene_id) j2 = j2.drop([&#39;KEGG_gene_name&#39;, &#39;newcol&#39;, &#39;gene_id&#39;, &#39;gene_name_y&#39;, 0, &#39;KEGG_ortholog_ID&#39;], axis=1).rename(columns={&#39;gene_name_x&#39;: &#39;gene_name&#39;}) return j2 def get_KEGG_data(pathway_code=None, brite_code=None): pathway_genes = None brite_genes = None if pathway_code: Image(REST.kegg_get(pathway_code, &#39;image&#39;).read()) pathway_genes = get_KEGG_pathway_gene_members(pathway_code) if brite_code: brite_genes = get_KEGG_BRITE_entry(brite_code) if pathway_code: brite_genes[&#39;in_KEGG_pathway&#39;] = brite_genes.ENSG.isin(pathway_genes.ENSG).astype(int) return pathway_genes, brite_genes . GO functions . # define functions to query GO database and process/visualize results def GO_subgraph_from_query(query): # nodes = pd.DataFrame({key: data for key, data in ontology_graph.nodes(data=True) if all(query in data[&#39;name&#39;].lower() for query in queries)}, index=GO_columns).T nodes = pd.DataFrame({key: data for key, data in ontology_graph.nodes(data=True) if query.lower() in data[&#39;name&#39;].lower()}, index=GO_columns).T nodes[&#39;gene_name&#39;] = nodes.ENSG.apply(lambda l: gene_names.reindex(l).gene_name.values) g = ontology_graph_literate.subgraph(nodes.name.tolist()) return g, nodes def draw_graph(graph, scale=0.5): ag = nx.nx_agraph.to_agraph(graph) ag.graph_attr[&#39;rankdir&#39;]=&#39;LR&#39; ag.node_attr[&#39;shape&#39;] = &#39;record&#39; svg = ag.draw(prog=&#39;dot&#39;,format=&#39;svg&#39;) # display(scale_svg(SVG(svg), scale)) display(SVG(svg)) def create_GO_by_gene_matrix(node_df, attr=&#39;ENSG&#39;): df = node_df.set_index(&#39;name&#39;)[attr].explode() df = (df.reset_index() .assign(v = True) .groupby([&#39;name&#39;,attr]).first() .unstack(level=1) .fillna(False) )[&#39;v&#39;] if attr == &#39;ENSG&#39;: df = df.loc[:, df.columns.str.startswith(&#39;gene_name&#39;)] return df sns.set(font_scale = 0.5) cmap = sns.color_palette(&quot;light:b&quot;, as_cmap=True) def plot_gene_membership_in_GO_terms(df, figsize=(10, 50)): ax = sns.clustermap(df.T, figsize=figsize, cbar=False, dendrogram_ratio=(0.001,0.001), colors_ratio=0.0001, cmap=cmap) ax.ax_row_dendrogram.set_visible(False) ax.ax_col_dendrogram.set_visible(False) ax.ax_cbar.set_visible(False) plt.xticks(fontsize=8) plt.yticks(fontsize=8) return ax ontology_graph = nx.read_gpickle(&#39;/Users/alex/Documents/goenrich-web/GO/human_GO.gpickle&#39;) ontology_graph_literate = nx.relabel_nodes(ontology_graph, {key: data[&#39;name&#39;] for key, data in ontology_graph.nodes(data=True)}) GO_columns = list(ontology_graph.nodes(data=True)[&#39;GO:0000001&#39;].keys()) human_GO = pd.read_csv(&#39;/Users/alex/Documents/goenrich-web/GO/human_GO.csv&#39;) human_GO[&#39;NCBI_ID&#39;] = human_GO.NCBI_ID.str.split(&#39;;&#39;) human_GO[&#39;ENSG&#39;] = human_GO.ENSG.str.split(&#39;;&#39;) def drop_nan_index_levels(df): for i in list(range(df.index.nlevels))[::-1]: if pd.isnull(df.index.get_level_values(i)).all(): df.index = df.index.droplevel(i) return df def KEGG_GO_venn(kegg_brite, GO_nodes): KEGG_list = np.unique(kegg_brite.ENSG.dropna().values) GO_list = np.unique(flatten(GO_nodes.ENSG.values)) return venn(KEGG_list, GO_list) . . 1. Proteasome, Chaperones, Autophagy, Mitophagy, Lysosomal acidification . 1.1 Proteasome . KEGG . proteasome_pathway_id = &#39;hsa03050&#39; proteasome_brite_id = &#39;ko03051&#39; Image(REST.kegg_get(proteasome_pathway_id, &#39;image&#39;).read()) . proteasome_pathway_genes = get_KEGG_pathway_gene_members(proteasome_pathway_id) . proteasome_brite_genes = get_KEGG_BRITE_entry(proteasome_brite_id) proteasome_brite_genes = proteasome_brite_genes.loc[&#39;Eukaryotic proteasome&#39;] proteasome_brite_genes[&#39;in_KEGG_pathway&#39;] = proteasome_brite_genes.ENSG.isin(proteasome_pathway_genes.ENSG).astype(int) . proteasome_brite_genes.to_pickle(&#39;targets/proteasome_brite.pickle&#39;) . GO . proteasome_subgraph, proteasome_nodes = GO_subgraph_from_query(&#39;proteasom&#39;) . draw_graph(proteasome_subgraph) . negative regulation of SCF-dependent proteasomal ubiquitin-dependent catabolic process negative regulation of SCF-dependent proteasomal ubiquitin-dependent catabolic process regulation of SCF-dependent proteasomal ubiquitin-dependent protein catabolic process regulation of SCF-dependent proteasomal ubiquitin-dependent protein catabolic process negative regulation of SCF-dependent proteasomal ubiquitin-dependent catabolic process-&gt;regulation of SCF-dependent proteasomal ubiquitin-dependent protein catabolic process negative regulation of proteasomal ubiquitin-dependent protein catabolic process negative regulation of proteasomal ubiquitin-dependent protein catabolic process negative regulation of SCF-dependent proteasomal ubiquitin-dependent catabolic process-&gt;negative regulation of proteasomal ubiquitin-dependent protein catabolic process regulation of proteasomal ubiquitin-dependent protein catabolic process regulation of proteasomal ubiquitin-dependent protein catabolic process regulation of SCF-dependent proteasomal ubiquitin-dependent protein catabolic process-&gt;regulation of proteasomal ubiquitin-dependent protein catabolic process negative regulation of proteasomal ubiquitin-dependent protein catabolic process-&gt;regulation of proteasomal ubiquitin-dependent protein catabolic process negative regulation of proteasomal protein catabolic process negative regulation of proteasomal protein catabolic process negative regulation of proteasomal ubiquitin-dependent protein catabolic process-&gt;negative regulation of proteasomal protein catabolic process positive regulation of proteasomal protein catabolic process positive regulation of proteasomal protein catabolic process regulation of proteasomal protein catabolic process regulation of proteasomal protein catabolic process positive regulation of proteasomal protein catabolic process-&gt;regulation of proteasomal protein catabolic process protein localization to cytosolic proteasome complex involved in ERAD pathway protein localization to cytosolic proteasome complex involved in ERAD pathway protein localization to cytosolic proteasome complex protein localization to cytosolic proteasome complex protein localization to cytosolic proteasome complex involved in ERAD pathway-&gt;protein localization to cytosolic proteasome complex proteasome accessory complex proteasome accessory complex proteasome complex proteasome complex proteasome accessory complex-&gt;proteasome complex cytosolic proteasome regulatory particle cytosolic proteasome regulatory particle cytosolic proteasome complex cytosolic proteasome complex cytosolic proteasome regulatory particle-&gt;cytosolic proteasome complex proteasome regulatory particle proteasome regulatory particle cytosolic proteasome regulatory particle-&gt;proteasome regulatory particle cytosolic proteasome complex-&gt;proteasome complex proteasome regulatory particle-&gt;proteasome accessory complex nuclear proteasome regulatory particle nuclear proteasome regulatory particle nuclear proteasome regulatory particle-&gt;proteasome regulatory particle nuclear proteasome complex nuclear proteasome complex nuclear proteasome regulatory particle-&gt;nuclear proteasome complex nuclear proteasome complex-&gt;proteasome complex protein polyubiquitination involved in nucleus-associated proteasomal ubiquitin-dependent protein catabolic process protein polyubiquitination involved in nucleus-associated proteasomal ubiquitin-dependent protein catabolic process nuclear protein quality control by the ubiquitin-proteasome system nuclear protein quality control by the ubiquitin-proteasome system protein polyubiquitination involved in nucleus-associated proteasomal ubiquitin-dependent protein catabolic process-&gt;nuclear protein quality control by the ubiquitin-proteasome system proteasome-mediated ubiquitin-dependent protein catabolic process proteasome-mediated ubiquitin-dependent protein catabolic process nuclear protein quality control by the ubiquitin-proteasome system-&gt;proteasome-mediated ubiquitin-dependent protein catabolic process regulation of proteasomal ubiquitin-dependent protein catabolic process-&gt;regulation of proteasomal protein catabolic process proteasomal ubiquitin-independent protein catabolic process proteasomal ubiquitin-independent protein catabolic process proteasomal protein catabolic process proteasomal protein catabolic process proteasomal ubiquitin-independent protein catabolic process-&gt;proteasomal protein catabolic process cytosolic proteasome core complex cytosolic proteasome core complex cytosolic proteasome core complex-&gt;cytosolic proteasome complex proteasome core complex proteasome core complex cytosolic proteasome core complex-&gt;proteasome core complex proteasome core complex-&gt;proteasome complex nuclear proteasome core complex, alpha-subunit complex nuclear proteasome core complex, alpha-subunit complex nuclear proteasome core complex nuclear proteasome core complex nuclear proteasome core complex, alpha-subunit complex-&gt;nuclear proteasome core complex proteasome core complex, alpha-subunit complex proteasome core complex, alpha-subunit complex nuclear proteasome core complex, alpha-subunit complex-&gt;proteasome core complex, alpha-subunit complex nuclear proteasome core complex-&gt;nuclear proteasome complex nuclear proteasome core complex-&gt;proteasome core complex proteasome core complex, alpha-subunit complex-&gt;proteasome core complex nuclear proteasome regulatory particle, base subcomplex nuclear proteasome regulatory particle, base subcomplex nuclear proteasome regulatory particle, base subcomplex-&gt;nuclear proteasome regulatory particle proteasome regulatory particle, base subcomplex proteasome regulatory particle, base subcomplex nuclear proteasome regulatory particle, base subcomplex-&gt;proteasome regulatory particle, base subcomplex proteasome regulatory particle, base subcomplex-&gt;proteasome regulatory particle positive regulation of SCF-dependent proteasomal ubiquitin-dependent catabolic process positive regulation of SCF-dependent proteasomal ubiquitin-dependent catabolic process positive regulation of SCF-dependent proteasomal ubiquitin-dependent catabolic process-&gt;regulation of SCF-dependent proteasomal ubiquitin-dependent protein catabolic process positive regulation of proteasomal ubiquitin-dependent protein catabolic process positive regulation of proteasomal ubiquitin-dependent protein catabolic process positive regulation of SCF-dependent proteasomal ubiquitin-dependent catabolic process-&gt;positive regulation of proteasomal ubiquitin-dependent protein catabolic process positive regulation of proteasomal ubiquitin-dependent protein catabolic process-&gt;positive regulation of proteasomal protein catabolic process positive regulation of proteasomal ubiquitin-dependent protein catabolic process-&gt;regulation of proteasomal ubiquitin-dependent protein catabolic process SCF-dependent proteasomal ubiquitin-dependent protein catabolic process SCF-dependent proteasomal ubiquitin-dependent protein catabolic process SCF-dependent proteasomal ubiquitin-dependent protein catabolic process-&gt;proteasome-mediated ubiquitin-dependent protein catabolic process proteasome-mediated ubiquitin-dependent protein catabolic process-&gt;proteasomal protein catabolic process nuclear proteasome regulatory particle, lid subcomplex nuclear proteasome regulatory particle, lid subcomplex nuclear proteasome regulatory particle, lid subcomplex-&gt;nuclear proteasome regulatory particle proteasome regulatory particle, lid subcomplex proteasome regulatory particle, lid subcomplex nuclear proteasome regulatory particle, lid subcomplex-&gt;proteasome regulatory particle, lid subcomplex proteasome regulatory particle, lid subcomplex-&gt;proteasome regulatory particle proteasome complex disassembly proteasome complex disassembly proteasome storage granule assembly proteasome storage granule assembly proteasome-activating nucleotidase complex proteasome-activating nucleotidase complex proteasome-activating nucleotidase complex-&gt;proteasome accessory complex cytosolic proteasome core complex, alpha-subunit complex cytosolic proteasome core complex, alpha-subunit complex cytosolic proteasome core complex, alpha-subunit complex-&gt;cytosolic proteasome core complex cytosolic proteasome core complex, alpha-subunit complex-&gt;proteasome core complex, alpha-subunit complex proteasome storage granule proteasome storage granule proteasome assembly proteasome assembly regulation of proteasome assembly regulation of proteasome assembly cytoplasm protein quality control by the ubiquitin-proteasome system cytoplasm protein quality control by the ubiquitin-proteasome system cytoplasm protein quality control by the ubiquitin-proteasome system-&gt;proteasome-mediated ubiquitin-dependent protein catabolic process proteasome storage granule disassembly proteasome storage granule disassembly negative regulation of proteasomal protein catabolic process-&gt;regulation of proteasomal protein catabolic process regulation of proteasome core complex assembly regulation of proteasome core complex assembly regulation of proteasome core complex assembly-&gt;regulation of proteasome assembly proteasome-nuclear membrane anchor activity proteasome-nuclear membrane anchor activity proteasome core complex, beta-subunit complex proteasome core complex, beta-subunit complex proteasome core complex, beta-subunit complex-&gt;proteasome core complex nuclear proteasome core complex, beta-subunit complex nuclear proteasome core complex, beta-subunit complex nuclear proteasome core complex, beta-subunit complex-&gt;nuclear proteasome core complex nuclear proteasome core complex, beta-subunit complex-&gt;proteasome core complex, beta-subunit complex proteasome core complex binding proteasome core complex binding spermatoproteasome complex spermatoproteasome complex spermatoproteasome complex-&gt;proteasome complex proteasome core complex import into nucleus proteasome core complex import into nucleus cytosolic proteasome regulatory particle, base subcomplex cytosolic proteasome regulatory particle, base subcomplex cytosolic proteasome regulatory particle, base subcomplex-&gt;cytosolic proteasome regulatory particle cytosolic proteasome regulatory particle, base subcomplex-&gt;proteasome regulatory particle, base subcomplex proteasome binding proteasome binding proteasome localization to nuclear periphery proteasome localization to nuclear periphery proteasome localization proteasome localization proteasome localization to nuclear periphery-&gt;proteasome localization cytosolic proteasome regulatory particle, lid subcomplex cytosolic proteasome regulatory particle, lid subcomplex cytosolic proteasome regulatory particle, lid subcomplex-&gt;cytosolic proteasome regulatory particle cytosolic proteasome regulatory particle, lid subcomplex-&gt;proteasome regulatory particle, lid subcomplex positive regulation of proteasomal ubiquitin-dependent protein catabolic process involved in cellular response to hypoxia positive regulation of proteasomal ubiquitin-dependent protein catabolic process involved in cellular response to hypoxia positive regulation of proteasomal ubiquitin-dependent protein catabolic process involved in cellular response to hypoxia-&gt;positive regulation of proteasomal ubiquitin-dependent protein catabolic process proteasome activator complex proteasome activator complex proteasome activator complex-&gt;proteasome accessory complex proteasome-activating activity proteasome-activating activity proteasome regulatory particle binding proteasome regulatory particle binding cytosolic proteasome core complex, beta-subunit complex cytosolic proteasome core complex, beta-subunit complex cytosolic proteasome core complex, beta-subunit complex-&gt;cytosolic proteasome core complex cytosolic proteasome core complex, beta-subunit complex-&gt;proteasome core complex, beta-subunit complex proteasome regulatory particle assembly proteasome regulatory particle assembly proteasome regulatory particle assembly-&gt;proteasome assembly proteasomal proteolysis associated with antigen processing and presentation proteasomal proteolysis associated with antigen processing and presentation proteasome core complex assembly proteasome core complex assembly proteasome core complex assembly-&gt;proteasome assembly structural constituent of proteasome structural constituent of proteasome df = create_GO_by_gene_matrix(proteasome_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:44:39.117055 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ proteasome_nodes.to_pickle(&#39;targets/proteasome_GO.pickle&#39;) . Overlap . KEGG_GO_venn(proteasome_brite_genes, proteasome_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1a9bc0fa0&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:44:40.435437 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 1.2 Chaperones . KEGG . chaperones_brite_id = &#39;ko03110&#39; chaperones_brite_genes = get_KEGG_BRITE_entry(chaperones_brite_id) . chaperones_brite_genes.to_pickle(&#39;targets/chaperone_brite.pickle&#39;) . GO . chaperone_subgraph, chaperone_nodes = GO_subgraph_from_query(&#39;chaperone&#39;) draw_graph(chaperone_subgraph) df = create_GO_by_gene_matrix(chaperone_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . histone chaperone activity histone chaperone activity protein carrier chaperone protein carrier chaperone histone chaperone activity-&gt;protein carrier chaperone chaperone-mediated autophagy translocation complex disassembly chaperone-mediated autophagy translocation complex disassembly chaperone-mediated autophagy translocation complex chaperone-mediated autophagy translocation complex ATP-dependent H3-H4 histone complex chaperone activity ATP-dependent H3-H4 histone complex chaperone activity ATP-dependent histone chaperone activity ATP-dependent histone chaperone activity ATP-dependent H3-H4 histone complex chaperone activity-&gt;ATP-dependent histone chaperone activity H3-H4 histone complex chaperone activity H3-H4 histone complex chaperone activity ATP-dependent H3-H4 histone complex chaperone activity-&gt;H3-H4 histone complex chaperone activity ATP-dependent histone chaperone activity-&gt;histone chaperone activity H3-H4 histone complex chaperone activity-&gt;histone chaperone activity regulation of chaperone-mediated protein complex assembly regulation of chaperone-mediated protein complex assembly metallochaperone activity metallochaperone activity chaperone binding chaperone binding superoxide dismutase copper chaperone activity superoxide dismutase copper chaperone activity copper chaperone activity copper chaperone activity superoxide dismutase copper chaperone activity-&gt;copper chaperone activity copper chaperone activity-&gt;metallochaperone activity zinc chaperone activity zinc chaperone activity zinc chaperone activity-&gt;metallochaperone activity regulation of chaperone-mediated protein folding regulation of chaperone-mediated protein folding regulation of chaperone-mediated autophagy regulation of chaperone-mediated autophagy protein targeting to lysosome involved in chaperone-mediated autophagy protein targeting to lysosome involved in chaperone-mediated autophagy chaperone-mediated autophagy chaperone-mediated autophagy protein targeting to lysosome involved in chaperone-mediated autophagy-&gt;chaperone-mediated autophagy ATP-dependent FeS chaperone activity ATP-dependent FeS chaperone activity ATP-dependent FeS chaperone activity-&gt;metallochaperone activity iron chaperone activity iron chaperone activity iron chaperone activity-&gt;metallochaperone activity chaperone complex chaperone complex ATP-dependent protein folding chaperone ATP-dependent protein folding chaperone protein folding chaperone protein folding chaperone ATP-dependent protein folding chaperone-&gt;protein folding chaperone vacuolar transporter chaperone complex vacuolar transporter chaperone complex vacuolar transporter chaperone complex-&gt;chaperone complex chaperone mediated protein folding independent of cofactor chaperone mediated protein folding independent of cofactor chaperone-mediated protein folding chaperone-mediated protein folding chaperone mediated protein folding independent of cofactor-&gt;chaperone-mediated protein folding positive regulation of chaperone-mediated autophagy positive regulation of chaperone-mediated autophagy positive regulation of chaperone-mediated autophagy-&gt;regulation of chaperone-mediated autophagy chaperone-mediated protein complex assembly chaperone-mediated protein complex assembly ATP-dependent H2AZ histone chaperone activity ATP-dependent H2AZ histone chaperone activity ATP-dependent H2AZ histone chaperone activity-&gt;ATP-dependent histone chaperone activity RNA folding chaperone RNA folding chaperone HSP90-CDC37 chaperone complex HSP90-CDC37 chaperone complex HSP90-CDC37 chaperone complex-&gt;chaperone complex chaperone-mediated autophagy translocation complex assembly chaperone-mediated autophagy translocation complex assembly chaperone-mediated autophagy translocation complex assembly-&gt;chaperone-mediated autophagy chaperone cofactor-dependent protein refolding chaperone cofactor-dependent protein refolding chaperone cofactor-dependent protein refolding-&gt;chaperone-mediated protein folding endoplasmic reticulum chaperone complex endoplasmic reticulum chaperone complex positive regulation of chaperone-mediated protein complex assembly positive regulation of chaperone-mediated protein complex assembly positive regulation of chaperone-mediated protein complex assembly-&gt;regulation of chaperone-mediated protein complex assembly metallochaperone complex metallochaperone complex negative regulation of chaperone-mediated protein folding negative regulation of chaperone-mediated protein folding negative regulation of chaperone-mediated protein folding-&gt;regulation of chaperone-mediated protein folding positive regulation of chaperone-mediated protein folding positive regulation of chaperone-mediated protein folding positive regulation of chaperone-mediated protein folding-&gt;regulation of chaperone-mediated protein folding H2A-H2B histone complex chaperone activity H2A-H2B histone complex chaperone activity H2A-H2B histone complex chaperone activity-&gt;histone chaperone activity negative regulation of chaperone-mediated autophagy negative regulation of chaperone-mediated autophagy negative regulation of chaperone-mediated autophagy-&gt;regulation of chaperone-mediated autophagy Ig heavy chain-bound endoplasmic reticulum chaperone complex Ig heavy chain-bound endoplasmic reticulum chaperone complex Ig heavy chain-bound endoplasmic reticulum chaperone complex-&gt;chaperone complex superoxide dismutase copper chaperone complex superoxide dismutase copper chaperone complex superoxide dismutase copper chaperone complex-&gt;metallochaperone complex &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:44:42.431906 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ chaperone_nodes.to_pickle(&#39;targets/chaperone_GO.pickle&#39;) . Overlap . KEGG_GO_venn(chaperones_brite_genes, chaperone_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1a9cdd940&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:44:43.002047 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 1.3 Autophagy . KEGG . autophagy_KEGG_pathway = &#39;hsa04140&#39; autophagy_KEGG_BRITE = &#39;ko04131&#39; Image(REST.kegg_get(autophagy_KEGG_pathway, &#39;image&#39;).read()) . autophagy_pathway_genes = get_KEGG_pathway_gene_members(autophagy_KEGG_pathway) . autophagy_brite_genes = get_KEGG_BRITE_entry(autophagy_KEGG_BRITE) . autophagy_brite_genes = autophagy_brite_genes.loc[&#39;Autophagy&#39;] . autophagy_brite_genes[&#39;in_KEGG_pathway&#39;] = autophagy_brite_genes.ENSG.isin(autophagy_pathway_genes.ENSG).astype(int) . autophagy_brite_genes.to_pickle(&#39;targets/autophagy_brite.pickle&#39;) . GO . autophagy_subgraph, autophagy_nodes = GO_subgraph_from_query(&#39;autophag&#39;) df = create_GO_by_gene_matrix(autophagy_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) clustermap = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:44:52.029688 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ autophagy_nodes.to_pickle(&#39;targets/autophagy_GO.pickle&#39;) . Overlap . KEGG_GO_venn(autophagy_brite_genes, autophagy_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x19a056520&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:44:54.058061 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 1.4 Mitophagy . KEGG . mitophagy_KEGG_pathway = &#39;hsa04137&#39; Image(REST.kegg_get(mitophagy_KEGG_pathway, &#39;image&#39;).read()) . mitophagy_pathway_genes = get_KEGG_pathway_gene_members(mitophagy_KEGG_pathway) . mitophagy_brite_genes = pd.DataFrame(autophagy_brite_genes.loc[&#39;Mitophagy&#39;]) . mitophagy_brite_genes.drop([&#39;in_KEGG_pathway&#39;], axis=1, inplace=True) mitophagy_brite_genes[&#39;in_KEGG_pathway&#39;] = mitophagy_brite_genes.ENSG.isin(mitophagy_pathway_genes.ENSG).astype(int) mitophagy_brite_genes.to_pickle(&#39;targets/mitophagy_brite.pickle&#39;) . GO . mitophagy_subgraph, mitophagy_nodes = GO_subgraph_from_query(&#39;mitophagy&#39;) df = create_GO_by_gene_matrix(mitophagy_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:44:57.283422 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ mitophagy_nodes.to_pickle(&#39;targets/mitophagy_GO.pickle&#39;) . Overlap . KEGG_GO_venn(mitophagy_brite_genes, mitophagy_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x199e82f40&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:44:57.403791 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 1.5 Lysosomal acidification . KEGG . lysosome_KEGG_pathway = &#39;hsa04142&#39; Image(REST.kegg_get(lysosome_KEGG_pathway, &#39;image&#39;).read()) . lysosome_pathway_genes = get_KEGG_pathway_gene_members(lysosome_KEGG_pathway) . lysosome_pathway_genes.set_index(&#39;ENSG&#39;)[&#39;gene_name&#39;].to_pickle(&#39;./targets/lysosome_kegg.pickle&#39;) . GO . lysosome_subgraph, lysosome_nodes = GO_subgraph_from_query(&#39;lysosom&#39;) . df = create_GO_by_gene_matrix(lysosome_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:45:04.254706 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ lysosome_nodes.to_pickle(&#39;targets/lysosome_GO.pickle&#39;) . Overlap . KEGG_GO_venn(lysosome_pathway_genes, lysosome_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x199e873a0&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:45:07.914521 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 2. TE/ERV de-repression, Chromatin modifiers, Epigenetic Erosion (heterochromatin loosening), histones are limiting, Nuclear Lamin defects, neurons entering cell cycle? . brite = &#39;ko03036&#39; brite_genes = get_KEGG_BRITE_entry(brite) brite_genes = brite_genes.loc[&#39;Eukaryotic type&#39;] . 2.1 TE de-repression . # Silencing chromatin modifiers, # TFs which recognize ERVs . Restricting retrotransposons: a review . . KEGG . gene_silencing_brite = brite_genes.loc[&#39;Gene silencing&#39;] gene_silencing_brite.index = gene_silencing_brite.index.droplevel(2) . gene_silencing_brite.to_pickle(&#39;targets/gene_silencing_brite.pickle&#39;) . GO . transposon_subgraph, transposon_nodes = GO_subgraph_from_query(&#39;transpos&#39;) . draw_graph(transposon_subgraph) . transposition, RNA-mediated transposition, RNA-mediated transposition transposition transposition, RNA-mediated-&gt;transposition negative regulation of transposon integration negative regulation of transposon integration regulation of transposon integration regulation of transposon integration negative regulation of transposon integration-&gt;regulation of transposon integration negative regulation of transposition negative regulation of transposition negative regulation of transposon integration-&gt;negative regulation of transposition regulation of transposition regulation of transposition regulation of transposon integration-&gt;regulation of transposition negative regulation of transposition-&gt;regulation of transposition regulation of transposition, DNA-mediated regulation of transposition, DNA-mediated regulation of transposition, DNA-mediated-&gt;regulation of transposition positive regulation of transposition positive regulation of transposition positive regulation of transposition-&gt;regulation of transposition intramolecular oxidoreductase activity, transposing C=C bonds intramolecular oxidoreductase activity, transposing C=C bonds positive regulation of transposition, RNA-mediated positive regulation of transposition, RNA-mediated positive regulation of transposition, RNA-mediated-&gt;positive regulation of transposition regulation of transposition, RNA-mediated regulation of transposition, RNA-mediated positive regulation of transposition, RNA-mediated-&gt;regulation of transposition, RNA-mediated regulation of transposition, RNA-mediated-&gt;regulation of transposition negative regulation of transposition, DNA-mediated negative regulation of transposition, DNA-mediated negative regulation of transposition, DNA-mediated-&gt;negative regulation of transposition negative regulation of transposition, DNA-mediated-&gt;regulation of transposition, DNA-mediated transposon integration involved in RNA-mediated transposition transposon integration involved in RNA-mediated transposition transposon integration involved in RNA-mediated transposition-&gt;transposition, RNA-mediated transposon integration transposon integration transposon integration involved in RNA-mediated transposition-&gt;transposon integration transposon integration-&gt;transposition replicative transposition, DNA-mediated replicative transposition, DNA-mediated transposition, DNA-mediated transposition, DNA-mediated replicative transposition, DNA-mediated-&gt;transposition, DNA-mediated transposition, DNA-mediated-&gt;transposition reverse transcription involved in RNA-mediated transposition reverse transcription involved in RNA-mediated transposition reverse transcription involved in RNA-mediated transposition-&gt;transposition, RNA-mediated positive regulation of transposon integration positive regulation of transposon integration positive regulation of transposon integration-&gt;regulation of transposon integration positive regulation of transposon integration-&gt;positive regulation of transposition MITE transposition MITE transposition MITE transposition-&gt;transposition negative regulation of transposition, RNA-mediated negative regulation of transposition, RNA-mediated negative regulation of transposition, RNA-mediated-&gt;negative regulation of transposition negative regulation of transposition, RNA-mediated-&gt;regulation of transposition, RNA-mediated non-replicative transposition, DNA-mediated non-replicative transposition, DNA-mediated non-replicative transposition, DNA-mediated-&gt;transposition, DNA-mediated retrotransposon nucleocapsid retrotransposon nucleocapsid positive regulation of transposition, DNA-mediated positive regulation of transposition, DNA-mediated positive regulation of transposition, DNA-mediated-&gt;regulation of transposition, DNA-mediated positive regulation of transposition, DNA-mediated-&gt;positive regulation of transposition intramolecular oxidoreductase activity, transposing S-S bonds intramolecular oxidoreductase activity, transposing S-S bonds transposase activity transposase activity df = create_GO_by_gene_matrix(transposon_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:45:10.122414 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ transposon_nodes.to_pickle(&#39;targets/transposon_GO.pickle&#39;) . Overlap . KEGG_GO_venn(gene_silencing_brite, transposon_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1aa7fa670&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:45:10.307020 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 2.2 Chromatin modifiers . KEGG . chromatin_remodeling_brite = brite_genes.loc[&#39;Chromatin remodeling factors&#39;] chromatin_remodeling_brite.index = chromatin_remodeling_brite.index.droplevel(2).droplevel(1) . chromatin_remodeling_brite.to_pickle(&#39;targets/chromatin_remodeling_brite.pickle&#39;) . histone_modification_brite = brite_genes.loc[&#39;Histone modification proteins&#39;] histone_modification_brite = drop_nan_index_levels(histone_modification_brite) . histone_modification_brite.to_pickle(&#39;targets/histone_modification_brite.pickle&#39;) . GO . chromatin_remodeling_subgraph, chromatin_remodeling_nodes = GO_subgraph_from_query(&#39;chromatin remodel&#39;) . draw_graph(chromatin_remodeling_subgraph) . chromatin remodeling at centromere chromatin remodeling at centromere chromatin remodeling chromatin remodeling chromatin remodeling at centromere-&gt;chromatin remodeling DNA repair-dependent chromatin remodeling DNA repair-dependent chromatin remodeling DNA repair-dependent chromatin remodeling-&gt;chromatin remodeling ATP-dependent chromatin remodeler activity ATP-dependent chromatin remodeler activity chromatin_remodeling_nodes.to_pickle(&#39;targets/chromatin_remodeling_GO.pickle&#39;) . Overlap . KEGG_GO_venn(chromatin_remodeling_brite, chromatin_remodeling_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1a9343df0&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:45:10.536337 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 2.3 Epigenetic Erosion (heterochromatin loosening) . KEGG . heterochromatin_formation_brite = brite_genes.loc[&#39;Heterochromatin formation proteins&#39;] heterochromatin_formation_brite = drop_nan_index_levels(heterochromatin_formation_brite) . heterochromatin_formation_brite.to_pickle(&#39;targets/heterochromatin_formation_brite.pickle&#39;) . GO . heterochromatin_subgraph, heterochromatin_nodes = GO_subgraph_from_query(&#39;heterochromatin&#39;) . draw_graph(heterochromatin_subgraph) . meiotic attachment of telomeric heterochromatin to spindle pole body meiotic attachment of telomeric heterochromatin to spindle pole body negative regulation of heterochromatin organization negative regulation of heterochromatin organization regulation of heterochromatin organization regulation of heterochromatin organization negative regulation of heterochromatin organization-&gt;regulation of heterochromatin organization siRNA-dependent facultative heterochromatin formation siRNA-dependent facultative heterochromatin formation small non-coding RNA-dependent heterochromatin formation small non-coding RNA-dependent heterochromatin formation siRNA-dependent facultative heterochromatin formation-&gt;small non-coding RNA-dependent heterochromatin formation heterochromatin formation heterochromatin formation small non-coding RNA-dependent heterochromatin formation-&gt;heterochromatin formation alpha-heterochromatin alpha-heterochromatin pericentric heterochromatin pericentric heterochromatin alpha-heterochromatin-&gt;pericentric heterochromatin heterochromatin heterochromatin pericentric heterochromatin-&gt;heterochromatin beta-heterochromatin beta-heterochromatin beta-heterochromatin-&gt;pericentric heterochromatin regulation of rDNA heterochromatin formation regulation of rDNA heterochromatin formation regulation of heterochromatin formation regulation of heterochromatin formation regulation of rDNA heterochromatin formation-&gt;regulation of heterochromatin formation regulation of heterochromatin formation-&gt;regulation of heterochromatin organization protein localization to pericentric heterochromatin protein localization to pericentric heterochromatin protein localization to heterochromatin protein localization to heterochromatin protein localization to pericentric heterochromatin-&gt;protein localization to heterochromatin regulation of siRNA-dependent facultative heterochromatin formation regulation of siRNA-dependent facultative heterochromatin formation regulation of small non-coding RNA-mediated heterochromatin formation regulation of small non-coding RNA-mediated heterochromatin formation regulation of siRNA-dependent facultative heterochromatin formation-&gt;regulation of small non-coding RNA-mediated heterochromatin formation regulation of small non-coding RNA-mediated heterochromatin formation-&gt;regulation of heterochromatin formation protein localization to mating-type region heterochromatin protein localization to mating-type region heterochromatin protein localization to mating-type region heterochromatin-&gt;protein localization to heterochromatin silent mating-type cassette heterochromatin formation silent mating-type cassette heterochromatin formation constitutive heterochromatin formation constitutive heterochromatin formation silent mating-type cassette heterochromatin formation-&gt;constitutive heterochromatin formation constitutive heterochromatin formation-&gt;heterochromatin formation nucleolus-associated heterochromatin nucleolus-associated heterochromatin negative regulation of heterochromatin formation negative regulation of heterochromatin formation negative regulation of heterochromatin formation-&gt;negative regulation of heterochromatin organization negative regulation of heterochromatin formation-&gt;regulation of heterochromatin formation heterochromatin organization heterochromatin organization heterochromatin formation-&gt;heterochromatin organization rDNA heterochromatin formation rDNA heterochromatin formation facultative heterochromatin formation facultative heterochromatin formation rDNA heterochromatin formation-&gt;facultative heterochromatin formation facultative heterochromatin formation-&gt;heterochromatin formation inactivation of X chromosome by heterochromatin formation inactivation of X chromosome by heterochromatin formation inactivation of X chromosome by heterochromatin formation-&gt;constitutive heterochromatin formation subtelomeric heterochromatin formation subtelomeric heterochromatin formation subtelomeric heterochromatin formation-&gt;constitutive heterochromatin formation siRNA-dependent pericentric heterochromatin formation siRNA-dependent pericentric heterochromatin formation pericentric heterochromatin formation pericentric heterochromatin formation siRNA-dependent pericentric heterochromatin formation-&gt;pericentric heterochromatin formation pericentric heterochromatin formation-&gt;constitutive heterochromatin formation regulation of silent mating-type cassette heterochromatin formation regulation of silent mating-type cassette heterochromatin formation regulation of silent mating-type cassette heterochromatin formation-&gt;regulation of heterochromatin formation maintenance of protein localization to heterochromatin maintenance of protein localization to heterochromatin maintenance of protein localization to heterochromatin-&gt;protein localization to heterochromatin protein localization to subtelomeric heterochromatin protein localization to subtelomeric heterochromatin protein localization to subtelomeric heterochromatin-&gt;protein localization to heterochromatin heterochromatin domain heterochromatin domain heterochromatin domain-&gt;heterochromatin positive regulation of DNA methylation-dependent heterochromatin formation positive regulation of DNA methylation-dependent heterochromatin formation positive regulation of heterochromatin formation positive regulation of heterochromatin formation positive regulation of DNA methylation-dependent heterochromatin formation-&gt;positive regulation of heterochromatin formation regulation of DNA methylation-dependent heterochromatin formation regulation of DNA methylation-dependent heterochromatin formation positive regulation of DNA methylation-dependent heterochromatin formation-&gt;regulation of DNA methylation-dependent heterochromatin formation positive regulation of heterochromatin formation-&gt;regulation of heterochromatin formation positive regulation of heterochromatin organization positive regulation of heterochromatin organization positive regulation of heterochromatin formation-&gt;positive regulation of heterochromatin organization regulation of DNA methylation-dependent heterochromatin formation-&gt;regulation of heterochromatin formation regulation of siRNA-independent facultative heterochromatin formation regulation of siRNA-independent facultative heterochromatin formation regulation of siRNA-independent facultative heterochromatin formation-&gt;regulation of heterochromatin formation negative regulation of DNA methylation-dependent heterochromatin formation negative regulation of DNA methylation-dependent heterochromatin formation negative regulation of DNA methylation-dependent heterochromatin formation-&gt;negative regulation of heterochromatin formation negative regulation of DNA methylation-dependent heterochromatin formation-&gt;regulation of DNA methylation-dependent heterochromatin formation positive regulation of rDNA heterochromatin formation positive regulation of rDNA heterochromatin formation positive regulation of rDNA heterochromatin formation-&gt;regulation of rDNA heterochromatin formation positive regulation of rDNA heterochromatin formation-&gt;positive regulation of heterochromatin formation heterochromatin-nuclear membrane anchor activity heterochromatin-nuclear membrane anchor activity pericentric heterochromatin organization pericentric heterochromatin organization pericentric heterochromatin organization-&gt;heterochromatin formation mating-type region heterochromatin mating-type region heterochromatin mating-type region heterochromatin-&gt;heterochromatin positive regulation of pericentric heterochromatin formation positive regulation of pericentric heterochromatin formation positive regulation of pericentric heterochromatin formation-&gt;positive regulation of heterochromatin formation regulation of pericentric heterochromatin formation regulation of pericentric heterochromatin formation positive regulation of pericentric heterochromatin formation-&gt;regulation of pericentric heterochromatin formation regulation of pericentric heterochromatin formation-&gt;regulation of heterochromatin formation intercalary heterochromatin intercalary heterochromatin intercalary heterochromatin-&gt;heterochromatin positive regulation of heterochromatin organization-&gt;regulation of heterochromatin organization CLRC complex localization to heterochromatin CLRC complex localization to heterochromatin CLRC complex localization to heterochromatin-&gt;protein localization to heterochromatin positive regulation of silent mating-type cassette heterochromatin formation positive regulation of silent mating-type cassette heterochromatin formation positive regulation of silent mating-type cassette heterochromatin formation-&gt;regulation of silent mating-type cassette heterochromatin formation positive regulation of silent mating-type cassette heterochromatin formation-&gt;positive regulation of heterochromatin formation senescence-associated heterochromatin focus senescence-associated heterochromatin focus senescence-associated heterochromatin focus-&gt;heterochromatin siRNA-independent facultative heterochromatin formation siRNA-independent facultative heterochromatin formation siRNA-independent facultative heterochromatin formation-&gt;facultative heterochromatin formation heterochromatin island heterochromatin island heterochromatin island-&gt;heterochromatin heterochromatin boundary formation heterochromatin boundary formation heterochromatin boundary formation-&gt;heterochromatin formation heterochromatin boundary formation-&gt;heterochromatin organization DNA methylation-dependent heterochromatin formation DNA methylation-dependent heterochromatin formation DNA methylation-dependent heterochromatin formation-&gt;facultative heterochromatin formation negative regulation of ribosomal DNA heterochromatin formation negative regulation of ribosomal DNA heterochromatin formation negative regulation of ribosomal DNA heterochromatin formation-&gt;regulation of rDNA heterochromatin formation negative regulation of ribosomal DNA heterochromatin formation-&gt;negative regulation of heterochromatin formation attachment of telomeric heterochromatin to nuclear envelope attachment of telomeric heterochromatin to nuclear envelope silent mating-type cassette heterochromatin organization silent mating-type cassette heterochromatin organization silent mating-type cassette heterochromatin organization-&gt;constitutive heterochromatin formation negative regulation of silent mating-type cassette heterochromatin formation negative regulation of silent mating-type cassette heterochromatin formation negative regulation of silent mating-type cassette heterochromatin formation-&gt;negative regulation of heterochromatin formation negative regulation of silent mating-type cassette heterochromatin formation-&gt;regulation of silent mating-type cassette heterochromatin formation subtelomeric heterochromatin subtelomeric heterochromatin subtelomeric heterochromatin-&gt;heterochromatin negative regulation of small non-coding RNA-mediated heterochromatin formation negative regulation of small non-coding RNA-mediated heterochromatin formation negative regulation of small non-coding RNA-mediated heterochromatin formation-&gt;regulation of small non-coding RNA-mediated heterochromatin formation negative regulation of small non-coding RNA-mediated heterochromatin formation-&gt;negative regulation of heterochromatin formation rDNA heterochromatin rDNA heterochromatin rDNA heterochromatin-&gt;heterochromatin heterochromatin_nodes.to_pickle(&#39;targets/heterochromatin_GO.pickle&#39;) . Overlap . KEGG_GO_venn(heterochromatin_formation_brite, heterochromatin_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1a96a5df0&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:45:10.771697 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 2.4 histones are limiting . KEGG . nucleosome_assembly_brite = brite_genes.loc[&#39;Nucleosome assembly factors&#39;] nucleosome_assembly_brite = drop_nan_index_levels(nucleosome_assembly_brite) . nucleosome_assembly_brite.to_pickle(&#39;targets/nucleosome_assembly_brite.pickle&#39;) . GO . nucleosome_assembly_subgraph, nucleosome_assembly_nodes = GO_subgraph_from_query(&#39;nucleosome assembly&#39;) . draw_graph(nucleosome_assembly_subgraph) . nucleosome assembly nucleosome assembly nucleosome_assembly_nodes.to_pickle(&#39;targets/nucleosome_assembly_GO.pickle&#39;) . Overlap . KEGG_GO_venn(nucleosome_assembly_brite, nucleosome_assembly_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1a925ffd0&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:45:10.982377 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 2.5 Nuclear Lamin defects . Image(&#39;https://upload.wikimedia.org/wikipedia/commons/b/b4/Structure_and_function_of_the_nuclear_lamina.jpg&#39;) . KEGG . nuclear_lamin_brite_id = &#39;ko04812+K12641&#39; nuclear_lamin_brite = get_KEGG_BRITE_entry(nuclear_lamin_brite_id) . nuclear_lamin_brite = nuclear_lamin_brite.loc[&#39;Eukaryotic cytoskeleton proteins&#39;, &#39;Intermediate filaments&#39;, &#39;Intermediate filaments&#39;, &#39;Type V: Nuclear lamins&#39;] nuclear_lamin_brite.index = [&#39;Nuclear lamins&#39;]*len(nuclear_lamin_brite) . /var/folders/mq/yzq45gh52xn7zz498z7cjtkw0000gn/T/ipykernel_10928/5367033.py:1: PerformanceWarning: indexing past lexsort depth may impact performance. nuclear_lamin_brite = nuclear_lamin_brite.loc[&#39;Eukaryotic cytoskeleton proteins&#39;, &#39;Intermediate filaments&#39;, &#39;Intermediate filaments&#39;, &#39;Type V: Nuclear lamins&#39;] . nuclear_lamin_brite.to_pickle(&#39;targets/nuclear_lamin_brite.pickle&#39;) . GO . nuclear_lamin_subgraph, nuclear_lamin_nodes = GO_subgraph_from_query(&#39;nuclear lamin&#39;) . draw_graph(nuclear_lamin_subgraph) . nuclear lamina nuclear lamina host cell nuclear lamina host cell nuclear lamina nuclear_lamin_nodes.to_pickle(&#39;targets/nuclear_lamin_GO.pickle&#39;) . Overlap . KEGG_GO_venn(nuclear_lamin_brite, nuclear_lamin_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1a9d43bb0&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:45:12.529306 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 2.6 neurons entering cell cycle? Cell cycle markers . KEGG . cell_cycle_pathway_id = &#39;hsa04110&#39; Image(REST.kegg_get(cell_cycle_pathway_id, &#39;image&#39;).read()) . cell_cycle_pathway_genes = get_KEGG_pathway_gene_members(cell_cycle_pathway_id) . cell_cycle_pathway_genes.to_pickle(&#39;cell_cycle_pathway.pickle&#39;) . GO . cell_cycle_subgraph, cell_cycle_nodes = GO_subgraph_from_query(&#39;cell cycle&#39;) df = create_GO_by_gene_matrix(cell_cycle_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;png&#39;) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . draw_graph(cell_cycle_subgraph) . regulation of transcription involved in G1/S transition of mitotic cell cycle regulation of transcription involved in G1/S transition of mitotic cell cycle mitotic cell cycle process mitotic cell cycle process regulation of transcription involved in G1/S transition of mitotic cell cycle-&gt;mitotic cell cycle process G1/S transition of mitotic cell cycle G1/S transition of mitotic cell cycle regulation of transcription involved in G1/S transition of mitotic cell cycle-&gt;G1/S transition of mitotic cell cycle mitotic cell cycle mitotic cell cycle mitotic cell cycle process-&gt;mitotic cell cycle cell cycle process cell cycle process mitotic cell cycle process-&gt;cell cycle process cell cycle G1/S phase transition cell cycle G1/S phase transition G1/S transition of mitotic cell cycle-&gt;cell cycle G1/S phase transition mitotic cell cycle phase transition mitotic cell cycle phase transition G1/S transition of mitotic cell cycle-&gt;mitotic cell cycle phase transition meiotic cell cycle checkpoint signaling meiotic cell cycle checkpoint signaling cell cycle checkpoint signaling cell cycle checkpoint signaling meiotic cell cycle checkpoint signaling-&gt;cell cycle checkpoint signaling meiotic cell cycle process meiotic cell cycle process meiotic cell cycle checkpoint signaling-&gt;meiotic cell cycle process negative regulation of cell cycle phase transition negative regulation of cell cycle phase transition cell cycle checkpoint signaling-&gt;negative regulation of cell cycle phase transition meiotic cell cycle process-&gt;cell cycle process meiotic cell cycle meiotic cell cycle meiotic cell cycle process-&gt;meiotic cell cycle mitotic cell cycle, embryonic mitotic cell cycle, embryonic mitotic cell cycle, embryonic-&gt;mitotic cell cycle cell cycle cell cycle mitotic cell cycle-&gt;cell cycle regulation of mitotic cell cycle, embryonic regulation of mitotic cell cycle, embryonic regulation of mitotic cell cycle regulation of mitotic cell cycle regulation of mitotic cell cycle, embryonic-&gt;regulation of mitotic cell cycle regulation of cell cycle regulation of cell cycle regulation of mitotic cell cycle-&gt;regulation of cell cycle meiosis II cell cycle process meiosis II cell cycle process meiosis II cell cycle process-&gt;meiotic cell cycle process mitotic cell cycle checkpoint signaling mitotic cell cycle checkpoint signaling mitotic cell cycle checkpoint signaling-&gt;mitotic cell cycle process mitotic cell cycle checkpoint signaling-&gt;cell cycle checkpoint signaling negative regulation of mitotic cell cycle negative regulation of mitotic cell cycle mitotic cell cycle checkpoint signaling-&gt;negative regulation of mitotic cell cycle negative regulation of mitotic cell cycle-&gt;regulation of mitotic cell cycle negative regulation of cell cycle negative regulation of cell cycle negative regulation of mitotic cell cycle-&gt;negative regulation of cell cycle positive regulation of cell cycle switching, mitotic to meiotic cell cycle positive regulation of cell cycle switching, mitotic to meiotic cell cycle positive regulation of cell cycle process positive regulation of cell cycle process positive regulation of cell cycle switching, mitotic to meiotic cell cycle-&gt;positive regulation of cell cycle process positive regulation of meiotic cell cycle positive regulation of meiotic cell cycle positive regulation of cell cycle switching, mitotic to meiotic cell cycle-&gt;positive regulation of meiotic cell cycle regulation of cell cycle switching, mitotic to meiotic cell cycle regulation of cell cycle switching, mitotic to meiotic cell cycle positive regulation of cell cycle switching, mitotic to meiotic cell cycle-&gt;regulation of cell cycle switching, mitotic to meiotic cell cycle regulation of cell cycle process regulation of cell cycle process positive regulation of cell cycle process-&gt;regulation of cell cycle process positive regulation of cell cycle positive regulation of cell cycle positive regulation of cell cycle process-&gt;positive regulation of cell cycle positive regulation of meiotic cell cycle-&gt;positive regulation of cell cycle regulation of meiotic cell cycle regulation of meiotic cell cycle positive regulation of meiotic cell cycle-&gt;regulation of meiotic cell cycle regulation of cell cycle switching, mitotic to meiotic cell cycle-&gt;regulation of mitotic cell cycle regulation of cell cycle switching, mitotic to meiotic cell cycle-&gt;regulation of cell cycle process regulation of cell cycle switching, mitotic to meiotic cell cycle-&gt;regulation of meiotic cell cycle negative regulation of G1/S transition of mitotic cell cycle negative regulation of G1/S transition of mitotic cell cycle negative regulation of mitotic cell cycle phase transition negative regulation of mitotic cell cycle phase transition negative regulation of G1/S transition of mitotic cell cycle-&gt;negative regulation of mitotic cell cycle phase transition regulation of G1/S transition of mitotic cell cycle regulation of G1/S transition of mitotic cell cycle negative regulation of G1/S transition of mitotic cell cycle-&gt;regulation of G1/S transition of mitotic cell cycle negative regulation of cell cycle G1/S phase transition negative regulation of cell cycle G1/S phase transition negative regulation of G1/S transition of mitotic cell cycle-&gt;negative regulation of cell cycle G1/S phase transition negative regulation of mitotic cell cycle phase transition-&gt;negative regulation of mitotic cell cycle negative regulation of mitotic cell cycle phase transition-&gt;negative regulation of cell cycle phase transition regulation of mitotic cell cycle phase transition regulation of mitotic cell cycle phase transition negative regulation of mitotic cell cycle phase transition-&gt;regulation of mitotic cell cycle phase transition regulation of G1/S transition of mitotic cell cycle-&gt;regulation of mitotic cell cycle phase transition regulation of cell cycle G1/S phase transition regulation of cell cycle G1/S phase transition regulation of G1/S transition of mitotic cell cycle-&gt;regulation of cell cycle G1/S phase transition negative regulation of cell cycle G1/S phase transition-&gt;negative regulation of cell cycle phase transition negative regulation of cell cycle G1/S phase transition-&gt;regulation of cell cycle G1/S phase transition meiotic cell cycle phase meiotic cell cycle phase cell cycle phase cell cycle phase meiotic cell cycle phase-&gt;cell cycle phase response to cell cycle checkpoint signaling response to cell cycle checkpoint signaling signal transduction involved in cell cycle switching, mitotic to meiotic cell cycle signal transduction involved in cell cycle switching, mitotic to meiotic cell cycle cell cycle switching, mitotic to meiotic cell cycle cell cycle switching, mitotic to meiotic cell cycle signal transduction involved in cell cycle switching, mitotic to meiotic cell cycle-&gt;cell cycle switching, mitotic to meiotic cell cycle signal transduction involved in cell cycle switching, mitotic to meiotic cell cycle-&gt;cell cycle process cell cycle switching, mitotic to meiotic cell cycle-&gt;negative regulation of mitotic cell cycle cell cycle switching, mitotic to meiotic cell cycle-&gt;positive regulation of meiotic cell cycle cell cycle switching cell cycle switching cell cycle switching, mitotic to meiotic cell cycle-&gt;cell cycle switching cell cycle process-&gt;cell cycle positive regulation of response to cell cycle checkpoint signaling positive regulation of response to cell cycle checkpoint signaling regulation of response to cell cycle checkpoint signaling regulation of response to cell cycle checkpoint signaling positive regulation of response to cell cycle checkpoint signaling-&gt;regulation of response to cell cycle checkpoint signaling endomitotic cell cycle endomitotic cell cycle endomitotic cell cycle-&gt;mitotic cell cycle positive regulation of syncytial blastoderm mitotic cell cycle positive regulation of syncytial blastoderm mitotic cell cycle positive regulation of mitotic cell cycle, embryonic positive regulation of mitotic cell cycle, embryonic positive regulation of syncytial blastoderm mitotic cell cycle-&gt;positive regulation of mitotic cell cycle, embryonic regulation of syncytial blastoderm mitotic cell cycle regulation of syncytial blastoderm mitotic cell cycle positive regulation of syncytial blastoderm mitotic cell cycle-&gt;regulation of syncytial blastoderm mitotic cell cycle positive regulation of mitotic cell cycle, embryonic-&gt;regulation of mitotic cell cycle, embryonic positive regulation of mitotic cell cycle positive regulation of mitotic cell cycle positive regulation of mitotic cell cycle, embryonic-&gt;positive regulation of mitotic cell cycle regulation of syncytial blastoderm mitotic cell cycle-&gt;regulation of mitotic cell cycle, embryonic regulation of syncytial blastoderm mitotic cell cycle-&gt;cell cycle process regulation of cell cycle process-&gt;regulation of cell cycle negative regulation of metaphase/anaphase transition of cell cycle negative regulation of metaphase/anaphase transition of cell cycle regulation of metaphase/anaphase transition of cell cycle regulation of metaphase/anaphase transition of cell cycle negative regulation of metaphase/anaphase transition of cell cycle-&gt;regulation of metaphase/anaphase transition of cell cycle negative regulation of metaphase/anaphase transition of cell cycle-&gt;negative regulation of cell cycle phase transition regulation of cell cycle phase transition regulation of cell cycle phase transition regulation of metaphase/anaphase transition of cell cycle-&gt;regulation of cell cycle phase transition negative regulation of cell cycle phase transition-&gt;regulation of cell cycle phase transition negative regulation of cell cycle process negative regulation of cell cycle process negative regulation of cell cycle phase transition-&gt;negative regulation of cell cycle process cell cycle DNA replication DNA unwinding cell cycle DNA replication DNA unwinding cell cycle DNA replication DNA unwinding-&gt;cell cycle process cell cycle DNA replication cell cycle DNA replication cell cycle DNA replication DNA unwinding-&gt;cell cycle DNA replication cell cycle DNA replication-&gt;cell cycle process positive regulation of metaphase/anaphase transition of meiotic cell cycle positive regulation of metaphase/anaphase transition of meiotic cell cycle regulation of metaphase/anaphase transition of meiotic cell cycle regulation of metaphase/anaphase transition of meiotic cell cycle positive regulation of metaphase/anaphase transition of meiotic cell cycle-&gt;regulation of metaphase/anaphase transition of meiotic cell cycle positive regulation of metaphase/anaphase transition of cell cycle positive regulation of metaphase/anaphase transition of cell cycle positive regulation of metaphase/anaphase transition of meiotic cell cycle-&gt;positive regulation of metaphase/anaphase transition of cell cycle positive regulation of meiotic cell cycle phase transition positive regulation of meiotic cell cycle phase transition positive regulation of metaphase/anaphase transition of meiotic cell cycle-&gt;positive regulation of meiotic cell cycle phase transition regulation of metaphase/anaphase transition of meiotic cell cycle-&gt;regulation of metaphase/anaphase transition of cell cycle regulation of meiotic cell cycle phase transition regulation of meiotic cell cycle phase transition regulation of metaphase/anaphase transition of meiotic cell cycle-&gt;regulation of meiotic cell cycle phase transition positive regulation of metaphase/anaphase transition of cell cycle-&gt;regulation of metaphase/anaphase transition of cell cycle positive regulation of cell cycle phase transition positive regulation of cell cycle phase transition positive regulation of metaphase/anaphase transition of cell cycle-&gt;positive regulation of cell cycle phase transition positive regulation of meiotic cell cycle phase transition-&gt;positive regulation of meiotic cell cycle positive regulation of meiotic cell cycle phase transition-&gt;regulation of meiotic cell cycle phase transition positive regulation of meiotic cell cycle phase transition-&gt;positive regulation of cell cycle phase transition cell cycle switching-&gt;cell cycle process regulation of cell cycle phase transition-&gt;regulation of cell cycle process DNA damage response, signal transduction by p53 class mediator resulting in cell cycle arrest DNA damage response, signal transduction by p53 class mediator resulting in cell cycle arrest positive regulation of G2/MI transition of meiotic cell cycle positive regulation of G2/MI transition of meiotic cell cycle positive regulation of G2/MI transition of meiotic cell cycle-&gt;positive regulation of meiotic cell cycle phase transition regulation of G2/MI transition of meiotic cell cycle regulation of G2/MI transition of meiotic cell cycle positive regulation of G2/MI transition of meiotic cell cycle-&gt;regulation of G2/MI transition of meiotic cell cycle positive regulation of cell cycle G2/M phase transition positive regulation of cell cycle G2/M phase transition positive regulation of G2/MI transition of meiotic cell cycle-&gt;positive regulation of cell cycle G2/M phase transition regulation of G2/MI transition of meiotic cell cycle-&gt;regulation of meiotic cell cycle phase transition regulation of cell cycle G2/M phase transition regulation of cell cycle G2/M phase transition regulation of G2/MI transition of meiotic cell cycle-&gt;regulation of cell cycle G2/M phase transition positive regulation of cell cycle G2/M phase transition-&gt;regulation of cell cycle G2/M phase transition positive regulation of cell cycle G2/M phase transition-&gt;positive regulation of cell cycle phase transition traversing start control point of mitotic cell cycle traversing start control point of mitotic cell cycle positive regulation of G1/S transition of mitotic cell cycle positive regulation of G1/S transition of mitotic cell cycle traversing start control point of mitotic cell cycle-&gt;positive regulation of G1/S transition of mitotic cell cycle positive regulation of G1/S transition of mitotic cell cycle-&gt;regulation of G1/S transition of mitotic cell cycle positive regulation of mitotic cell cycle phase transition positive regulation of mitotic cell cycle phase transition positive regulation of G1/S transition of mitotic cell cycle-&gt;positive regulation of mitotic cell cycle phase transition positive regulation of cell cycle G1/S phase transition positive regulation of cell cycle G1/S phase transition positive regulation of G1/S transition of mitotic cell cycle-&gt;positive regulation of cell cycle G1/S phase transition meiotic cell cycle phase transition meiotic cell cycle phase transition meiotic cell cycle phase transition-&gt;meiotic cell cycle process cell cycle phase transition cell cycle phase transition meiotic cell cycle phase transition-&gt;cell cycle phase transition cell cycle phase transition-&gt;cell cycle process re-entry into mitotic cell cycle after pheromone arrest re-entry into mitotic cell cycle after pheromone arrest re-entry into mitotic cell cycle re-entry into mitotic cell cycle re-entry into mitotic cell cycle after pheromone arrest-&gt;re-entry into mitotic cell cycle re-entry into mitotic cell cycle-&gt;cell cycle process positive regulation of cell cycle-&gt;regulation of cell cycle cell cycle comprising mitosis without cytokinesis cell cycle comprising mitosis without cytokinesis cell cycle comprising mitosis without cytokinesis-&gt;mitotic cell cycle G2/MI transition of meiotic cell cycle G2/MI transition of meiotic cell cycle G2/MI transition of meiotic cell cycle-&gt;meiotic cell cycle phase transition meiosis I cell cycle process meiosis I cell cycle process G2/MI transition of meiotic cell cycle-&gt;meiosis I cell cycle process cell cycle G2/M phase transition cell cycle G2/M phase transition G2/MI transition of meiotic cell cycle-&gt;cell cycle G2/M phase transition meiosis I cell cycle process-&gt;meiotic cell cycle process cell cycle G2/M phase transition-&gt;cell cycle phase transition activation of mitotic cell cycle spindle assembly checkpoint activation of mitotic cell cycle spindle assembly checkpoint positive regulation of mitotic cell cycle spindle assembly checkpoint positive regulation of mitotic cell cycle spindle assembly checkpoint activation of mitotic cell cycle spindle assembly checkpoint-&gt;positive regulation of mitotic cell cycle spindle assembly checkpoint positive regulation of mitotic cell cycle spindle assembly checkpoint-&gt;positive regulation of cell cycle process regulation of mitotic cell cycle spindle assembly checkpoint regulation of mitotic cell cycle spindle assembly checkpoint positive regulation of mitotic cell cycle spindle assembly checkpoint-&gt;regulation of mitotic cell cycle spindle assembly checkpoint suppression by virus of G2/M transition of host mitotic cell cycle suppression by virus of G2/M transition of host mitotic cell cycle modulation by virus of host cell cycle modulation by virus of host cell cycle suppression by virus of G2/M transition of host mitotic cell cycle-&gt;modulation by virus of host cell cycle modification by virus of host cell cycle regulation modification by virus of host cell cycle regulation modulation by virus of host cell cycle-&gt;modification by virus of host cell cycle regulation metaphase/anaphase transition of cell cycle metaphase/anaphase transition of cell cycle metaphase/anaphase transition of cell cycle-&gt;cell cycle phase transition response to mitotic cell cycle checkpoint signaling response to mitotic cell cycle checkpoint signaling response to mitotic cell cycle checkpoint signaling-&gt;response to cell cycle checkpoint signaling negative regulation of G1/S transition of mitotic cell cycle by negative regulation of transcription from RNA polymerase II promoter negative regulation of G1/S transition of mitotic cell cycle by negative regulation of transcription from RNA polymerase II promoter negative regulation of G1/S transition of mitotic cell cycle by negative regulation of transcription from RNA polymerase II promoter-&gt;negative regulation of G1/S transition of mitotic cell cycle regulation of nuclear cell cycle DNA replication regulation of nuclear cell cycle DNA replication regulation of nuclear cell cycle DNA replication-&gt;regulation of cell cycle process regulation of meiotic cell cycle phase transition-&gt;regulation of cell cycle phase transition positive regulation of cell cycle checkpoint positive regulation of cell cycle checkpoint regulation of cell cycle checkpoint regulation of cell cycle checkpoint positive regulation of cell cycle checkpoint-&gt;regulation of cell cycle checkpoint regulation of cell cycle checkpoint-&gt;regulation of cell cycle phase transition negative regulation of nuclear cell cycle DNA replication negative regulation of nuclear cell cycle DNA replication negative regulation of nuclear cell cycle DNA replication-&gt;regulation of nuclear cell cycle DNA replication negative regulation of nuclear cell cycle DNA replication-&gt;negative regulation of cell cycle process negative regulation of cell cycle process-&gt;regulation of cell cycle process negative regulation of cell cycle process-&gt;negative regulation of cell cycle positive regulation of G2/M transition of mitotic cell cycle positive regulation of G2/M transition of mitotic cell cycle positive regulation of G2/M transition of mitotic cell cycle-&gt;positive regulation of cell cycle G2/M phase transition regulation of G2/M transition of mitotic cell cycle regulation of G2/M transition of mitotic cell cycle positive regulation of G2/M transition of mitotic cell cycle-&gt;regulation of G2/M transition of mitotic cell cycle positive regulation of G2/M transition of mitotic cell cycle-&gt;positive regulation of mitotic cell cycle phase transition regulation of G2/M transition of mitotic cell cycle-&gt;regulation of cell cycle G2/M phase transition regulation of G2/M transition of mitotic cell cycle-&gt;regulation of mitotic cell cycle phase transition positive regulation of mitotic cell cycle phase transition-&gt;regulation of mitotic cell cycle phase transition positive regulation of mitotic cell cycle phase transition-&gt;positive regulation of cell cycle phase transition positive regulation of mitotic cell cycle phase transition-&gt;positive regulation of mitotic cell cycle mitotic cell cycle G1 arrest in response to pheromone mitotic cell cycle G1 arrest in response to pheromone mitotic cell cycle G1 arrest in response to pheromone-&gt;negative regulation of mitotic cell cycle negative regulation of metaphase/anaphase transition of meiotic cell cycle negative regulation of metaphase/anaphase transition of meiotic cell cycle negative regulation of metaphase/anaphase transition of meiotic cell cycle-&gt;negative regulation of metaphase/anaphase transition of cell cycle negative regulation of metaphase/anaphase transition of meiotic cell cycle-&gt;regulation of metaphase/anaphase transition of meiotic cell cycle negative regulation of meiotic cell cycle phase transition negative regulation of meiotic cell cycle phase transition negative regulation of metaphase/anaphase transition of meiotic cell cycle-&gt;negative regulation of meiotic cell cycle phase transition negative regulation of meiotic cell cycle phase transition-&gt;negative regulation of cell cycle phase transition negative regulation of meiotic cell cycle phase transition-&gt;regulation of meiotic cell cycle phase transition negative regulation of meiotic cell cycle negative regulation of meiotic cell cycle negative regulation of meiotic cell cycle phase transition-&gt;negative regulation of meiotic cell cycle regulation of cell cycle G2/M phase transition-&gt;regulation of cell cycle phase transition regulation of mitotic cell cycle phase transition-&gt;regulation of mitotic cell cycle regulation of mitotic cell cycle phase transition-&gt;regulation of cell cycle phase transition positive regulation of cell cycle phase transition-&gt;positive regulation of cell cycle process positive regulation of cell cycle phase transition-&gt;regulation of cell cycle phase transition negative regulation of mitotic cell cycle DNA replication negative regulation of mitotic cell cycle DNA replication negative regulation of mitotic cell cycle DNA replication-&gt;negative regulation of mitotic cell cycle negative regulation of mitotic cell cycle DNA replication-&gt;negative regulation of nuclear cell cycle DNA replication regulation of mitotic cell cycle DNA replication regulation of mitotic cell cycle DNA replication negative regulation of mitotic cell cycle DNA replication-&gt;regulation of mitotic cell cycle DNA replication regulation of mitotic cell cycle DNA replication-&gt;regulation of mitotic cell cycle regulation of mitotic cell cycle DNA replication-&gt;regulation of nuclear cell cycle DNA replication regulation of meiotic cell cycle-&gt;regulation of cell cycle regulation of preblastoderm mitotic cell cycle regulation of preblastoderm mitotic cell cycle regulation of preblastoderm mitotic cell cycle-&gt;regulation of mitotic cell cycle, embryonic negative regulation of cell cycle-&gt;regulation of cell cycle negative regulation of meiotic cell cycle process involved in oocyte maturation negative regulation of meiotic cell cycle process involved in oocyte maturation negative regulation of meiotic cell cycle process involved in oocyte maturation-&gt;negative regulation of cell cycle process negative regulation of meiotic cell cycle process involved in oocyte maturation-&gt;negative regulation of meiotic cell cycle regulation of meiotic cell cycle process involved in oocyte maturation regulation of meiotic cell cycle process involved in oocyte maturation negative regulation of meiotic cell cycle process involved in oocyte maturation-&gt;regulation of meiotic cell cycle process involved in oocyte maturation negative regulation of meiotic cell cycle-&gt;regulation of meiotic cell cycle negative regulation of meiotic cell cycle-&gt;negative regulation of cell cycle regulation of meiotic cell cycle process involved in oocyte maturation-&gt;regulation of cell cycle process germline cell cycle switching, mitotic to meiotic cell cycle germline cell cycle switching, mitotic to meiotic cell cycle germline cell cycle switching, mitotic to meiotic cell cycle-&gt;cell cycle switching, mitotic to meiotic cell cycle negative regulation of transcription involved in meiotic cell cycle negative regulation of transcription involved in meiotic cell cycle regulation of transcription involved in meiotic cell cycle regulation of transcription involved in meiotic cell cycle negative regulation of transcription involved in meiotic cell cycle-&gt;regulation of transcription involved in meiotic cell cycle regulation of transcription involved in meiotic cell cycle-&gt;meiotic cell cycle negative regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle negative regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle negative regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle-&gt;negative regulation of transcription involved in meiotic cell cycle regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle negative regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle-&gt;regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle-&gt;regulation of transcription involved in meiotic cell cycle negative regulation of cell cycle switching, mitotic to meiotic cell cycle negative regulation of cell cycle switching, mitotic to meiotic cell cycle negative regulation of cell cycle switching, mitotic to meiotic cell cycle-&gt;regulation of cell cycle switching, mitotic to meiotic cell cycle negative regulation of cell cycle switching, mitotic to meiotic cell cycle-&gt;negative regulation of cell cycle process negative regulation of cell cycle switching, mitotic to meiotic cell cycle-&gt;positive regulation of mitotic cell cycle positive regulation of mitotic cell cycle-&gt;regulation of mitotic cell cycle positive regulation of mitotic cell cycle-&gt;positive regulation of cell cycle response to meiotic cell cycle checkpoint signaling response to meiotic cell cycle checkpoint signaling response to meiotic cell cycle checkpoint signaling-&gt;response to cell cycle checkpoint signaling pre-replicative complex assembly involved in nuclear cell cycle DNA replication pre-replicative complex assembly involved in nuclear cell cycle DNA replication pre-replicative complex assembly involved in cell cycle DNA replication pre-replicative complex assembly involved in cell cycle DNA replication pre-replicative complex assembly involved in nuclear cell cycle DNA replication-&gt;pre-replicative complex assembly involved in cell cycle DNA replication pre-replicative complex assembly involved in cell cycle DNA replication-&gt;cell cycle process pre-replicative complex assembly involved in cell cycle DNA replication-&gt;cell cycle DNA replication syncytial blastoderm mitotic cell cycle syncytial blastoderm mitotic cell cycle syncytial blastoderm mitotic cell cycle-&gt;mitotic cell cycle, embryonic syncytial blastoderm mitotic cell cycle-&gt;cell cycle comprising mitosis without cytokinesis meiotic cell cycle-&gt;cell cycle synthesis of RNA primer involved in nuclear cell cycle DNA replication synthesis of RNA primer involved in nuclear cell cycle DNA replication synthesis of RNA primer involved in cell cycle DNA replication synthesis of RNA primer involved in cell cycle DNA replication synthesis of RNA primer involved in nuclear cell cycle DNA replication-&gt;synthesis of RNA primer involved in cell cycle DNA replication synthesis of RNA primer involved in cell cycle DNA replication-&gt;cell cycle process synthesis of RNA primer involved in cell cycle DNA replication-&gt;cell cycle DNA replication cell cycle G1/S phase transition-&gt;cell cycle phase transition abortive mitotic cell cycle abortive mitotic cell cycle abortive mitotic cell cycle-&gt;mitotic cell cycle DNA strand elongation involved in nuclear cell cycle DNA replication DNA strand elongation involved in nuclear cell cycle DNA replication DNA strand elongation involved in cell cycle DNA replication DNA strand elongation involved in cell cycle DNA replication DNA strand elongation involved in nuclear cell cycle DNA replication-&gt;DNA strand elongation involved in cell cycle DNA replication DNA strand elongation involved in cell cycle DNA replication-&gt;cell cycle process DNA strand elongation involved in cell cycle DNA replication-&gt;cell cycle DNA replication negative regulation by symbiont of host cell cycle negative regulation by symbiont of host cell cycle negative regulation by symbiont of host cell cycle-&gt;negative regulation of cell cycle process modulation by symbiont of host cell cycle modulation by symbiont of host cell cycle negative regulation by symbiont of host cell cycle-&gt;modulation by symbiont of host cell cycle modulation by symbiont of host cell cycle-&gt;regulation of cell cycle process G2/M transition of mitotic cell cycle G2/M transition of mitotic cell cycle G2/M transition of mitotic cell cycle-&gt;cell cycle G2/M phase transition G2/M transition of mitotic cell cycle-&gt;mitotic cell cycle phase transition mitotic cell cycle phase transition-&gt;mitotic cell cycle process mitotic cell cycle phase transition-&gt;cell cycle phase transition cell cycle DNA replication initiation cell cycle DNA replication initiation cell cycle DNA replication initiation-&gt;cell cycle process cell cycle DNA replication initiation-&gt;cell cycle DNA replication negative regulation of cell cycle checkpoint negative regulation of cell cycle checkpoint negative regulation of cell cycle checkpoint-&gt;regulation of cell cycle checkpoint negative regulation of cell cycle checkpoint-&gt;positive regulation of cell cycle phase transition chromosome organization involved in meiotic cell cycle chromosome organization involved in meiotic cell cycle chromosome organization involved in meiotic cell cycle-&gt;meiotic cell cycle process negative regulation of G2/MI transition of meiotic cell cycle negative regulation of G2/MI transition of meiotic cell cycle negative regulation of G2/MI transition of meiotic cell cycle-&gt;regulation of G2/MI transition of meiotic cell cycle negative regulation of G2/MI transition of meiotic cell cycle-&gt;negative regulation of meiotic cell cycle phase transition negative regulation of cell cycle G2/M phase transition negative regulation of cell cycle G2/M phase transition negative regulation of G2/MI transition of meiotic cell cycle-&gt;negative regulation of cell cycle G2/M phase transition negative regulation of cell cycle G2/M phase transition-&gt;negative regulation of cell cycle phase transition negative regulation of cell cycle G2/M phase transition-&gt;regulation of cell cycle G2/M phase transition positive regulation of transcription involved in G1/S transition of mitotic cell cycle positive regulation of transcription involved in G1/S transition of mitotic cell cycle positive regulation of transcription involved in G1/S transition of mitotic cell cycle-&gt;regulation of transcription involved in G1/S transition of mitotic cell cycle actin filament reorganization involved in cell cycle actin filament reorganization involved in cell cycle actin filament reorganization involved in cell cycle-&gt;cell cycle process negative regulation of transcription involved in G1/S transition of mitotic cell cycle negative regulation of transcription involved in G1/S transition of mitotic cell cycle negative regulation of transcription involved in G1/S transition of mitotic cell cycle-&gt;regulation of transcription involved in G1/S transition of mitotic cell cycle positive regulation of cell cycle G1/S phase transition-&gt;positive regulation of cell cycle phase transition positive regulation of cell cycle G1/S phase transition-&gt;regulation of cell cycle G1/S phase transition regulation of cell cycle G1/S phase transition-&gt;regulation of cell cycle phase transition meiosis II cell cycle phase meiosis II cell cycle phase meiosis II cell cycle phase-&gt;meiotic cell cycle phase suppression by virus of host cell cycle arrest suppression by virus of host cell cycle arrest suppression by virus of host cell cycle arrest-&gt;modification by virus of host cell cycle regulation modification by virus of host cell cycle regulation-&gt;modulation by symbiont of host cell cycle cell cycle DNA replication DNA ligation cell cycle DNA replication DNA ligation cell cycle DNA replication DNA ligation-&gt;cell cycle process cell cycle DNA replication DNA ligation-&gt;cell cycle DNA replication mitotic G2 cell cycle arrest in response to glucose starvation mitotic G2 cell cycle arrest in response to glucose starvation mitotic G2 cell cycle arrest in response to glucose starvation-&gt;regulation of cell cycle negative regulation of preblastoderm mitotic cell cycle negative regulation of preblastoderm mitotic cell cycle negative regulation of preblastoderm mitotic cell cycle-&gt;regulation of preblastoderm mitotic cell cycle negative regulation of mitotic cell cycle, embryonic negative regulation of mitotic cell cycle, embryonic negative regulation of preblastoderm mitotic cell cycle-&gt;negative regulation of mitotic cell cycle, embryonic negative regulation of mitotic cell cycle, embryonic-&gt;regulation of mitotic cell cycle, embryonic negative regulation of mitotic cell cycle, embryonic-&gt;negative regulation of mitotic cell cycle metaphase/anaphase transition of mitotic cell cycle metaphase/anaphase transition of mitotic cell cycle metaphase/anaphase transition of mitotic cell cycle-&gt;metaphase/anaphase transition of cell cycle metaphase/anaphase transition of mitotic cell cycle-&gt;mitotic cell cycle phase transition negative regulation of G2/M transition of mitotic cell cycle negative regulation of G2/M transition of mitotic cell cycle negative regulation of G2/M transition of mitotic cell cycle-&gt;negative regulation of mitotic cell cycle phase transition negative regulation of G2/M transition of mitotic cell cycle-&gt;regulation of G2/M transition of mitotic cell cycle negative regulation of G2/M transition of mitotic cell cycle-&gt;negative regulation of cell cycle G2/M phase transition preblastoderm mitotic cell cycle preblastoderm mitotic cell cycle preblastoderm mitotic cell cycle-&gt;mitotic cell cycle, embryonic preblastoderm mitotic cell cycle-&gt;cell cycle comprising mitosis without cytokinesis nuclear cell cycle DNA replication initiation nuclear cell cycle DNA replication initiation nuclear cell cycle DNA replication initiation-&gt;cell cycle DNA replication initiation mitotic cell cycle phase mitotic cell cycle phase mitotic cell cycle phase-&gt;cell cycle phase positive regulation of nuclear cell cycle DNA replication positive regulation of nuclear cell cycle DNA replication positive regulation of nuclear cell cycle DNA replication-&gt;positive regulation of cell cycle process positive regulation of nuclear cell cycle DNA replication-&gt;regulation of nuclear cell cycle DNA replication negative regulation of transcription involved in G2/M transition of mitotic cell cycle negative regulation of transcription involved in G2/M transition of mitotic cell cycle regulation of transcription involved in G2/M transition of mitotic cell cycle regulation of transcription involved in G2/M transition of mitotic cell cycle negative regulation of transcription involved in G2/M transition of mitotic cell cycle-&gt;regulation of transcription involved in G2/M transition of mitotic cell cycle regulation of transcription involved in G2/M transition of mitotic cell cycle-&gt;mitotic cell cycle process regulation of transcription involved in G2/M transition of mitotic cell cycle-&gt;G2/M transition of mitotic cell cycle positive regulation of meiotic cell cycle process involved in oocyte maturation positive regulation of meiotic cell cycle process involved in oocyte maturation positive regulation of meiotic cell cycle process involved in oocyte maturation-&gt;positive regulation of cell cycle process positive regulation of meiotic cell cycle process involved in oocyte maturation-&gt;positive regulation of meiotic cell cycle positive regulation of meiotic cell cycle process involved in oocyte maturation-&gt;regulation of meiotic cell cycle process involved in oocyte maturation positive regulation of G2/M transition of mitotic cell cycle involved in cellular response to nitrogen starvation positive regulation of G2/M transition of mitotic cell cycle involved in cellular response to nitrogen starvation positive regulation of G2/M transition of mitotic cell cycle involved in cellular response to nitrogen starvation-&gt;positive regulation of G2/M transition of mitotic cell cycle positive regulation of preblastoderm mitotic cell cycle positive regulation of preblastoderm mitotic cell cycle positive regulation of preblastoderm mitotic cell cycle-&gt;positive regulation of mitotic cell cycle, embryonic positive regulation of preblastoderm mitotic cell cycle-&gt;regulation of preblastoderm mitotic cell cycle response to mitotic cell cycle spindle orientation checkpoint signaling response to mitotic cell cycle spindle orientation checkpoint signaling metaphase/anaphase transition of meiotic cell cycle metaphase/anaphase transition of meiotic cell cycle metaphase/anaphase transition of meiotic cell cycle-&gt;meiotic cell cycle phase transition metaphase/anaphase transition of meiotic cell cycle-&gt;metaphase/anaphase transition of cell cycle cell cycle DNA replication maintenance of fidelity cell cycle DNA replication maintenance of fidelity cell cycle DNA replication maintenance of fidelity-&gt;cell cycle process cell cycle DNA replication maintenance of fidelity-&gt;cell cycle DNA replication first cell cycle pseudocleavage first cell cycle pseudocleavage response to mitotic cell cycle spindle assembly checkpoint signaling response to mitotic cell cycle spindle assembly checkpoint signaling regulation of establishment of actomyosin contractile ring localization involved in mitotic cell cycle regulation of establishment of actomyosin contractile ring localization involved in mitotic cell cycle positive regulation of transcription involved in G2/M transition of mitotic cell cycle positive regulation of transcription involved in G2/M transition of mitotic cell cycle positive regulation of transcription involved in G2/M transition of mitotic cell cycle-&gt;regulation of transcription involved in G2/M transition of mitotic cell cycle meiosis I cell cycle phase meiosis I cell cycle phase meiosis I cell cycle phase-&gt;meiotic cell cycle phase positive regulation of mitotic cell cycle DNA replication positive regulation of mitotic cell cycle DNA replication positive regulation of mitotic cell cycle DNA replication-&gt;regulation of mitotic cell cycle DNA replication positive regulation of mitotic cell cycle DNA replication-&gt;positive regulation of mitotic cell cycle positive regulation of mitotic cell cycle DNA replication-&gt;positive regulation of nuclear cell cycle DNA replication positive regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle positive regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle positive regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle-&gt;regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle positive regulation of transcription involved in meiotic cell cycle positive regulation of transcription involved in meiotic cell cycle positive regulation of transcription from RNA polymerase II promoter involved in meiotic cell cycle-&gt;positive regulation of transcription involved in meiotic cell cycle positive regulation of transcription involved in meiotic cell cycle-&gt;regulation of transcription involved in meiotic cell cycle negative regulation of syncytial blastoderm mitotic cell cycle negative regulation of syncytial blastoderm mitotic cell cycle negative regulation of syncytial blastoderm mitotic cell cycle-&gt;regulation of syncytial blastoderm mitotic cell cycle negative regulation of syncytial blastoderm mitotic cell cycle-&gt;negative regulation of mitotic cell cycle, embryonic meiotic cell cycle process involved in oocyte maturation meiotic cell cycle process involved in oocyte maturation meiotic cell cycle process involved in oocyte maturation-&gt;meiotic cell cycle process cell cycle DNA replication termination cell cycle DNA replication termination cell cycle DNA replication termination-&gt;cell cycle process cell cycle DNA replication termination-&gt;cell cycle DNA replication cell_cycle_nodes.to_pickle(&#39;targets/cell_cycle_GO.pickle&#39;) . Overlap . KEGG_GO_venn(cell_cycle_pathway_genes, cell_cycle_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1a9edbf40&gt; . 3. Inflammation, cytokines, cGAS-STING, senescence programs, inflammasome activation . pd.set_option(&#39;display.max_rows&#39;, 200) matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;svg&#39;) . 3.1 Inflammation . KEGG . chemokine_pathway_id = &#39;hsa04062&#39; TNF_pathway_id = &#39;hsa04668&#39; complement_pathway_id = &#39;hsa04610&#39; leukocyte_transendothelial_migration_pathway_id = &#39;hsa04670&#39; . Image(REST.kegg_get(chemokine_pathway_id, &#39;image&#39;).read()) Image(REST.kegg_get(TNF_pathway_id, &#39;image&#39;).read()) Image(REST.kegg_get(complement_pathway_id, &#39;image&#39;).read()) Image(REST.kegg_get(leukocyte_transendothelial_migration_pathway_id, &#39;image&#39;).read()) . chemokine_pathway_genes = get_KEGG_pathway_gene_members(chemokine_pathway_id) TNF_pathway_genes = get_KEGG_pathway_gene_members(TNF_pathway_id) complement_pathway_genes = get_KEGG_pathway_gene_members(complement_pathway_id) leukocyte_transendothelial_migration_pathway_genes = get_KEGG_pathway_gene_members(leukocyte_transendothelial_migration_pathway_id) . chemokine_pathway_genes.index = [&#39;Chemokine signaling pathway&#39;]*len(chemokine_pathway_genes) TNF_pathway_genes.index = [&#39;TNF signaling pathway&#39;]*len(TNF_pathway_genes) complement_pathway_genes.index = [&#39;Complement and coagulation cascades&#39;]*len(complement_pathway_genes) leukocyte_transendothelial_migration_pathway_genes.index = [&#39;Leukocyte transendothelial migration&#39;]*len(leukocyte_transendothelial_migration_pathway_genes) inflammation_genes = pd.concat((chemokine_pathway_genes,TNF_pathway_genes,complement_pathway_genes,leukocyte_transendothelial_migration_pathway_genes)) inflammation_genes.to_pickle(&#39;targets/inflammation_brite.pickle&#39;) . GO . inflammation_subgraph, inflammation_nodes = GO_subgraph_from_query(&#39;inflammat&#39;) df = create_GO_by_gene_matrix(inflammation_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;png&#39;) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . draw_graph(inflammation_subgraph) . regulation of acute inflammatory response to non-antigenic stimulus regulation of acute inflammatory response to non-antigenic stimulus regulation of acute inflammatory response regulation of acute inflammatory response regulation of acute inflammatory response to non-antigenic stimulus-&gt;regulation of acute inflammatory response regulation of inflammatory response regulation of inflammatory response regulation of acute inflammatory response-&gt;regulation of inflammatory response regulation of cytokine production involved in inflammatory response regulation of cytokine production involved in inflammatory response negative regulation of inflammatory response negative regulation of inflammatory response negative regulation of inflammatory response-&gt;regulation of inflammatory response negative regulation of neuroinflammatory response negative regulation of neuroinflammatory response negative regulation of neuroinflammatory response-&gt;negative regulation of inflammatory response regulation of neuroinflammatory response regulation of neuroinflammatory response negative regulation of neuroinflammatory response-&gt;regulation of neuroinflammatory response regulation of neuroinflammatory response-&gt;regulation of inflammatory response negative regulation of inflammatory response to wounding negative regulation of inflammatory response to wounding negative regulation of inflammatory response to wounding-&gt;negative regulation of inflammatory response regulation of inflammatory response to wounding regulation of inflammatory response to wounding negative regulation of inflammatory response to wounding-&gt;regulation of inflammatory response to wounding regulation of inflammatory response to wounding-&gt;regulation of inflammatory response regulation of chronic inflammatory response regulation of chronic inflammatory response regulation of chronic inflammatory response-&gt;regulation of inflammatory response positive regulation of inflammatory response positive regulation of inflammatory response positive regulation of inflammatory response-&gt;regulation of inflammatory response lysosomal enzyme secretion involved in inflammatory response lysosomal enzyme secretion involved in inflammatory response lysosomal enzyme production involved in inflammatory response lysosomal enzyme production involved in inflammatory response lysosomal enzyme secretion involved in inflammatory response-&gt;lysosomal enzyme production involved in inflammatory response production of molecular mediator involved in inflammatory response production of molecular mediator involved in inflammatory response lysosomal enzyme production involved in inflammatory response-&gt;production of molecular mediator involved in inflammatory response wound healing involved in inflammatory response wound healing involved in inflammatory response inflammatory response to wounding inflammatory response to wounding wound healing involved in inflammatory response-&gt;inflammatory response to wounding inflammatory response inflammatory response inflammatory response to wounding-&gt;inflammatory response negative regulation of acute inflammatory response to non-antigenic stimulus negative regulation of acute inflammatory response to non-antigenic stimulus negative regulation of acute inflammatory response to non-antigenic stimulus-&gt;regulation of acute inflammatory response to non-antigenic stimulus negative regulation of acute inflammatory response negative regulation of acute inflammatory response negative regulation of acute inflammatory response to non-antigenic stimulus-&gt;negative regulation of acute inflammatory response negative regulation of acute inflammatory response-&gt;regulation of acute inflammatory response negative regulation of acute inflammatory response-&gt;negative regulation of inflammatory response negative regulation of macrophage inflammatory protein-1 gamma production negative regulation of macrophage inflammatory protein-1 gamma production regulation of macrophage inflammatory protein-1 gamma production regulation of macrophage inflammatory protein-1 gamma production negative regulation of macrophage inflammatory protein-1 gamma production-&gt;regulation of macrophage inflammatory protein-1 gamma production positive regulation of cytokine production involved in inflammatory response positive regulation of cytokine production involved in inflammatory response positive regulation of cytokine production involved in inflammatory response-&gt;regulation of cytokine production involved in inflammatory response negative regulation of cytokine production involved in inflammatory response negative regulation of cytokine production involved in inflammatory response negative regulation of cytokine production involved in inflammatory response-&gt;regulation of cytokine production involved in inflammatory response prostaglandin production involved in inflammatory response prostaglandin production involved in inflammatory response arachidonic acid metabolite production involved in inflammatory response arachidonic acid metabolite production involved in inflammatory response prostaglandin production involved in inflammatory response-&gt;arachidonic acid metabolite production involved in inflammatory response arachidonic acid metabolite production involved in inflammatory response-&gt;production of molecular mediator involved in inflammatory response regulation of chronic inflammatory response to non-antigenic stimulus regulation of chronic inflammatory response to non-antigenic stimulus regulation of chronic inflammatory response to non-antigenic stimulus-&gt;regulation of chronic inflammatory response positive regulation of respiratory burst involved in inflammatory response positive regulation of respiratory burst involved in inflammatory response positive regulation of respiratory burst involved in inflammatory response-&gt;positive regulation of inflammatory response regulation of respiratory burst involved in inflammatory response regulation of respiratory burst involved in inflammatory response positive regulation of respiratory burst involved in inflammatory response-&gt;regulation of respiratory burst involved in inflammatory response regulation of respiratory burst involved in inflammatory response-&gt;regulation of inflammatory response positive regulation of neuroinflammatory response positive regulation of neuroinflammatory response positive regulation of neuroinflammatory response-&gt;regulation of neuroinflammatory response positive regulation of neuroinflammatory response-&gt;positive regulation of inflammatory response inflammatory response to antigenic stimulus inflammatory response to antigenic stimulus inflammatory response to antigenic stimulus-&gt;inflammatory response serotonin production involved in inflammatory response serotonin production involved in inflammatory response serotonin production involved in inflammatory response-&gt;production of molecular mediator involved in inflammatory response production of molecular mediator involved in inflammatory response-&gt;inflammatory response negative regulation of chronic inflammatory response negative regulation of chronic inflammatory response negative regulation of chronic inflammatory response-&gt;negative regulation of inflammatory response negative regulation of chronic inflammatory response-&gt;regulation of chronic inflammatory response acute inflammatory response to antigenic stimulus acute inflammatory response to antigenic stimulus acute inflammatory response to antigenic stimulus-&gt;inflammatory response to antigenic stimulus acute inflammatory response acute inflammatory response acute inflammatory response to antigenic stimulus-&gt;acute inflammatory response acute inflammatory response-&gt;inflammatory response negative regulation of acute inflammatory response to antigenic stimulus negative regulation of acute inflammatory response to antigenic stimulus negative regulation of acute inflammatory response to antigenic stimulus-&gt;negative regulation of acute inflammatory response regulation of acute inflammatory response to antigenic stimulus regulation of acute inflammatory response to antigenic stimulus negative regulation of acute inflammatory response to antigenic stimulus-&gt;regulation of acute inflammatory response to antigenic stimulus negative regulation of inflammatory response to antigenic stimulus negative regulation of inflammatory response to antigenic stimulus negative regulation of acute inflammatory response to antigenic stimulus-&gt;negative regulation of inflammatory response to antigenic stimulus regulation of acute inflammatory response to antigenic stimulus-&gt;regulation of acute inflammatory response regulation of inflammatory response to antigenic stimulus regulation of inflammatory response to antigenic stimulus regulation of acute inflammatory response to antigenic stimulus-&gt;regulation of inflammatory response to antigenic stimulus negative regulation of inflammatory response to antigenic stimulus-&gt;negative regulation of inflammatory response negative regulation of inflammatory response to antigenic stimulus-&gt;regulation of inflammatory response to antigenic stimulus leukocyte migration involved in inflammatory response leukocyte migration involved in inflammatory response leukocyte migration involved in inflammatory response-&gt;inflammatory response suppression by symbiont of host inflammatory response suppression by symbiont of host inflammatory response modulation by symbiont of host inflammatory response modulation by symbiont of host inflammatory response suppression by symbiont of host inflammatory response-&gt;modulation by symbiont of host inflammatory response cytokine production involved in inflammatory response cytokine production involved in inflammatory response cytokine production involved in inflammatory response-&gt;production of molecular mediator involved in inflammatory response clearance of damaged tissue involved in inflammatory response wound healing clearance of damaged tissue involved in inflammatory response wound healing clearance of damaged tissue involved in inflammatory response wound healing-&gt;wound healing involved in inflammatory response respiratory burst involved in inflammatory response respiratory burst involved in inflammatory response respiratory burst involved in inflammatory response-&gt;production of molecular mediator involved in inflammatory response regulation of vascular permeability involved in acute inflammatory response regulation of vascular permeability involved in acute inflammatory response regulation of vascular permeability involved in acute inflammatory response-&gt;acute inflammatory response chronic inflammatory response to non-antigenic stimulus chronic inflammatory response to non-antigenic stimulus chronic inflammatory response chronic inflammatory response chronic inflammatory response to non-antigenic stimulus-&gt;chronic inflammatory response chronic inflammatory response-&gt;inflammatory response macrophage inflammatory protein-1 alpha production macrophage inflammatory protein-1 alpha production inflammatory cell apoptotic process inflammatory cell apoptotic process nitric oxide production involved in inflammatory response nitric oxide production involved in inflammatory response nitric oxide production involved in inflammatory response-&gt;production of molecular mediator involved in inflammatory response regulation of connective tissue replacement involved in inflammatory response wound healing regulation of connective tissue replacement involved in inflammatory response wound healing regulation of macrophage inflammatory protein 1 alpha production regulation of macrophage inflammatory protein 1 alpha production acute inflammatory response to non-antigenic stimulus acute inflammatory response to non-antigenic stimulus acute inflammatory response to non-antigenic stimulus-&gt;acute inflammatory response negative regulation of respiratory burst involved in inflammatory response negative regulation of respiratory burst involved in inflammatory response negative regulation of respiratory burst involved in inflammatory response-&gt;negative regulation of inflammatory response negative regulation of respiratory burst involved in inflammatory response-&gt;regulation of respiratory burst involved in inflammatory response positive regulation of chronic inflammatory response to non-antigenic stimulus positive regulation of chronic inflammatory response to non-antigenic stimulus positive regulation of chronic inflammatory response to non-antigenic stimulus-&gt;regulation of chronic inflammatory response to non-antigenic stimulus positive regulation of chronic inflammatory response positive regulation of chronic inflammatory response positive regulation of chronic inflammatory response to non-antigenic stimulus-&gt;positive regulation of chronic inflammatory response positive regulation of chronic inflammatory response-&gt;regulation of chronic inflammatory response positive regulation of chronic inflammatory response-&gt;positive regulation of inflammatory response negative regulation of chronic inflammatory response to antigenic stimulus negative regulation of chronic inflammatory response to antigenic stimulus negative regulation of chronic inflammatory response to antigenic stimulus-&gt;negative regulation of chronic inflammatory response negative regulation of chronic inflammatory response to antigenic stimulus-&gt;negative regulation of inflammatory response to antigenic stimulus regulation of chronic inflammatory response to antigenic stimulus regulation of chronic inflammatory response to antigenic stimulus negative regulation of chronic inflammatory response to antigenic stimulus-&gt;regulation of chronic inflammatory response to antigenic stimulus regulation of chronic inflammatory response to antigenic stimulus-&gt;regulation of chronic inflammatory response regulation of chronic inflammatory response to antigenic stimulus-&gt;regulation of inflammatory response to antigenic stimulus leukotriene production involved in inflammatory response leukotriene production involved in inflammatory response leukotriene production involved in inflammatory response-&gt;arachidonic acid metabolite production involved in inflammatory response negative regulation of macrophage inflammatory protein 1 alpha production negative regulation of macrophage inflammatory protein 1 alpha production negative regulation of macrophage inflammatory protein 1 alpha production-&gt;regulation of macrophage inflammatory protein 1 alpha production histamine secretion involved in inflammatory response histamine secretion involved in inflammatory response histamine production involved in inflammatory response histamine production involved in inflammatory response histamine secretion involved in inflammatory response-&gt;histamine production involved in inflammatory response histamine production involved in inflammatory response-&gt;production of molecular mediator involved in inflammatory response vasodilation involved in acute inflammatory response vasodilation involved in acute inflammatory response vasodilation involved in acute inflammatory response-&gt;acute inflammatory response activation of plasma proteins involved in acute inflammatory response activation of plasma proteins involved in acute inflammatory response activation of plasma proteins involved in acute inflammatory response-&gt;acute inflammatory response regulation of inflammatory response to antigenic stimulus-&gt;regulation of inflammatory response positive regulation of chronic inflammatory response to antigenic stimulus positive regulation of chronic inflammatory response to antigenic stimulus positive regulation of chronic inflammatory response to antigenic stimulus-&gt;positive regulation of chronic inflammatory response positive regulation of chronic inflammatory response to antigenic stimulus-&gt;regulation of chronic inflammatory response to antigenic stimulus positive regulation of inflammatory response to antigenic stimulus positive regulation of inflammatory response to antigenic stimulus positive regulation of chronic inflammatory response to antigenic stimulus-&gt;positive regulation of inflammatory response to antigenic stimulus positive regulation of inflammatory response to antigenic stimulus-&gt;positive regulation of inflammatory response positive regulation of inflammatory response to antigenic stimulus-&gt;regulation of inflammatory response to antigenic stimulus positive regulation by symbiont of host inflammatory response positive regulation by symbiont of host inflammatory response positive regulation by symbiont of host inflammatory response-&gt;modulation by symbiont of host inflammatory response positive regulation of connective tissue replacement involved in inflammatory response wound healing positive regulation of connective tissue replacement involved in inflammatory response wound healing positive regulation of connective tissue replacement involved in inflammatory response wound healing-&gt;regulation of connective tissue replacement involved in inflammatory response wound healing connective tissue replacement involved in inflammatory response wound healing connective tissue replacement involved in inflammatory response wound healing connective tissue replacement involved in inflammatory response wound healing-&gt;wound healing involved in inflammatory response negative regulation of chronic inflammatory response to non-antigenic stimulus negative regulation of chronic inflammatory response to non-antigenic stimulus negative regulation of chronic inflammatory response to non-antigenic stimulus-&gt;regulation of chronic inflammatory response to non-antigenic stimulus negative regulation of chronic inflammatory response to non-antigenic stimulus-&gt;negative regulation of chronic inflammatory response positive regulation of inflammatory response to wounding positive regulation of inflammatory response to wounding positive regulation of inflammatory response to wounding-&gt;regulation of inflammatory response to wounding positive regulation of inflammatory response to wounding-&gt;positive regulation of inflammatory response leukocyte chemotaxis involved in inflammatory response leukocyte chemotaxis involved in inflammatory response leukocyte chemotaxis involved in inflammatory response-&gt;leukocyte migration involved in inflammatory response platelet activating factor production involved in inflammatory response platelet activating factor production involved in inflammatory response platelet activating factor production involved in inflammatory response-&gt;production of molecular mediator involved in inflammatory response positive regulation of acute inflammatory response positive regulation of acute inflammatory response positive regulation of acute inflammatory response-&gt;regulation of acute inflammatory response positive regulation of acute inflammatory response-&gt;positive regulation of inflammatory response positive regulation of acute inflammatory response to non-antigenic stimulus positive regulation of acute inflammatory response to non-antigenic stimulus positive regulation of acute inflammatory response to non-antigenic stimulus-&gt;regulation of acute inflammatory response to non-antigenic stimulus positive regulation of acute inflammatory response to non-antigenic stimulus-&gt;positive regulation of acute inflammatory response regulation of leukotriene production involved in inflammatory response regulation of leukotriene production involved in inflammatory response macrophage inflammatory protein-1 gamma production macrophage inflammatory protein-1 gamma production positive regulation of macrophage inflammatory protein 1 alpha production positive regulation of macrophage inflammatory protein 1 alpha production positive regulation of macrophage inflammatory protein 1 alpha production-&gt;regulation of macrophage inflammatory protein 1 alpha production neuroinflammatory response neuroinflammatory response neuroinflammatory response-&gt;inflammatory response negative regulation of leukotriene production involved in inflammatory response negative regulation of leukotriene production involved in inflammatory response negative regulation of leukotriene production involved in inflammatory response-&gt;negative regulation of inflammatory response negative regulation of leukotriene production involved in inflammatory response-&gt;regulation of leukotriene production involved in inflammatory response chronic inflammatory response to antigenic stimulus chronic inflammatory response to antigenic stimulus chronic inflammatory response to antigenic stimulus-&gt;inflammatory response to antigenic stimulus chronic inflammatory response to antigenic stimulus-&gt;chronic inflammatory response positive regulation of macrophage inflammatory protein-1 gamma production positive regulation of macrophage inflammatory protein-1 gamma production positive regulation of macrophage inflammatory protein-1 gamma production-&gt;regulation of macrophage inflammatory protein-1 gamma production serotonin secretion involved in inflammatory response serotonin secretion involved in inflammatory response serotonin secretion involved in inflammatory response-&gt;serotonin production involved in inflammatory response leukocyte activation involved in inflammatory response leukocyte activation involved in inflammatory response leukocyte activation involved in inflammatory response-&gt;inflammatory response positive regulation of acute inflammatory response to antigenic stimulus positive regulation of acute inflammatory response to antigenic stimulus positive regulation of acute inflammatory response to antigenic stimulus-&gt;regulation of acute inflammatory response to antigenic stimulus positive regulation of acute inflammatory response to antigenic stimulus-&gt;positive regulation of inflammatory response to antigenic stimulus positive regulation of acute inflammatory response to antigenic stimulus-&gt;positive regulation of acute inflammatory response negative regulation of connective tissue replacement involved in inflammatory response wound healing negative regulation of connective tissue replacement involved in inflammatory response wound healing negative regulation of connective tissue replacement involved in inflammatory response wound healing-&gt;regulation of connective tissue replacement involved in inflammatory response wound healing positive regulation of leukotriene production involved in inflammatory response positive regulation of leukotriene production involved in inflammatory response positive regulation of leukotriene production involved in inflammatory response-&gt;positive regulation of inflammatory response positive regulation of leukotriene production involved in inflammatory response-&gt;regulation of leukotriene production involved in inflammatory response inflammation_nodes.to_pickle(&#39;targets/inflammation_GO.pickle&#39;) . Overlap . matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;svg&#39;) KEGG_GO_venn(inflammation_genes, inflammation_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1aa368940&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:46:13.515420 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 3.2 cytokines . KEGG . cytokines_KEGG_BRITE = &#39;ko04052&#39; cytokines_brite_genes = get_KEGG_BRITE_entry(cytokines_KEGG_BRITE) . cytokines_brite_genes.to_pickle(&#39;targets/cytokines_brite.pickle&#39;) . GO . cytokines_subgraph, cytokines_nodes = GO_subgraph_from_query(&#39;cytokine&#39;) df = create_GO_by_gene_matrix(cytokines_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;png&#39;) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . draw_graph(cytokines_subgraph) . mitotic cytokinetic process mitotic cytokinetic process mitotic cytokinesis mitotic cytokinesis mitotic cytokinetic process-&gt;mitotic cytokinesis cytokinetic process cytokinetic process mitotic cytokinetic process-&gt;cytokinetic process cytoskeleton-dependent cytokinesis cytoskeleton-dependent cytokinesis mitotic cytokinesis-&gt;cytoskeleton-dependent cytokinesis cytokinesis cytokinesis cytokinetic process-&gt;cytokinesis regulation of cytokine production involved in inflammatory response regulation of cytokine production involved in inflammatory response regulation of cytokine production regulation of cytokine production regulation of cytokine production involved in inflammatory response-&gt;regulation of cytokine production macrophage cytokine production macrophage cytokine production myeloid leukocyte cytokine production myeloid leukocyte cytokine production macrophage cytokine production-&gt;myeloid leukocyte cytokine production cytokine production involved in immune response cytokine production involved in immune response myeloid leukocyte cytokine production-&gt;cytokine production involved in immune response mitotic cytokinesis, site selection mitotic cytokinesis, site selection mitotic cytokinesis, site selection-&gt;mitotic cytokinetic process cytokinesis, site selection cytokinesis, site selection mitotic cytokinesis, site selection-&gt;cytokinesis, site selection cytokinesis, site selection-&gt;cytokinetic process positive regulation of cytokine production positive regulation of cytokine production positive regulation of cytokine production-&gt;regulation of cytokine production regulation of cytokine production involved in immune response regulation of cytokine production involved in immune response regulation of cytokine production involved in immune response-&gt;regulation of cytokine production FtsZ-dependent cytokinesis FtsZ-dependent cytokinesis FtsZ-dependent cytokinesis-&gt;cytokinesis regulation of plasmacytoid dendritic cell cytokine production regulation of plasmacytoid dendritic cell cytokine production regulation of dendritic cell cytokine production regulation of dendritic cell cytokine production regulation of plasmacytoid dendritic cell cytokine production-&gt;regulation of dendritic cell cytokine production regulation of dendritic cell cytokine production-&gt;regulation of cytokine production involved in immune response positive regulation of cytokinesis, actomyosin contractile ring assembly positive regulation of cytokinesis, actomyosin contractile ring assembly regulation of cytokinesis, actomyosin contractile ring assembly regulation of cytokinesis, actomyosin contractile ring assembly positive regulation of cytokinesis, actomyosin contractile ring assembly-&gt;regulation of cytokinesis, actomyosin contractile ring assembly positive regulation of cytokinesis positive regulation of cytokinesis positive regulation of cytokinesis, actomyosin contractile ring assembly-&gt;positive regulation of cytokinesis regulation of cytokinetic process regulation of cytokinetic process regulation of cytokinesis, actomyosin contractile ring assembly-&gt;regulation of cytokinetic process regulation of cytokinesis regulation of cytokinesis positive regulation of cytokinesis-&gt;regulation of cytokinesis B cell cytokine production B cell cytokine production B cell cytokine production-&gt;cytokine production involved in immune response cytokine production cytokine production cytokine production involved in immune response-&gt;cytokine production evasion of host immune response via regulation of host cytokine network evasion of host immune response via regulation of host cytokine network cytokine-mediated signaling pathway cytokine-mediated signaling pathway cellular response to cytokine stimulus cellular response to cytokine stimulus cytokine-mediated signaling pathway-&gt;cellular response to cytokine stimulus response to cytokine response to cytokine cellular response to cytokine stimulus-&gt;response to cytokine regulation of T cell cytokine production regulation of T cell cytokine production regulation of T cell cytokine production-&gt;regulation of cytokine production involved in immune response myosin filament organization involved in cytokinetic actomyosin contractile ring assembly myosin filament organization involved in cytokinetic actomyosin contractile ring assembly regulation of mast cell cytokine production regulation of mast cell cytokine production regulation of mast cell cytokine production-&gt;regulation of cytokine production involved in immune response positive regulation of cytokine production involved in inflammatory response positive regulation of cytokine production involved in inflammatory response positive regulation of cytokine production involved in inflammatory response-&gt;regulation of cytokine production involved in inflammatory response positive regulation of cytokine production involved in inflammatory response-&gt;positive regulation of cytokine production negative regulation of cytokine production involved in inflammatory response negative regulation of cytokine production involved in inflammatory response negative regulation of cytokine production involved in inflammatory response-&gt;regulation of cytokine production involved in inflammatory response negative regulation of cytokine production negative regulation of cytokine production negative regulation of cytokine production involved in inflammatory response-&gt;negative regulation of cytokine production negative regulation of cytokine production-&gt;regulation of cytokine production mast cell cytokine production mast cell cytokine production mast cell cytokine production-&gt;myeloid leukocyte cytokine production negative regulation of myeloid dendritic cell cytokine production negative regulation of myeloid dendritic cell cytokine production regulation of myeloid dendritic cell cytokine production regulation of myeloid dendritic cell cytokine production negative regulation of myeloid dendritic cell cytokine production-&gt;regulation of myeloid dendritic cell cytokine production negative regulation of dendritic cell cytokine production negative regulation of dendritic cell cytokine production negative regulation of myeloid dendritic cell cytokine production-&gt;negative regulation of dendritic cell cytokine production regulation of myeloid dendritic cell cytokine production-&gt;regulation of dendritic cell cytokine production negative regulation of dendritic cell cytokine production-&gt;regulation of dendritic cell cytokine production negative regulation of cytokine production involved in immune response negative regulation of cytokine production involved in immune response negative regulation of dendritic cell cytokine production-&gt;negative regulation of cytokine production involved in immune response positive regulation of plasmacytoid dendritic cell cytokine production positive regulation of plasmacytoid dendritic cell cytokine production positive regulation of plasmacytoid dendritic cell cytokine production-&gt;regulation of plasmacytoid dendritic cell cytokine production positive regulation of dendritic cell cytokine production positive regulation of dendritic cell cytokine production positive regulation of plasmacytoid dendritic cell cytokine production-&gt;positive regulation of dendritic cell cytokine production positive regulation of dendritic cell cytokine production-&gt;regulation of dendritic cell cytokine production positive regulation of cytokine production involved in immune response positive regulation of cytokine production involved in immune response positive regulation of dendritic cell cytokine production-&gt;positive regulation of cytokine production involved in immune response positive regulation of response to cytokinesis checkpoint signaling positive regulation of response to cytokinesis checkpoint signaling regulation of response to cytokinesis checkpoint signaling regulation of response to cytokinesis checkpoint signaling positive regulation of response to cytokinesis checkpoint signaling-&gt;regulation of response to cytokinesis checkpoint signaling negative regulation of septum digestion after cytokinesis negative regulation of septum digestion after cytokinesis regulation of septum digestion after cytokinesis regulation of septum digestion after cytokinesis negative regulation of septum digestion after cytokinesis-&gt;regulation of septum digestion after cytokinesis positive regulation of response to cytokine stimulus positive regulation of response to cytokine stimulus regulation of response to cytokine stimulus regulation of response to cytokine stimulus positive regulation of response to cytokine stimulus-&gt;regulation of response to cytokine stimulus negative regulation of cytokine activity negative regulation of cytokine activity regulation of cytokine activity regulation of cytokine activity negative regulation of cytokine activity-&gt;regulation of cytokine activity negative regulation of T cell cytokine production negative regulation of T cell cytokine production negative regulation of T cell cytokine production-&gt;regulation of T cell cytokine production negative regulation of T cell cytokine production-&gt;negative regulation of cytokine production involved in immune response negative regulation of cytokine production involved in immune response-&gt;regulation of cytokine production involved in immune response negative regulation of cytokine production involved in immune response-&gt;negative regulation of cytokine production cell cycle comprising mitosis without cytokinesis cell cycle comprising mitosis without cytokinesis negative regulation of mast cell cytokine production negative regulation of mast cell cytokine production negative regulation of mast cell cytokine production-&gt;regulation of mast cell cytokine production negative regulation of mast cell cytokine production-&gt;negative regulation of cytokine production involved in immune response positive regulation of mitotic cytokinesis positive regulation of mitotic cytokinesis positive regulation of mitotic cytokinesis-&gt;positive regulation of cytokinesis regulation of mitotic cytokinesis regulation of mitotic cytokinesis positive regulation of mitotic cytokinesis-&gt;regulation of mitotic cytokinesis regulation of mitotic cytokinesis-&gt;regulation of cytokinesis cytoskeleton-dependent cytokinesis-&gt;cytokinesis positive regulation of myeloid dendritic cell cytokine production positive regulation of myeloid dendritic cell cytokine production positive regulation of myeloid dendritic cell cytokine production-&gt;regulation of myeloid dendritic cell cytokine production positive regulation of myeloid dendritic cell cytokine production-&gt;positive regulation of dendritic cell cytokine production positive regulation of myeloid leukocyte cytokine production involved in immune response positive regulation of myeloid leukocyte cytokine production involved in immune response positive regulation of myeloid dendritic cell cytokine production-&gt;positive regulation of myeloid leukocyte cytokine production involved in immune response positive regulation of myeloid leukocyte cytokine production involved in immune response-&gt;positive regulation of cytokine production involved in immune response septum digestion after cytokinesis septum digestion after cytokinesis negative regulation of tumor necrosis factor superfamily cytokine production negative regulation of tumor necrosis factor superfamily cytokine production negative regulation of tumor necrosis factor superfamily cytokine production-&gt;negative regulation of cytokine production regulation of tumor necrosis factor superfamily cytokine production regulation of tumor necrosis factor superfamily cytokine production negative regulation of tumor necrosis factor superfamily cytokine production-&gt;regulation of tumor necrosis factor superfamily cytokine production regulation of tumor necrosis factor superfamily cytokine production-&gt;regulation of cytokine production negative regulation of T-helper 2 cell cytokine production negative regulation of T-helper 2 cell cytokine production negative regulation of T-helper 2 cell cytokine production-&gt;negative regulation of T cell cytokine production regulation of T-helper 2 cell cytokine production regulation of T-helper 2 cell cytokine production negative regulation of T-helper 2 cell cytokine production-&gt;regulation of T-helper 2 cell cytokine production regulation of T-helper 2 cell cytokine production-&gt;regulation of T cell cytokine production suppression by virus of host cytokine production suppression by virus of host cytokine production suppression by virus of host cytokine production-&gt;negative regulation of cytokine production modulation by virus of host cytokine production modulation by virus of host cytokine production suppression by virus of host cytokine production-&gt;modulation by virus of host cytokine production negative regulation of mitotic cytokinesis negative regulation of mitotic cytokinesis negative regulation of mitotic cytokinesis-&gt;regulation of mitotic cytokinesis negative regulation of cytokinesis negative regulation of cytokinesis negative regulation of mitotic cytokinesis-&gt;negative regulation of cytokinesis negative regulation of cytokinesis-&gt;regulation of cytokinesis cytokine production involved in inflammatory response cytokine production involved in inflammatory response cytokine production involved in inflammatory response-&gt;cytokine production positive regulation of cytokinesis, site selection positive regulation of cytokinesis, site selection positive regulation of cytokinesis, site selection-&gt;positive regulation of cytokinesis regulation of cytokinesis, site selection regulation of cytokinesis, site selection positive regulation of cytokinesis, site selection-&gt;regulation of cytokinesis, site selection regulation of cytokinesis, site selection-&gt;regulation of cytokinetic process regulation of mitotic cytokinesis, site selection regulation of mitotic cytokinesis, site selection regulation of mitotic cytokinesis, site selection-&gt;regulation of cytokinesis, site selection regulation of mitotic cytokinetic process regulation of mitotic cytokinetic process regulation of mitotic cytokinesis, site selection-&gt;regulation of mitotic cytokinetic process regulation of mitotic cytokinetic process-&gt;regulation of cytokinetic process regulation of mitotic cytokinetic process-&gt;regulation of mitotic cytokinesis meiosis I cytokinesis meiosis I cytokinesis meiotic cytokinesis meiotic cytokinesis meiosis I cytokinesis-&gt;meiotic cytokinesis meiotic cytokinesis-&gt;cytoskeleton-dependent cytokinesis cytokine receptor activity cytokine receptor activity cytokinesis by cell plate formation cytokinesis by cell plate formation cytokinesis by cell plate formation-&gt;cytokinesis protein localization to cell division site after cytokinesis protein localization to cell division site after cytokinesis negative regulation of macrophage cytokine production negative regulation of macrophage cytokine production negative regulation of macrophage cytokine production-&gt;negative regulation of cytokine production involved in immune response regulation of macrophage cytokine production regulation of macrophage cytokine production negative regulation of macrophage cytokine production-&gt;regulation of macrophage cytokine production regulation of macrophage cytokine production-&gt;regulation of cytokine production involved in immune response positive regulation of cytokine production involved in immune response-&gt;positive regulation of cytokine production positive regulation of cytokine production involved in immune response-&gt;regulation of cytokine production involved in immune response mitotic cytokinesis checkpoint signaling mitotic cytokinesis checkpoint signaling positive regulation of septum digestion after cytokinesis positive regulation of septum digestion after cytokinesis positive regulation of septum digestion after cytokinesis-&gt;regulation of septum digestion after cytokinesis negative regulation of plasmacytoid dendritic cell cytokine production negative regulation of plasmacytoid dendritic cell cytokine production negative regulation of plasmacytoid dendritic cell cytokine production-&gt;regulation of plasmacytoid dendritic cell cytokine production negative regulation of plasmacytoid dendritic cell cytokine production-&gt;negative regulation of dendritic cell cytokine production negative regulation of mitotic cytokinetic process negative regulation of mitotic cytokinetic process negative regulation of mitotic cytokinetic process-&gt;negative regulation of mitotic cytokinesis negative regulation of mitotic cytokinetic process-&gt;regulation of mitotic cytokinetic process regulation of FtsZ-dependent cytokinesis regulation of FtsZ-dependent cytokinesis regulation of FtsZ-dependent cytokinesis-&gt;regulation of cytokinesis negative regulation of cytokinesis, actomyosin contractile ring assembly negative regulation of cytokinesis, actomyosin contractile ring assembly negative regulation of cytokinesis, actomyosin contractile ring assembly-&gt;regulation of cytokinesis, actomyosin contractile ring assembly negative regulation of cytokinesis, actomyosin contractile ring assembly-&gt;negative regulation of cytokinesis negative regulation of B cell cytokine production negative regulation of B cell cytokine production negative regulation of B cell cytokine production-&gt;negative regulation of cytokine production involved in immune response regulation of B cell cytokine production regulation of B cell cytokine production negative regulation of B cell cytokine production-&gt;regulation of B cell cytokine production regulation of B cell cytokine production-&gt;regulation of cytokine production involved in immune response regulation of protein localization to cell division site involved in cytokinesis regulation of protein localization to cell division site involved in cytokinesis regulation of protein localization to cell division site involved in cytokinesis-&gt;cytokinesis protein localization to cell division site involved in cytokinesis, actomyosin contractile ring assembly protein localization to cell division site involved in cytokinesis, actomyosin contractile ring assembly positive regulation of tumor necrosis factor superfamily cytokine production positive regulation of tumor necrosis factor superfamily cytokine production positive regulation of tumor necrosis factor superfamily cytokine production-&gt;positive regulation of cytokine production positive regulation of tumor necrosis factor superfamily cytokine production-&gt;regulation of tumor necrosis factor superfamily cytokine production membrane addition at site of mitotic cytokinesis membrane addition at site of mitotic cytokinesis membrane addition at site of mitotic cytokinesis-&gt;mitotic cytokinetic process membrane addition at site of cytokinesis membrane addition at site of cytokinesis membrane addition at site of mitotic cytokinesis-&gt;membrane addition at site of cytokinesis membrane addition at site of cytokinesis-&gt;cytokinetic process cytokine precursor processing cytokine precursor processing cytokine precursor processing-&gt;cytokine production T cell cytokine production T cell cytokine production T cell cytokine production-&gt;cytokine production involved in immune response positive regulation of mitotic cytokinesis, site selection positive regulation of mitotic cytokinesis, site selection positive regulation of mitotic cytokinesis, site selection-&gt;positive regulation of cytokinesis, site selection positive regulation of mitotic cytokinesis, site selection-&gt;regulation of mitotic cytokinesis, site selection positive regulation of mitotic cytokinetic process positive regulation of mitotic cytokinetic process positive regulation of mitotic cytokinesis, site selection-&gt;positive regulation of mitotic cytokinetic process positive regulation of mitotic cytokinetic process-&gt;positive regulation of mitotic cytokinesis positive regulation of mitotic cytokinetic process-&gt;regulation of mitotic cytokinetic process suppression by virus of host cytokine activity suppression by virus of host cytokine activity negative regulation of cytokinesis, site selection negative regulation of cytokinesis, site selection negative regulation of cytokinesis, site selection-&gt;negative regulation of cytokinesis negative regulation of cytokinesis, site selection-&gt;regulation of cytokinesis, site selection CD4-positive, alpha-beta T cell cytokine production CD4-positive, alpha-beta T cell cytokine production CD4-positive, alpha-beta T cell cytokine production-&gt;T cell cytokine production regulation of protein localization to cell division site involved in cell separation after cytokinesis regulation of protein localization to cell division site involved in cell separation after cytokinesis regulation of protein localization to cell division site involved in cell separation after cytokinesis-&gt;septum digestion after cytokinesis regulation of cytokine-mediated signaling pathway regulation of cytokine-mediated signaling pathway regulation of cytokine-mediated signaling pathway-&gt;regulation of response to cytokine stimulus positive regulation of FtsZ-dependent cytokinesis positive regulation of FtsZ-dependent cytokinesis positive regulation of FtsZ-dependent cytokinesis-&gt;positive regulation of cytokinesis positive regulation of FtsZ-dependent cytokinesis-&gt;regulation of FtsZ-dependent cytokinesis assembly of actomyosin apparatus involved in mitotic cytokinesis assembly of actomyosin apparatus involved in mitotic cytokinesis assembly of actomyosin apparatus involved in mitotic cytokinesis-&gt;mitotic cytokinetic process assembly of actomyosin apparatus involved in cytokinesis assembly of actomyosin apparatus involved in cytokinesis assembly of actomyosin apparatus involved in mitotic cytokinesis-&gt;assembly of actomyosin apparatus involved in cytokinesis assembly of actomyosin apparatus involved in cytokinesis-&gt;cytokinetic process assembly of actomyosin apparatus involved in cytokinesis-&gt;cytoskeleton-dependent cytokinesis regulation of natural killer cell cytokine production regulation of natural killer cell cytokine production regulation of natural killer cell cytokine production-&gt;regulation of cytokine production involved in immune response tumor necrosis factor superfamily cytokine production tumor necrosis factor superfamily cytokine production tumor necrosis factor superfamily cytokine production-&gt;cytokine production positive regulation of mast cell cytokine production positive regulation of mast cell cytokine production positive regulation of mast cell cytokine production-&gt;regulation of mast cell cytokine production positive regulation of mast cell cytokine production-&gt;positive regulation of myeloid leukocyte cytokine production involved in immune response T-helper 2 cell cytokine production T-helper 2 cell cytokine production T-helper 2 cell cytokine production-&gt;CD4-positive, alpha-beta T cell cytokine production positive regulation of macrophage cytokine production positive regulation of macrophage cytokine production positive regulation of macrophage cytokine production-&gt;positive regulation of myeloid leukocyte cytokine production involved in immune response positive regulation of macrophage cytokine production-&gt;regulation of macrophage cytokine production Cdv-dependent cytokinesis Cdv-dependent cytokinesis Cdv-dependent cytokinesis-&gt;cytokinesis guard mother cell cytokinesis guard mother cell cytokinesis guard mother cell cytokinesis-&gt;cytokinesis by cell plate formation positive regulation of cytokine activity positive regulation of cytokine activity positive regulation of cytokine activity-&gt;regulation of cytokine activity positive regulation of T-helper 2 cell cytokine production positive regulation of T-helper 2 cell cytokine production positive regulation of T-helper 2 cell cytokine production-&gt;regulation of T-helper 2 cell cytokine production positive regulation of T cell cytokine production positive regulation of T cell cytokine production positive regulation of T-helper 2 cell cytokine production-&gt;positive regulation of T cell cytokine production positive regulation of T cell cytokine production-&gt;regulation of T cell cytokine production positive regulation of T cell cytokine production-&gt;positive regulation of cytokine production involved in immune response male meiosis cytokinesis male meiosis cytokinesis male meiosis cytokinesis-&gt;meiotic cytokinesis regulation of actin filament organization involved in cytokinetic actomyosin contractile ring assembly regulation of actin filament organization involved in cytokinetic actomyosin contractile ring assembly response to cytokinesis checkpoint signaling response to cytokinesis checkpoint signaling meiosis II cytokinesis meiosis II cytokinesis meiosis II cytokinesis-&gt;meiotic cytokinesis negative regulation of natural killer cell cytokine production negative regulation of natural killer cell cytokine production negative regulation of natural killer cell cytokine production-&gt;negative regulation of cytokine production involved in immune response negative regulation of natural killer cell cytokine production-&gt;regulation of natural killer cell cytokine production signal transduction involved in cytokinesis checkpoint signal transduction involved in cytokinesis checkpoint cytokine binding cytokine binding positive regulation of T-helper 1 cell cytokine production positive regulation of T-helper 1 cell cytokine production positive regulation of T-helper 1 cell cytokine production-&gt;positive regulation of T cell cytokine production regulation of T-helper 1 cell cytokine production regulation of T-helper 1 cell cytokine production positive regulation of T-helper 1 cell cytokine production-&gt;regulation of T-helper 1 cell cytokine production regulation of T-helper 1 cell cytokine production-&gt;regulation of T cell cytokine production suppression by symbiont of host cytokine production suppression by symbiont of host cytokine production syncytium formation by mitosis without cytokinesis syncytium formation by mitosis without cytokinesis dendritic cell cytokine production dendritic cell cytokine production dendritic cell cytokine production-&gt;cytokine production involved in immune response myeloid dendritic cell cytokine production myeloid dendritic cell cytokine production myeloid dendritic cell cytokine production-&gt;myeloid leukocyte cytokine production myeloid dendritic cell cytokine production-&gt;dendritic cell cytokine production induction by virus of host cytokine production induction by virus of host cytokine production induction by virus of host cytokine production-&gt;positive regulation of cytokine production induction by virus of host cytokine production-&gt;modulation by virus of host cytokine production negative regulation of response to cytokine stimulus negative regulation of response to cytokine stimulus negative regulation of response to cytokine stimulus-&gt;regulation of response to cytokine stimulus positive regulation of B cell cytokine production positive regulation of B cell cytokine production positive regulation of B cell cytokine production-&gt;positive regulation of cytokine production involved in immune response positive regulation of B cell cytokine production-&gt;regulation of B cell cytokine production natural killer cell cytokine production natural killer cell cytokine production natural killer cell cytokine production-&gt;cytokine production involved in immune response protein localization to cell division site involved in cell separation after cytokinesis protein localization to cell division site involved in cell separation after cytokinesis protein localization to cell division site involved in cell separation after cytokinesis-&gt;septum digestion after cytokinesis negative regulation of FtsZ-dependent cytokinesis negative regulation of FtsZ-dependent cytokinesis negative regulation of FtsZ-dependent cytokinesis-&gt;negative regulation of cytokinesis negative regulation of FtsZ-dependent cytokinesis-&gt;regulation of FtsZ-dependent cytokinesis negative regulation of T-helper 1 cell cytokine production negative regulation of T-helper 1 cell cytokine production negative regulation of T-helper 1 cell cytokine production-&gt;negative regulation of T cell cytokine production negative regulation of T-helper 1 cell cytokine production-&gt;regulation of T-helper 1 cell cytokine production negative regulation of cytokine-mediated signaling pathway negative regulation of cytokine-mediated signaling pathway negative regulation of cytokine-mediated signaling pathway-&gt;regulation of cytokine-mediated signaling pathway negative regulation of cytokine-mediated signaling pathway-&gt;negative regulation of response to cytokine stimulus T-helper 1 cell cytokine production T-helper 1 cell cytokine production T-helper 1 cell cytokine production-&gt;CD4-positive, alpha-beta T cell cytokine production cytokine receptor binding cytokine receptor binding positive regulation of cytokine-mediated signaling pathway positive regulation of cytokine-mediated signaling pathway positive regulation of cytokine-mediated signaling pathway-&gt;positive regulation of response to cytokine stimulus positive regulation of cytokine-mediated signaling pathway-&gt;regulation of cytokine-mediated signaling pathway positive regulation of natural killer cell cytokine production positive regulation of natural killer cell cytokine production positive regulation of natural killer cell cytokine production-&gt;positive regulation of cytokine production involved in immune response positive regulation of natural killer cell cytokine production-&gt;regulation of natural killer cell cytokine production plasmacytoid dendritic cell cytokine production plasmacytoid dendritic cell cytokine production plasmacytoid dendritic cell cytokine production-&gt;dendritic cell cytokine production cytokine activity cytokine activity zygote asymmetric cytokinesis in embryo sac zygote asymmetric cytokinesis in embryo sac zygote asymmetric cytokinesis in embryo sac-&gt;mitotic cytokinesis cytokines_nodes.to_pickle(&#39;targets/cytokines_GO.pickle&#39;) . Overlap . matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;svg&#39;) KEGG_GO_venn(cytokines_brite_genes, cytokines_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1aaae7040&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:46:43.065532 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 3.3 cGAS-STING . KEGG . cGAS_STING_pathway_id = &#39;hsa04623&#39; Image(REST.kegg_get(cGAS_STING_pathway_id, &#39;image&#39;).read()) . cGAS_STING_pathway_genes = get_KEGG_pathway_gene_members(cGAS_STING_pathway_id) . cGAS_STING_pathway_genes.to_pickle(&#39;targets/cGAS_STING_kegg.pickle&#39;) . GO . cGAS_STING_subgraph, cGAS_STING_nodes = GO_subgraph_from_query(&#39;activation of innate immune response&#39;) . draw_graph(cGAS_STING_subgraph) . activation of innate immune response activation of innate immune response cGAS_STING_nodes.to_pickle(&#39;targets/cGAS_STING_GO.pickle&#39;) . Overlap . KEGG_GO_venn(cGAS_STING_pathway_genes, cGAS_STING_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1aaa85340&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:46:46.451775 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 3.4 senescence programs . KEGG . senescence_pathway = &#39;hsa04218&#39; Image(REST.kegg_get(senescence_pathway, &#39;image&#39;).read()) . senescence_pathway_genes = get_KEGG_pathway_gene_members(senescence_pathway) . senescence_pathway_genes.to_pickle(&#39;targets/senescence_kegg.pickle&#39;) . GO . senescence_subgraph, senescence_nodes = GO_subgraph_from_query(&#39;senescence&#39;) df = create_GO_by_gene_matrix(senescence_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;svg&#39;) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:46:50.753292 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ draw_graph(senescence_subgraph) . plant organ senescence plant organ senescence cellular senescence cellular senescence regulation of replicative senescence regulation of replicative senescence regulation of cellular senescence regulation of cellular senescence negative regulation of leaf senescence negative regulation of leaf senescence regulation of leaf senescence regulation of leaf senescence negative regulation of leaf senescence-&gt;regulation of leaf senescence replicative senescence replicative senescence senescence-associated vacuole senescence-associated vacuole oncogene-induced cell senescence oncogene-induced cell senescence oncogene-induced cell senescence-&gt;cellular senescence senescence-associated heterochromatin focus senescence-associated heterochromatin focus stress-induced premature senescence stress-induced premature senescence stress-induced premature senescence-&gt;cellular senescence negative regulation of replicative senescence negative regulation of replicative senescence negative regulation of replicative senescence-&gt;regulation of replicative senescence negative regulation of cellular senescence negative regulation of cellular senescence negative regulation of cellular senescence-&gt;regulation of cellular senescence oxidative stress-induced premature senescence oxidative stress-induced premature senescence oxidative stress-induced premature senescence-&gt;stress-induced premature senescence floral organ senescence floral organ senescence floral organ senescence-&gt;plant organ senescence reproductive senescence reproductive senescence positive regulation of leaf senescence positive regulation of leaf senescence positive regulation of leaf senescence-&gt;regulation of leaf senescence positive regulation of cellular senescence positive regulation of cellular senescence positive regulation of cellular senescence-&gt;regulation of cellular senescence positive regulation of replicative senescence positive regulation of replicative senescence positive regulation of replicative senescence-&gt;regulation of replicative senescence leaf senescence leaf senescence leaf senescence-&gt;plant organ senescence senescence_nodes.to_pickle(&#39;targets/senescence_GO.pickle&#39;) . Overlap . KEGG_GO_venn(senescence_pathway_genes, senescence_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1a9ed3400&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:46:51.104733 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 3.5 inflammasome activation . KEGG . inflammasome_pathway = &#39;hsa04621&#39; Image(REST.kegg_get(inflammasome_pathway, &#39;image&#39;).read()) . inflammasome_pathway_genes = get_KEGG_pathway_gene_members(inflammasome_pathway) . inflammasome_pathway_genes.to_pickle(&#39;targets/inflammasome_kegg.pickle&#39;) . GO . inflammasome_subgraph, inflammasome_nodes = GO_subgraph_from_query(&#39;inflammasome&#39;) df = create_GO_by_gene_matrix(inflammasome_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) # matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;svg&#39;) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:46:55.037351 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ draw_graph(inflammasome_subgraph) . IPAF inflammasome complex IPAF inflammasome complex inflammasome complex inflammasome complex IPAF inflammasome complex-&gt;inflammasome complex NLRP1 inflammasome complex NLRP1 inflammasome complex NLRP1 inflammasome complex-&gt;inflammasome complex positive regulation of NLRP3 inflammasome complex assembly positive regulation of NLRP3 inflammasome complex assembly regulation of NLRP3 inflammasome complex assembly regulation of NLRP3 inflammasome complex assembly positive regulation of NLRP3 inflammasome complex assembly-&gt;regulation of NLRP3 inflammasome complex assembly NLRP6 inflammasome complex assembly NLRP6 inflammasome complex assembly inflammasome complex assembly inflammasome complex assembly NLRP6 inflammasome complex assembly-&gt;inflammasome complex assembly negative regulation of NLRP3 inflammasome complex assembly negative regulation of NLRP3 inflammasome complex assembly negative regulation of NLRP3 inflammasome complex assembly-&gt;regulation of NLRP3 inflammasome complex assembly AIM2 inflammasome complex AIM2 inflammasome complex AIM2 inflammasome complex-&gt;inflammasome complex CARD8 inflammasome complex CARD8 inflammasome complex CARD8 inflammasome complex-&gt;inflammasome complex NLRP1 inflammasome complex assembly NLRP1 inflammasome complex assembly NLRP1 inflammasome complex assembly-&gt;inflammasome complex assembly NLRP3 inflammasome complex NLRP3 inflammasome complex NLRP3 inflammasome complex-&gt;inflammasome complex NLRP3 inflammasome complex assembly NLRP3 inflammasome complex assembly NLRP3 inflammasome complex assembly-&gt;inflammasome complex assembly CARD8 inflammasome complex assembly CARD8 inflammasome complex assembly CARD8 inflammasome complex assembly-&gt;inflammasome complex assembly NLRP6 inflammasome complex NLRP6 inflammasome complex NLRP6 inflammasome complex-&gt;inflammasome complex inflammasome_nodes.to_pickle(&#39;targets/inflammasome_GO.pickle&#39;) . Overlap . KEGG_GO_venn(inflammasome_pathway_genes, inflammasome_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x199e98a00&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:46:55.303127 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 4. Glycolysis, TCA Cycle, electron transport chain, mitochondrial biogenesis, oxidative stress . 4.1 Glycolysis . KEGG . glycolysis_pathway_id = &#39;hsa00010&#39; # glycolysis_brite_id = &#39;ko03051&#39; Image(REST.kegg_get(glycolysis_pathway_id, &#39;image&#39;).read()) . glycolysis_pathway_genes = get_KEGG_pathway_gene_members(glycolysis_pathway_id) . # proteasome_brite_genes = proteasome_brite_genes.loc[&#39;Eukaryotic proteasome&#39;] # proteasome_brite_genes[&#39;in_KEGG_pathway&#39;] = proteasome_brite_genes.ENSG.isin(proteasome_pathway_genes.ENSG).astype(int) . glycolysis_pathway_genes.to_pickle(&#39;targets/glycolysis_kegg.pickle&#39;) . GO . glycolysis_subgraph, glycolysis_nodes = GO_subgraph_from_query(&#39;glycolysis&#39;) df = create_GO_by_gene_matrix(glycolysis_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:46:58.301281 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ draw_graph(glycolysis_subgraph) . canonical glycolysis canonical glycolysis glycolysis from storage polysaccharide through glucose-1-phosphate glycolysis from storage polysaccharide through glucose-1-phosphate sulphoglycolysis sulphoglycolysis glycolysis_nodes.to_pickle(&#39;targets/glycolysis_GO.pickle&#39;) . Overlap . KEGG_GO_venn(glycolysis_pathway_genes, glycolysis_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x19a013910&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:46:58.509224 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 4.2 TCA Cycle . KEGG . tca_pathway_id = &#39;hsa00020&#39; # tca_brite_id = &#39;ko03051&#39; Image(REST.kegg_get(tca_pathway_id, &#39;image&#39;).read()) . tca_pathway_genes = get_KEGG_pathway_gene_members(tca_pathway_id) . # proteasome_brite_genes = proteasome_brite_genes.loc[&#39;Eukaryotic proteasome&#39;] # proteasome_brite_genes[&#39;in_KEGG_pathway&#39;] = proteasome_brite_genes.ENSG.isin(proteasome_pathway_genes.ENSG).astype(int) . tca_pathway_genes.to_pickle(&#39;targets/tca_kegg.pickle&#39;) . GO . tca_subgraph, tca_nodes = GO_subgraph_from_query(&#39;tricarboxylic acid cycle&#39;) df = create_GO_by_gene_matrix(tca_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:47:01.609924 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ draw_graph(tca_subgraph) . cytosolic tricarboxylic acid cycle enzyme complex cytosolic tricarboxylic acid cycle enzyme complex tricarboxylic acid cycle enzyme complex tricarboxylic acid cycle enzyme complex cytosolic tricarboxylic acid cycle enzyme complex-&gt;tricarboxylic acid cycle enzyme complex mitochondrial tricarboxylic acid cycle enzyme complex mitochondrial tricarboxylic acid cycle enzyme complex mitochondrial tricarboxylic acid cycle enzyme complex-&gt;tricarboxylic acid cycle enzyme complex reductive tricarboxylic acid cycle reductive tricarboxylic acid cycle tricarboxylic acid cycle tricarboxylic acid cycle reductive tricarboxylic acid cycle-&gt;tricarboxylic acid cycle tca_nodes.to_pickle(&#39;targets/tca_GO.pickle&#39;) . Overlap . KEGG_GO_venn(tca_pathway_genes, tca_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1a9631f10&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:47:01.868275 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 4.3 electron transport chain . KEGG . ETC_pathway = &#39;hsa00190&#39; Image(REST.kegg_get(ETC_pathway, &#39;image&#39;).read()) . ETC_pathway_genes = get_KEGG_pathway_gene_members(ETC_pathway) . ETC_pathway_genes.to_pickle(&#39;targets/ETC_kegg.pickle&#39;) . GO . ETC_subgraph, ETC_nodes = GO_subgraph_from_query(&#39;electron transport chain&#39;) df = create_GO_by_gene_matrix(ETC_nodes, attr=&#39;gene_name&#39;) df = sort_df_by_hclust_olo(df) ax = plot_gene_membership_in_GO_terms(df, figsize=(6, 10)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:47:06.028776 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ draw_graph(ETC_subgraph) . respiratory electron transport chain respiratory electron transport chain electron transport chain electron transport chain respiratory electron transport chain-&gt;electron transport chain nitrate reductase activity involved in anaerobic electron transport chain nitrate reductase activity involved in anaerobic electron transport chain P450-containing electron transport chain P450-containing electron transport chain P450-containing electron transport chain-&gt;electron transport chain anaerobic electron transport chain anaerobic electron transport chain anaerobic electron transport chain-&gt;respiratory electron transport chain aerobic electron transport chain aerobic electron transport chain aerobic electron transport chain-&gt;respiratory electron transport chain photosynthetic electron transport chain photosynthetic electron transport chain photosynthetic electron transport chain-&gt;electron transport chain ETC_nodes.to_pickle(&#39;targets/ETC_GO.pickle&#39;) . Overlap . KEGG_GO_venn(ETC_pathway_genes, ETC_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1aa018970&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:47:06.349479 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 4.4 mitochondrial biogenesis . KEGG . pd.set_option(&#39;display.max_rows&#39;, 200) . mitochondrial_biogenesis_brite_id = &#39;ko03029&#39; mitochondrial_biogenesis_brite_genes = get_KEGG_BRITE_entry(mitochondrial_biogenesis_brite_id) . mitochondrial_biogenesis_brite_genes = mitochondrial_biogenesis_brite_genes.loc[[&#39;Mitochondrial DNA transcription, translation, and replication factors&#39;,&#39;Mitochondrial quality control factors&#39;]] # mitochondrial_biogenesis_brite.loc[&#39;Mitochondrial DNA transcription, translation, and replication factors&#39;] . mitochondrial_biogenesis_brite_genes.to_pickle(&#39;targets/mitochondrial_biogenesis_brite.pickle&#39;) . GO . mitochondrial_biogenesis_subgraph, mitochondrial_biogenesis_nodes = GO_subgraph_from_query(&#39;mitochondrial fission&#39;) draw_graph(mitochondrial_biogenesis_subgraph) . negative regulation of mitochondrial fission negative regulation of mitochondrial fission regulation of mitochondrial fission regulation of mitochondrial fission negative regulation of mitochondrial fission-&gt;regulation of mitochondrial fission positive regulation of mitochondrial fission positive regulation of mitochondrial fission positive regulation of mitochondrial fission-&gt;regulation of mitochondrial fission establishment of protein localization to mitochondrial membrane involved in mitochondrial fission establishment of protein localization to mitochondrial membrane involved in mitochondrial fission mitochondrial fission mitochondrial fission establishment of protein localization to mitochondrial membrane involved in mitochondrial fission-&gt;mitochondrial fission dynamin family protein polymerization involved in mitochondrial fission dynamin family protein polymerization involved in mitochondrial fission mitochondrial_biogenesis_nodes.to_pickle(&#39;targets/mitochondrial_biogenesis_GO.pickle&#39;) . Overlap . KEGG_GO_venn(mitochondrial_biogenesis_brite_genes, mitochondrial_biogenesis_nodes) . &lt;matplotlib_venn._common.VennDiagram at 0x1aa214a90&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-08-01T19:47:07.679206 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 4.5 oxidative stress . GO . oxidative_stress_subgraph, oxidative_stress_nodes = GO_subgraph_from_query(&#39;oxidative stress&#39;) draw_graph(oxidative_stress_subgraph) . regulation of mRNA stability involved in response to oxidative stress regulation of mRNA stability involved in response to oxidative stress response to oxidative stress response to oxidative stress regulation of mRNA stability involved in response to oxidative stress-&gt;response to oxidative stress regulation of oxidative stress-induced intrinsic apoptotic signaling pathway regulation of oxidative stress-induced intrinsic apoptotic signaling pathway regulation of oxidative stress-induced cell death regulation of oxidative stress-induced cell death regulation of oxidative stress-induced intrinsic apoptotic signaling pathway-&gt;regulation of oxidative stress-induced cell death regulation of cellular response to oxidative stress regulation of cellular response to oxidative stress regulation of oxidative stress-induced cell death-&gt;regulation of cellular response to oxidative stress intrinsic apoptotic signaling pathway in response to oxidative stress intrinsic apoptotic signaling pathway in response to oxidative stress cell death in response to oxidative stress cell death in response to oxidative stress intrinsic apoptotic signaling pathway in response to oxidative stress-&gt;cell death in response to oxidative stress cellular response to oxidative stress cellular response to oxidative stress cell death in response to oxidative stress-&gt;cellular response to oxidative stress regulation of transcription from RNA polymerase II promoter in response to oxidative stress regulation of transcription from RNA polymerase II promoter in response to oxidative stress regulation of transcription from RNA polymerase II promoter in response to oxidative stress-&gt;cellular response to oxidative stress cellular response to oxidative stress-&gt;response to oxidative stress positive regulation of oxidative stress-induced cell death positive regulation of oxidative stress-induced cell death positive regulation of oxidative stress-induced cell death-&gt;regulation of oxidative stress-induced cell death positive regulation of cellular response to oxidative stress positive regulation of cellular response to oxidative stress positive regulation of cellular response to oxidative stress-&gt;regulation of cellular response to oxidative stress positive regulation of response to oxidative stress positive regulation of response to oxidative stress positive regulation of cellular response to oxidative stress-&gt;positive regulation of response to oxidative stress regulation of response to oxidative stress regulation of response to oxidative stress regulation of cellular response to oxidative stress-&gt;regulation of response to oxidative stress positive regulation of response to oxidative stress-&gt;regulation of response to oxidative stress detection of oxidative stress detection of oxidative stress detection of oxidative stress-&gt;response to oxidative stress positive regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway positive regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway positive regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway-&gt;regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway positive regulation of oxidative stress-induced intrinsic apoptotic signaling pathway positive regulation of oxidative stress-induced intrinsic apoptotic signaling pathway positive regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway-&gt;positive regulation of oxidative stress-induced intrinsic apoptotic signaling pathway positive regulation of oxidative stress-induced neuron death positive regulation of oxidative stress-induced neuron death positive regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway-&gt;positive regulation of oxidative stress-induced neuron death regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway-&gt;regulation of oxidative stress-induced intrinsic apoptotic signaling pathway regulation of oxidative stress-induced neuron death regulation of oxidative stress-induced neuron death regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway-&gt;regulation of oxidative stress-induced neuron death positive regulation of oxidative stress-induced intrinsic apoptotic signaling pathway-&gt;regulation of oxidative stress-induced intrinsic apoptotic signaling pathway positive regulation of oxidative stress-induced intrinsic apoptotic signaling pathway-&gt;positive regulation of oxidative stress-induced cell death positive regulation of oxidative stress-induced neuron death-&gt;positive regulation of oxidative stress-induced cell death positive regulation of oxidative stress-induced neuron death-&gt;regulation of oxidative stress-induced neuron death positive regulation of translation in response to oxidative stress positive regulation of translation in response to oxidative stress positive regulation of translation in response to oxidative stress-&gt;cellular response to oxidative stress negative regulation of oxidative stress-induced intrinsic apoptotic signaling pathway negative regulation of oxidative stress-induced intrinsic apoptotic signaling pathway negative regulation of oxidative stress-induced intrinsic apoptotic signaling pathway-&gt;regulation of oxidative stress-induced intrinsic apoptotic signaling pathway negative regulation of oxidative stress-induced cell death negative regulation of oxidative stress-induced cell death negative regulation of oxidative stress-induced intrinsic apoptotic signaling pathway-&gt;negative regulation of oxidative stress-induced cell death negative regulation of oxidative stress-induced cell death-&gt;regulation of oxidative stress-induced cell death neuron death in response to oxidative stress neuron death in response to oxidative stress neuron death in response to oxidative stress-&gt;cell death in response to oxidative stress negative regulation of response to oxidative stress negative regulation of response to oxidative stress negative regulation of response to oxidative stress-&gt;regulation of response to oxidative stress negative regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway negative regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway negative regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway-&gt;regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway negative regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway-&gt;negative regulation of oxidative stress-induced intrinsic apoptotic signaling pathway negative regulation of oxidative stress-induced neuron death negative regulation of oxidative stress-induced neuron death negative regulation of oxidative stress-induced neuron intrinsic apoptotic signaling pathway-&gt;negative regulation of oxidative stress-induced neuron death negative regulation of oxidative stress-induced neuron death-&gt;negative regulation of oxidative stress-induced cell death negative regulation of oxidative stress-induced neuron death-&gt;regulation of oxidative stress-induced neuron death regulation of translation in response to oxidative stress regulation of translation in response to oxidative stress regulation of translation in response to oxidative stress-&gt;cellular response to oxidative stress negative regulation of cellular response to oxidative stress negative regulation of cellular response to oxidative stress negative regulation of cellular response to oxidative stress-&gt;regulation of cellular response to oxidative stress negative regulation of cellular response to oxidative stress-&gt;negative regulation of response to oxidative stress regulation of oxidative stress-induced neuron death-&gt;regulation of oxidative stress-induced cell death negative regulation of translation in response to oxidative stress negative regulation of translation in response to oxidative stress negative regulation of translation in response to oxidative stress-&gt;regulation of translation in response to oxidative stress neuron intrinsic apoptotic signaling pathway in response to oxidative stress neuron intrinsic apoptotic signaling pathway in response to oxidative stress neuron intrinsic apoptotic signaling pathway in response to oxidative stress-&gt;intrinsic apoptotic signaling pathway in response to oxidative stress neuron intrinsic apoptotic signaling pathway in response to oxidative stress-&gt;neuron death in response to oxidative stress positive regulation of transcription from RNA polymerase II promoter in response to oxidative stress positive regulation of transcription from RNA polymerase II promoter in response to oxidative stress positive regulation of transcription from RNA polymerase II promoter in response to oxidative stress-&gt;regulation of transcription from RNA polymerase II promoter in response to oxidative stress oxidative stress-induced premature senescence oxidative stress-induced premature senescence oxidative stress-induced premature senescence-&gt;cellular response to oxidative stress negative regulation of transcription from RNA polymerase II promoter in response to oxidative stress negative regulation of transcription from RNA polymerase II promoter in response to oxidative stress negative regulation of transcription from RNA polymerase II promoter in response to oxidative stress-&gt;regulation of transcription from RNA polymerase II promoter in response to oxidative stress response to photooxidative stress response to photooxidative stress response to photooxidative stress-&gt;response to oxidative stress oxidative_stress_nodes.to_pickle(&#39;targets/oxidative_stress_GO.pickle&#39;) .",
            "url": "https://alexlenail.me/back_of_my_envelope/2022/08/01/Transcriptional-Target-Selection.html",
            "relUrl": "/2022/08/01/Transcriptional-Target-Selection.html",
            "date": " • Aug 1, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Equilibrium Binding of Transcription Factors",
            "content": "# imports import os, sys import string import json from collections import defaultdict import itertools from random import choice, random import pickle import requests from xml.etree import ElementTree import numpy as np import pandas as pd from scipy.stats import bernoulli, norm, lognorm, expon as exponential from scipy.stats import rv_discrete, rv_continuous from scipy.stats import hypergeom from scipy import interpolate import matplotlib import matplotlib.pyplot as plt import matplotlib as mpl from matplotlib.text import TextPath from matplotlib.font_manager import FontProperties from matplotlib.collections import PolyCollection from matplotlib.patches import Rectangle, Polygon, PathPatch from matplotlib.colors import colorConverter, TABLEAU_COLORS, LinearSegmentedColormap import matplotlib.cm as cm from mpl_toolkits.mplot3d import axes3d from mpl_toolkits.mplot3d import Axes3D from matplotlib.ticker import MaxNLocator # colorConverter.to_rgba(&#39;mediumseagreen&#39;, alpha=.5) import matplotlib_inline.backend_inline matplotlib_inline.backend_inline.set_matplotlib_formats(&#39;svg&#39;) %config InlineBackend.figure_format = &#39;retina&#39; %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] plt.rcParams[&#39;figure.dpi&#39;] = 140 plt.rcParams[&#39;agg.path.chunksize&#39;] = 10000 plt.rcParams[&#39;animation.html&#39;] = &#39;jshtml&#39; plt.rcParams[&#39;hatch.linewidth&#39;] = 0.3 from IPython.display import display, HTML from matplotlib_venn import venn2, venn3 import plotly.graph_objects as go import seaborn as sns # import seaborn.apionly as sns sns.set_style(&quot;white&quot;) import MOODS.tools from dna_features_viewer import GraphicFeature, GraphicRecord import pyBigWig ln = np.log exp = np.exp . # distribution plotting utilities def is_discrete(dist): if hasattr(dist, &#39;dist&#39;): return isinstance(dist.dist, rv_discrete) else: return isinstance(dist, rv_discrete) def is_continuous(dist): if hasattr(dist, &#39;dist&#39;): return isinstance(dist.dist, rv_continuous) else: return isinstance(dist, rv_continuous) def plot_distrib(distrib, title=None): fig, ax = plt.subplots(1, 1) if is_continuous(distrib): x = np.linspace(distrib.ppf(0.001), distrib.ppf(0.999), 1000) ax.plot(x, distrib.pdf(x), &#39;k-&#39;, lw=0.4) elif is_discrete(distrib): x = np.arange(distrib.ppf(0.01), distrib.ppf(0.99)) ax.plot(x, distrib.pmf(x), &#39;bo&#39;, ms=2, lw=0.4) r = distrib.rvs(size=1000) ax.hist(r, density=True, histtype=&#39;stepfilled&#39;, alpha=0.2, bins=200) if title: ax.set_title(title) fig_style_2(ax) return ax def fig_style_2(ax): for side in [&quot;right&quot;,&quot;top&quot;,&quot;left&quot;]: ax.spines[side].set_visible(False) ax.get_yaxis().set_visible(False) . # functions for plotting DNA base_colors = {&#39;A&#39;: &#39;Lime&#39;, &#39;G&#39;: &#39;Gold&#39;, &#39;C&#39;: &#39;Blue&#39;, &#39;T&#39;:&#39;Crimson&#39;} def print_bases(dna): return HTML(&#39;&#39;.join([f&#39;&lt;span style=&quot;color:{base_colors[base]};font-size:1.5rem;font-weight:bold;font-family:monospace&quot;&gt;{base}&lt;/span&gt;&#39; for base in dna])) def print_dna(dna): return HTML(&#39;&#39;.join([f&#39;&lt;span style=&quot;color:{base_colors[base]};font-size:1rem;font-family:monospace&quot;&gt;{base}&lt;/span&gt;&#39; for base in dna])) complement = {&#39;A&#39;:&#39;T&#39;, &#39;T&#39;:&#39;A&#39;, &#39;C&#39;:&#39;G&#39;, &#39;G&#39;:&#39;C&#39;, &#39;a&#39;:&#39;t&#39;, &#39;t&#39;:&#39;a&#39;, &#39;c&#39;:&#39;g&#39;, &#39;g&#39;:&#39;c&#39;} def reverse_complement(dna): list_repr = [complement[base] for base in dna[::-1]] if type(dna) == list: return list_repr else: return &#39;&#39;.join(list_repr) def reverse_complement_pwm(pwm, base_index=&#39;ACGT&#39;): return pwm[::-1, [base_index.index(complement[base]) for base in base_index]] . # gene name namespace_mapping utility import mygene def namespace_mapping(names, map_from=[&#39;symbol&#39;, &#39;alias&#39;], map_to=&#39;symbol&#39;, species=&#39;human&#39;): names = pd.Series(names) print(f&quot;passed {len(names)} symbols&quot;) names_stripped = names.str.strip() if any(names_stripped != names): print(f&quot;{sum(names.str.strip() != names)} names contained whitespace. Stripping...&quot;) names_stripped_unique = names_stripped.unique() if len(names_stripped_unique) != len(names_stripped): print(f&quot;{len(names_stripped) - len(names_stripped_unique)} duplicates. {len(names_stripped_unique)} uniques.&quot;) print() mg = mygene.MyGeneInfo() out, dup, missing = mg.querymany(names_stripped_unique.tolist(), scopes=map_from, fields=[map_to], species=species, as_dataframe=True, returnall=True).values() out = out.reset_index().rename(columns={&#39;query&#39;:&#39;input&#39;}).sort_values([&#39;input&#39;, &#39;_score&#39;], ascending=[True, False]).drop_duplicates(subset=&#39;input&#39;, keep=&#39;first&#39;) same = out[out.input == out.symbol] updates = out[(out.input != out.symbol) &amp; (out.notfound.isna() if &#39;notfound&#39; in out else True)].set_index(&#39;input&#39;)[&#39;symbol&#39;] print(f&quot; nunchanged: {len(same)}; updates: {len(updates)}; missing: {len(missing)}&quot;) names_updated = updates.reindex(names_stripped.values) names_updated = names_updated.fillna(names_updated.index.to_series()).values return updates, missing, names_updated . # define read_shell() to read dataframe from shell output import os, sys import subprocess import shlex import io def read_shell(command, shell=False, **kwargs): proc = subprocess.Popen(command, shell=shell,stdout=subprocess.PIPE, stderr=subprocess.PIPE) stdout, stderr = proc.communicate() if proc.returncode == 0: with io.StringIO(stdout.decode()) as buffer: return pd.read_csv(buffer, **kwargs) else: message = (&quot;Shell command returned non-zero exit status: {0} n n&quot; &quot;Command was: n{1} n n&quot; &quot;Standard error was: n{2}&quot;) raise IOError(message.format(proc.returncode, command, stderr.decode())) . Single TF . $$ newcommand{ kon}{k_{ mathrm{on}}} newcommand{ koff}{k_{ mathrm{off}}}$$There exist two mathematical formalisms to describe the probabilities of molecular configurations at equilibrium: thermodynamics and kinetics. In the kinetics formalism, the system transits between configurational states according to rate parameters contained in differential equations, which can describe not just the system&#39;s equilibrium but also its trajectory towards it, or the kinetics of non-equilibrium systems. In the thermodynamics/statistical mechanics formalism, we posit that a system will occupy configurations with lower energy, and use the Boltzmann distribution to estimate the proportion of time the system spends in each state, at equilibrium. The thermodynamics formalism is limited to describing equilibrium state probabilities, but it does so with fewer parameters. . We&#39;ll derive an expression for the probability of a single TFBS&#39; occupancy with both formalisms, but proceed with the thermodynamic description for more elaborate configurations. It will become clear why that is preferable. . Kinetics . Most derivations of the probability of single TFBS occupancy at equilibrium employ a kinetics formalism, so we&#39;ll walk through that first, and then explore the analog in the thermodynamics description. In the kinetics description, the parameters are rates. . $$ mathrm{TF} + mathrm{TFBS} underset{ koff}{ overset{ kon}{ rightleftarrows}} mathrm{TF colon TFBS} $$ . The natural rates are the rate of TF binding $ kon$ and unbinding $ koff$. Equilibrium is reached when binding and unbinding are balanced: . $$ frac{d[ mathrm{TF colon TFBS}]}{dt} = k_{ mathrm{on}}[ mathrm{TF}][ mathrm{TFBS}] - k_{ mathrm{off}}[ mathrm{TF colon TFBS}] = 0 text{ at equilibrium}$$ $$k_{ mathrm{on}}[ mathrm{TF}]_{ mathrm{eq}}[ mathrm{TFBS}]_{ mathrm{eq}} = k_{ mathrm{off}}[ mathrm{TF colon TFBS}]_{ mathrm{eq}}$$ $$ text{(dropping eq subscript) }[ mathrm{TF colon TFBS}] = frac{k_{ mathrm{on}}[ mathrm{TF}][ mathrm{TFBS}]}{k_{ mathrm{off}}} = frac{[ mathrm{TF}][ mathrm{TFBS}]}{k_{d}}$$ . where $k_{d} = frac{ koff}{ kon}$ is called the dissociation constant (or equilibrium constant). We&#39;d like to determine the probability of finding the TFBS occupied, i.e. the fraction of time it spends in the bound state. That fraction is $ frac{[ mathrm{bound}]}{([ mathrm{unbound}] + [ mathrm{bound}])} = frac{[ mathrm{TF colon TFBS}]}{([ mathrm{TFBS}] + [ mathrm{TF colon TFBS}])}$. Define the denominator as $[ mathrm{TFBS}]_{0} = [ mathrm{TFBS}] + [ mathrm{TF colon TFBS}]$ so that $[ mathrm{TFBS}] = [ mathrm{TFBS}]_{0} - [ mathrm{TF colon TFBS}]$ and substitute: . $$[ mathrm{TF colon TFBS}] = frac{[ mathrm{TF}]([ mathrm{TFBS}]_{0} - [ mathrm{TF colon TFBS}])}{k_{d}}$$ $$[ mathrm{TF colon TFBS}](k_d + [ mathrm{TF}]) = [ mathrm{TF}][ mathrm{TFBS}]_{0}$$ $$ frac{[ mathrm{TF colon TFBS}]}{[ mathrm{TFBS}]_{0}} = frac{[ mathrm{TF}]}{k_d + [ mathrm{TF}]}$$ . Note: We could also ask for this expression in terms of $[ mathrm{TF}]_0 = [ mathrm{TF}] + [ mathrm{TF colon TFBS}]$ however, since we&#8217;re considering a single TFBS, $[ mathrm{TF colon TFBS}]$ is at most 1, and so $[ mathrm{TF}]_0 approx [ mathrm{TF}]$. In instances of ligand-receptor binding in which that approximation cannot be made, the fraction bound is a messy quadratic. Derivation here. . Thermodynamics . In the thermodynamics description, the parameters are Gibbs free energies $ Delta G$. Let&#39;s follow the derivation from Physical Biology of the Cell (pp. 242) and consider the number microstates underlying each of the of bound and unbound macrostates, and their energies. . In order to count microstates, we imagine distributing $L$ TF molecules across a space-filling lattice with $ Omega$ sites. The energy of a TF in solution is $ varepsilon_{ mathrm{solution}}$ and the energy of a bound TF is $ varepsilon_{ mathrm{bound}}$. $ beta$ is the constant $1/k_b T$ where $k_b$ is Boltzmann&#39;s constant and $T$ is the temperature. . . State | Energy | Multiplicity | Weight | . | $A cdot A_s$ | $ frac{ Omega!}{( Omega - A)!A!} approx frac{ Omega^{A}}{A!}$ | $ frac{ Omega^{A}}{A!} cdot e^{- beta left[ A cdot A_s right]}$ | . | $(A - 1) A_s + A_b$ | $ frac{ Omega!}{( Omega - (A - 1))!(A-1)!B!} approx frac{ Omega^{A-1}}{(A-1)!}$ | $ frac{ Omega^{A-1}}{(A-1)!} cdot e^{- beta left[ (A - 1) A_s + A_b right]}$ | . In our case, the number of microstates in the unbound macrostate is $ frac{ Omega !}{L!( Omega -L)!} approx frac{ Omega^L}{L!}$ and they each have energy $L cdot varepsilon_s$. The number of microstates in the bound macrostate is $ frac{ Omega !}{(L-1)!( Omega -(L+1))} approx frac{ Omega^{(L-1)}}{(L-1)!}$ and they each have energy $(L-1) varepsilon_s + varepsilon_b$. . The Boltzmann distribution describes the probability of a microstate as a function of its energy: $p(E_i) = e^{- beta E_i}/Z$ where $Z$ is the &quot;partition function&quot; or simply $ sum_i e^{- beta E_i}$ the sum of the weights of the microstates, which normalizes the distribution. In our case: . $$Z(L, Omega)= left( colorbox{LightCyan}{$ frac{ Omega^L}{L!} e^{- beta L varepsilon_s}$} right) + left( colorbox{Seashell}{$ frac{ Omega^{(L-1)}}{(L-1)!} e^{- beta [(L-1) varepsilon_s + varepsilon_b]}$} right)$$ . With that expression in hand, we can express the probability of the bound macrostate, $p_b$: . $$p_b= frac{ colorbox{Seashell}{$ frac{ Omega^{(L-1)}}{(L-1)!} e^{- beta [(L-1) varepsilon_s + varepsilon_b]}$}}{ colorbox{LightCyan}{$ frac{ Omega^L}{L!} e^{- beta L varepsilon_s}$} + colorbox{Seashell}{$ frac{ Omega^{(L-1)}}{(L-1)!} e^{- beta [(L-1) varepsilon_s + varepsilon_b]}$}} cdot color{DarkRed} frac{ frac{ Omega^L}{L!}e^{ beta L varepsilon_s}}{ frac{ Omega^L}{L!}e^{ beta L varepsilon_s}} color{black} = frac{(L/ Omega)e^{- beta Delta varepsilon}}{1+(L/ Omega)e^{- beta Delta varepsilon}} $$ . Where we have defined $ Delta varepsilon = varepsilon_b - varepsilon_s$. $L/ Omega$ is really just a dimensionless TF concentration, which we&#39;ll hand-wave as being equivalent to $[ mathrm{TF}]$, which leaves us with an expression suspiciously similar to the one we derived from the kinetics formalism: . $$p_b = frac{[ mathrm{TF}]e^{- beta Delta varepsilon}}{1+[ mathrm{TF}]e^{- beta Delta varepsilon}} cdot color{DarkRed} frac{e^{ beta Delta varepsilon}}{e^{ beta Delta varepsilon}} color{black} = frac{[ mathrm{TF}]}{e^{ beta Delta varepsilon}+[ mathrm{TF}]}$$ . From which we recapitulate an important correspondence between kinetics and thermodynamics at equilibrium: $ k_d = e^{ beta Delta varepsilon} = e^{ Delta varepsilon / k_bT} $ more commonly written for different units as $k = e^{- Delta G / RT}$. . The takeaway is that both the kinetics and thermodynamics formalisms produce an equivalent expression for the probabilities of each of the bound and unbound configurations, parameterized respectively by $k_d$ and $ Delta G$. . References: . Physical Biology of the Cell | Thermodynamics of Biological Processes | Statistical Mechanics of Binding | . Sample Values . In order to compute probabilities like $p_b$, we need concrete TF concentrations $[ mathrm{TF}]$ and binding affinities (either $k_d$ or $ Delta G$). What are typical intranuclear TF concentrations and binding affinities? . Concentrations . A typical human cell line, K562s, have a cellular diameter of 17 microns. (BioNumbers) . def sphere_volume(d): return 4/3*np.pi*(d/2)**3 K562_diameter_microns = 17 K562_volume_micron_cubed = sphere_volume(K562_diameter_microns) print(f&#39;K562 volume: {round(K562_volume_micron_cubed)} μm^3&#39;) . K562 volume: 2572 μm^3 . A typical expressed TF has a per-cell copy number range from $10^3$ - $10^6$. (BioNumbers) . copy_number_range = [1e3, 1e6] N_A = 6.02214076e23 def copy_number_and_cubic_micron_volume_to_molar_concentration(copy_number, volume=K562_volume_micron_cubed): return (copy_number / N_A) / (volume * (1e3 / 1e18)) # 1000 Liters / m^3; 1e18 μm^3 / m^3 lower_end_molar = copy_number_and_cubic_micron_volume_to_molar_concentration(copy_number_range[0], K562_volume_micron_cubed) upper_end_molar = copy_number_and_cubic_micron_volume_to_molar_concentration(copy_number_range[1], K562_volume_micron_cubed) lower_end_nanomolar = lower_end_molar / 1e-9 upper_end_nanomolar = upper_end_molar / 1e-9 print(&#39;If TF copy numbers range from 1,000-1,000,000, then TF concentrations range from&#39;, str(round(lower_end_nanomolar))+&#39;nM&#39;, &#39;to&#39;, str(round(upper_end_nanomolar))+&#39;nM&#39;) . If TF copy numbers range from 1,000-1,000,000, then TF concentrations range from 1nM to 646nM . We might also like a distribution over this range. Let&#39;s posit a lognormal, where $10^3$ and $10^6$ are the 3σ from the mean, which is $10^{4.5}$. Then $ sigma = 10^{0.5}$ . # define a distribution over TF copy numbers # Note: the lognormal is defined with base e, so we need to take some natural logs on our base 10 expression. TF_copy_number_distrib = lognorm(scale=10**4.5, s=np.log(10**0.5)) ax = plot_distrib(TF_copy_number_distrib, title=&#39;Hypothetical expressed TF copy number distribution&#39;) ax.set_xlim(left=0, right=5e5) ax.set_xlabel(&#39;TF protein copy number / cell&#39;) ax.get_xaxis().set_major_formatter(matplotlib.ticker.FuncFormatter(lambda x, p: format(int(x), &#39;,&#39;))) def TF_nanomolar_concentrations_sample(TFs): return dict(zip(TFs, (copy_number_and_cubic_micron_volume_to_molar_concentration(TF_copy_number_distrib.rvs(len(TFs)))*1e9).astype(int))) . Affinities . What are typical TF ΔG&#39;s of binding? How about the $ koff$ rates and half lives? . We can use the prior knowledge that dissociation constants should be in the nanomolar regime (BioNumbers). | We can use the relation that $ Delta G = -k_b T cdot ln(k_d)$ (Plugging in 310°K (human body temp) and the Boltzmann constant $k_b$ in kcal/Mol) | We use the approximation that $ kon$ is ~$10^5 / $ Molar $ times $ sec (Wittrup) | . T = 310 k_b = 3.297623483e-24 * 1e-3 ## cal/K * kcal/cal kbT = k_b*T*N_A kbT ## in 1/Mol -- an unusual format k_on = 1e5 def nanomolar_kd_from_kcal_ΔG(ΔG): return exp(-ΔG/kbT) * 1e9 def kcal_ΔG_from_nanomolar_kd(K_d): return -kbT*ln(K_d*1e-9) def k_off_from_nanomolar_kd(k_d): return (k_d*1e-9) * k_on def half_life_from_kd(k_d): return ln(2) / ((k_d*1e-9) * k_on) . # compute statistics from kds nanomolar_kds = pd.Series([1, 10, 100, 1000]) affinity_grid = pd.DataFrame() affinity_grid[&#39;$k_d$&#39;] = nanomolar_kds affinity_grid[&#39;$ Delta G$&#39;] = nanomolar_kds.apply(kcal_ΔG_from_nanomolar_kd) affinity_grid[&#39;$ kon$&#39;] = &#39;1e5 / (M * s)&#39; affinity_grid[&#39;$ koff$&#39;] = nanomolar_kds.apply(k_off_from_nanomolar_kd) affinity_grid[&#39;$t_{1/2}$&#39;] = pd.to_timedelta(nanomolar_kds.apply(half_life_from_kd), unit=&#39;s&#39;) affinity_grid = affinity_grid.set_index(&#39;$k_d$&#39;) affinity_grid . $ Delta G$ $ kon$ $ koff$ $t_{1/2}$ . $k_d$ . 1 12.757685 | 1e5 / (M * s) | 0.0001 | 0 days 01:55:31.471805599 | . 10 11.340164 | 1e5 / (M * s) | 0.0010 | 0 days 00:11:33.147180560 | . 100 9.922644 | 1e5 / (M * s) | 0.0100 | 0 days 00:01:09.314718056 | . 1000 8.505123 | 1e5 / (M * s) | 0.1000 | 0 days 00:00:06.931471806 | . We learn that an order of magnitude residence time difference results from just 1.4 extra kcal/Mol, and that TF half lives range from about 5s to about 2h. Let&#39;s once again posit a distribution of affinities to sample from (defined on $k_d$): . # define a distribution over TF Kd&#39;s / ΔG&#39;s TF_affinity_min = 6 ## define exponential distribution in log10 space TF_affinity_spread = 0.5 TF_affinity_distrib = exponential(loc=TF_affinity_min, scale=TF_affinity_spread) ax = plot_distrib(TF_affinity_distrib, title=&quot;Hypothetical TF $K_d$ distribution&quot;) ax.set_xlim(left=5.9) ax.set_xlabel(&#39;$k_d$&#39;) plt.xticks([6,7,8,9], [&#39;1000μm&#39;, &#39;100nm&#39;, &#39;10nm&#39;, &#39;1nm&#39;]) def TF_Kd_sample(n=1): return 10**(-TF_affinity_distrib.rvs(n)) def TF_ΔG_sample(n=1): return kcal_ΔG_from_nanomolar_kd(10**(-TF_affinity_distrib.rvs(n)+9)) . With those concrete TF concentrations and dissociation constants, we can finally plot our function $p_b = frac{[ mathrm{TF}]}{e^{ beta Delta varepsilon}+[ mathrm{TF}]}$. . @np.vectorize def fraction_bound(TF, ΔG): &#39;&#39;&#39;TF in nanomolar&#39;&#39;&#39; return TF / (TF + nanomolar_kd_from_kcal_ΔG(ΔG)) . # plot fraction bound as a function of concentration and binding energy TF_concentration_array = np.logspace(1, 5) ΔG_array = np.logspace(*np.log10([8, 13])) TF_concs_matrix, ΔG_matrix = np.meshgrid(TF_concentration_array, ΔG_array) z_data = pd.DataFrame(fraction_bound(TF_concs_matrix, ΔG_matrix), index=ΔG_array, columns=TF_concentration_array).rename_axis(&#39;ΔG&#39;).T.rename_axis(&#39;[TF]&#39;) fig = go.Figure(data=[go.Surface(x=TF_concentration_array.astype(int).astype(str), y=ΔG_array.round(1).astype(str), z=z_data.values)]) fig.update_layout( title=&#39;&#39;, autosize=False, width=700, margin=dict(r=20, l=10, b=10, t=10), scene = dict( xaxis_title=&#39;[TF]&#39;, yaxis_title=&#39;ΔG&#39;, zaxis_title=&#39;Pb&#39;), scene_camera = dict(eye=dict(x=-1, y=-1.8, z=1.25))) fig.update_traces(showscale=False) # config = dict({&#39;scrollZoom&#39;: False}) # fig.show(config = config) # display(fig) HTML(fig.to_html(include_plotlyjs=&#39;cdn&#39;, include_mathjax=False)) . . . (Note that both $[ mathrm{TF}]$ and $k_d$ are plotted in log space, but $p_b$ is linear.) . Multiple TFs: Direct Cooperativity &amp; Competition . Suppose now that two TFs bind adjacent segments of DNA in such a way that the binding of either facilitates (or hinders) the binding of the other. We call this direct cooperativity (and competition). We&#39;ll focus first on cooperativity. . Cooperativity . As before, the statistical mechanics formalism entails enumerating the configurations, their multiplicities, and their energies. We&#39;ll call the TFs A and B. We&#39;ll denote their counts as $A$ and $B$. The energy of a TF in solution will once more be $A_s$ and bound to its cognate TFBS $A_b$. The energy of cooperativity will be $C_{AB}$. . State | Energy | Multiplicity | Weight | . | $A cdot A_s + B cdot B_s$ | $ frac{ Omega!}{( Omega - A - B)!A!B!} approx frac{ Omega^{A+B}}{A!B!}$ | $ frac{ Omega^{A+B}}{A!B!} cdot e^{- beta left[ A cdot A_s + B cdot B_s right]}$ | . | $(A - 1) A_s + A_b + B cdot B_s$ | $ frac{ Omega!}{( Omega - (A - 1) - B)!(A-1)!B!} approx frac{ Omega^{A+B-1}}{(A-1)!B!}$ | $ frac{ Omega^{A+B-1}}{(A-1)!B!} cdot e^{- beta left[ (A - 1) A_s + A_b + B cdot B_s right]}$ | . | $A cdot A_s + (B - 1) B_s + B_b$ | $ frac{ Omega!}{( Omega - A - (B - 1))!A!(B-1)!} approx frac{ Omega^{A+B-1}}{A!(B-1)!}$ | $ frac{ Omega^{A+B-1}}{A!(B-1)!} cdot e^{- beta left[ A cdot A_s + (B - 1) B_s + B_b right]}$ | . | $(A - 1) A_s + A_b + (B - 1) B_s + B_b + C_{AB}$ | $ frac{ Omega!}{( Omega - (A - 1) - (B-1))!(A-1)!(B-1)!} approx frac{ Omega^{A+B-2}}{(A-1)!(B-1)!}$ | $ frac{ Omega^{A+B-2}}{(A-1)!(B-1)!} cdot e^{- beta left[ (A - 1) A_s + A_b + (B - 1) B_s + B_b + C_{AB} right]}$ | . The partition function is the sum of the weights: . $$ Z = frac{ Omega^{A+B}}{A!B!} cdot e^{- beta left[ A cdot A_s + B cdot B_s right]} + frac{ Omega^{A+B-1}}{(A-1)!B!} cdot e^{- beta left[ (A - 1) A_s + A_b + B cdot B_s right]} + frac{ Omega^{A+B-1}}{A!(B-1)!} cdot e^{- beta left[ A cdot A_s + (B - 1) B_s + B_b right]} + frac{ Omega^{A+B-2}}{(A-1)!(B-1)!} cdot e^{- beta left[ (A - 1) A_s + A_b + (B - 1) B_s + B_b + C_{AB} right]}$$Which we can greatly simplify by multiplying the entire expression by the reciprocal of the &quot;base state&quot; weight, $ color{DarkRed} frac{A!B!}{ Omega^{A+B}} cdot e^{ beta left[ A cdot A_s + B cdot B_s right]}$, normalizing that weight to 1: . $$ Z = 1 + frac{A}{ Omega} cdot e^{- beta left[ A_b-A_s right]} + frac{B}{ Omega} cdot e^{- beta left[ B_b-B_s right]} + frac{A cdot B}{ Omega^2} cdot e^{- beta left[ A_b-A_s+B_b-B_s+C_{AB} right]}$$Taking the definition $[A] = A/ Omega$ and $ Delta G_A = A_b-A_s$ produces: . $$ Z = 1 + [A] e^{- beta left[ Delta G_A right]} + [B] e^{- beta left[ Delta G_B right]} + [A][B] e^{- beta left[ Delta G_A+ Delta G_B+C_{AB} right]}$$Then the probability of any state is just the weight of that state (scaled by the weight of the base state) divided by the partition function expression $Z$. . From the above, we notice the form of the expression for the weight of a configuration of N TFBSs: . $$ p_{ mathrm{config}} = prod_{i in , mathrm{bound ,TBFS}} left( [ mathrm{TF}_{ mathrm{cognate}(i)}] cdot e^{- beta left[ Delta G_i + sum_j c_{ij} right]} right) / Z$$ . For numerical stability, we take the log of the unnormalized probability (that is, the weight) of configurations: . $$ log( tilde{p}_{ mathrm{config}}) = sum_{i in , mathrm{bound ,TBFS}} left( log([ mathrm{TF}_{ mathrm{cognate}(i)}]) - beta left[ Delta G_i + sum_j c_{ij} right] right) $$ . # define log_P_config() β = 1/kbT ## kbT was in in 1/Mol def log_P_config(config, TF_conc, TFBSs, cooperativities): logP = 0 for i, tfbs in TFBSs[config.astype(bool)].iterrows(): cooperativity_sum = 0 if i in cooperativities: cooperativity_sum = sum([C_AB for tfbs_j, C_AB in cooperativities[i].items() if config[tfbs_j] == 1]) logP = sum([np.log(TF_conc[tfbs.TF]*1e-9) + β*(tfbs.dG + cooperativity_sum)]) ## the sign is flipped here, because our ΔG&#39;s of binding are positive above. return logP . Competition . Incorporating competition into our thermodynamic model is slightly more subtle than cooperativity, because we can imagine two types of competition . Two TFs which may both bind DNA at adjacent sites, causing a free energy penalty due to some unfavorable interaction. | Two TFs with overlapping DNA binding sites, which cannot physically be bound at the same time. | . In the former case, the expression for $p_ mathrm{config}$ we had written before suffices, with values of $C_{AB}$ having both signs to represent cooperativity and competition. Nominally, the latter case also fits this formalism if we allow $C_{AB}$ to reach $- infty$, but that would cause us headaches in the implementation. Instead, the weights of all those configurations which are not physical attainable, due to &quot;strict&quot; competitive binding between TFs vying for overlapping binding sites, are merely omitted from the denominator $Z$. . References: . Transcriptional regulation by the numbers: models | Thermodynamic State Ensemble Models of cis-Regulation | . Sample cooperativity values . In order to compute concrete probabilities of configurations, accounting for cooperativity and competition, we will need concrete energies. We&#39;ll take $C_{AB}$ to be distributed exponentially with a mean at 2.2kcal/Mol. (Forsén &amp; Linse). . # define a distribution of cooperativities cooperativity_mean_ΔG = 2.2 cooperativity_distrib = exponential(scale=cooperativity_mean_ΔG) ax = plot_distrib(cooperativity_distrib, title=&quot;Hypothetical $C_{AB}$ distribution&quot;) ax.set_xlim(left=-0.5,right=15) ax.set_xlabel(&#39;$C_{AB}$ (kcal/mol)&#39;) def C_AB_sample(n=1): return cooperativity_distrib.rvs(n) . # sample that distribution for cooperativities between binding sites def sample_cooperativities(TFBSs): cooperativities = defaultdict(lambda: dict()) for i, tfbs_i in TFBSs.iterrows(): for j, tfbs_j in TFBSs.iterrows(): if i &lt; j: if 7 &lt;= abs(tfbs_i.start - tfbs_j.start) &lt;= 10: cooperativities[i][j] = cooperativities[j][i] = C_AB_sample()[0] elif abs(tfbs_i.start - tfbs_j.start) &lt; 7: cooperativities[i][j] = cooperativities[j][i] = -C_AB_sample()[0] return dict(cooperativities) . Let&#39;s check our derivation (and our implementation) of $p_ mathrm{config}$ by comparing it to our direct computation of $p_b$ from §1. Single TF. . # define create_environment() len_TFBS=10 def create_environment(len_DNA=1000, num_TFs=10, num_TFBS=20, len_TFBS=10): # TFBSs is a dataframe with columns &#39;TF_name&#39;, &#39;start&#39;, &#39;dG&#39; TFs = list(string.ascii_uppercase[:num_TFs]) ## TF names are just letters from the alphabet TF_conc = TF_nanomolar_concentrations_sample(TFs) TFBSs = pd.DataFrame([{&#39;TF&#39;: choice(TFs), &#39;start&#39;: int(random()*(len_DNA-len_TFBS)), &#39;dG&#39;: TF_ΔG_sample()[0]} for _ in range(num_TFBS)]).sort_values(by=&#39;start&#39;).reset_index(drop=True) cooperativities = sample_cooperativities(TFBSs) return TFs, TF_conc, TFBSs, cooperativities . # define draw_config() for plotting def draw_config(TFBSs, TF_conc, cooperativities, config=None, len_DNA=1000): if config is None: config = [0]*len(TFBSs) TF_colors = dict(zip(list(TF_conc.keys()), list(TABLEAU_COLORS.values()))) plt.rcParams[&#39;figure.figsize&#39;] = [12, 0.5+np.sqrt(len(TFs))] fig, axs = plt.subplots(ncols=2, sharey=True, gridspec_kw={&#39;width_ratios&#39;: [4, 1]}) genome_track_ax = draw_genome_track(axs[0], config, TFBSs, cooperativities, TF_colors, len_DNA=len_DNA) conc_plot_ax = draw_concentration_plot(axs[1], TF_conc, TF_colors) return genome_track_ax, conc_plot_ax def draw_concentration_plot(conc_plot_ax, TF_conc, TF_colors): conc_plot_ax.barh(range(len(TF_conc.keys())), TF_conc.values(), align=&#39;edge&#39;, color=list(TF_colors.values()), alpha=0.9) for p in conc_plot_ax.patches: conc_plot_ax.annotate(str(p.get_width())+&#39;nm&#39;, (p.get_width() + 10*(p.get_width()&gt;0), p.get_y() * 1.02), fontsize=&#39;x-small&#39;) conc_plot_ax.axes.get_yaxis().set_visible(False) conc_plot_ax.axes.get_xaxis().set_visible(False) conc_plot_ax.set_frame_on(False) return conc_plot_ax def draw_genome_track(genome_track_ax, config, TFBSs, cooperativities, TF_colors, len_DNA=1000): genome_track_ax.set(ylabel=&#39;TFs&#39;, ylim=[-1, len(TF_colors.keys())+1], yticks=range(len(TFs)), yticklabels=TFs, xlabel=&#39;Genome&#39;, xlim=[0, len_DNA]) for i, tfbs in TFBSs.iterrows(): tfbs_scale = np.clip(0.01*np.exp(tfbs.dG-7), 0, 1) genome_track_ax.add_patch(Rectangle((tfbs.start, TFs.index(tfbs.TF)), len_TFBS, 0.8, fc=TF_colors[tfbs.TF], alpha=tfbs_scale)) genome_track_ax.add_patch(Rectangle((tfbs.start, TFs.index(tfbs.TF)), len_TFBS, 0.1*tfbs_scale, fc=TF_colors[tfbs.TF], alpha=1)) genome_track_ax.annotate(str(int(tfbs.dG))+&#39;kcal/Mol&#39;, (tfbs.start, TFs.index(tfbs.TF)-0.3), fontsize=&#39;xx-small&#39;) genome_track_ax.add_patch(Polygon([[tfbs.start+2, TFs.index(tfbs.TF)], [tfbs.start+5,TFs.index(tfbs.TF)+0.8],[tfbs.start+8, TFs.index(tfbs.TF)]], fc=TF_colors[tfbs.TF], alpha=config[i])) cm = matplotlib.cm.ScalarMappable(norm=matplotlib.colors.Normalize(vmin=-3, vmax=3), cmap=matplotlib.cm.PiYG) for i, rest in cooperativities.items(): for j, C_AB in rest.items(): tfbs_i = TFBSs.iloc[i] tfbs_j = TFBSs.iloc[j] xa = tfbs_i.start+(len_TFBS/2) xb = tfbs_j.start+(len_TFBS/2) ya = TFs.index(tfbs_i.TF) yb = TFs.index(tfbs_j.TF) genome_track_ax.plot([xa, (xa+xb)/2, xb], [ya+0.9, max(ya, yb)+1.2, yb+0.9], color=cm.to_rgba(C_AB)) genome_track_ax.grid(axis=&#39;y&#39;, lw=0.1) genome_track_ax.set_frame_on(False) return genome_track_ax . def enumerate_configs(TFBSs): return list(map(np.array, itertools.product([0,1], repeat=len(TFBSs)))) def p_configs(TFBSs, TF_conc, cooperativities): configs = enumerate_configs(TFBSs) weights = [] for config in configs: weights.append(np.exp(log_P_config(config, TFBSs=TFBSs, TF_conc=TF_conc, cooperativities=cooperativities))) return list(zip(configs, np.array(weights) / sum(weights))) . TFs, TF_conc, TFBSs, cooperativities = create_environment(len_DNA=100, num_TFs=1, num_TFBS=1) print(&#39;p_bound (prev method): t&#39;, fraction_bound(TF_conc[&#39;A&#39;], TFBSs.iloc[0].dG)) print(&#39;p_config (new method): t&#39;, p_configs(TFBSs=TFBSs, TF_conc=TF_conc, cooperativities={})) genome_track_ax, conc_plot_ax = draw_config(TFBSs=TFBSs, TF_conc=TF_conc, cooperativities=cooperativities, len_DNA=100) plt.tight_layout() . p_bound (prev method): 0.00921878699097193 p_config (new method): [(array([0]), 0.9907812130090282), (array([1]), 0.00921878699097194)] . With that sanity check, let&#39;s now consider the scenario of two transcription factors with cooperative binding, and compute the probabilities of each of the 4 configurations: . # Create cooperative environment len_DNA = 100 TFs = [&#39;A&#39;, &#39;B&#39;] TF_conc = TF_nanomolar_concentrations_sample(TFs) TFBSs = pd.DataFrame([{&#39;TF&#39;: &#39;A&#39;, &#39;start&#39;: 10, &#39;dG&#39;: TF_ΔG_sample()[0]}, {&#39;TF&#39;: &#39;B&#39;, &#39;start&#39;: 20, &#39;dG&#39;: TF_ΔG_sample()[0]}]) cooperativities = {0: {1: 2}, 1: {0: 2}} TF_colors = dict(zip(list(TF_conc.keys()), list(TABLEAU_COLORS.values()))) plt.rcParams[&#39;figure.figsize&#39;] = [12, 2*(0.8+int(np.sqrt(len(TFs))))] fig, axs = plt.subplots(nrows=2, ncols=2) for ax, (config, p) in zip([ax for row in axs for ax in row], p_configs(TFBSs=TFBSs, TF_conc=TF_conc, cooperativities=cooperativities)): draw_genome_track(ax, config, TFBSs, cooperativities, TF_colors, len_DNA=50) ax.set(ylabel=&#39;&#39;, xlabel=&#39;&#39;) ax.set_title(&#39;$p_ mathrm{config}$: &#39;+str(round(p*100,3))+&#39;%&#39;, y=1.0, pad=-28, loc=&#39;left&#39;, fontsize=10) . Low-Affinity binding . In reality, transcription factors&#39; binding sites are not so discretely present or absent: transcription factors may bind anywhere along the DNA polymer, with an affinity dependent on the interaction surface provided by the sequence of nucleotides at each locus. There are a variety of approaches to model the sequence-to-affinity function for each TF. The simplest is to consider each nucleotide independently, and list the preferences for each nucleotide at each sequential position in a matrix. This type of &quot;mono-nucleotide position weight matrix&quot; (PWM) model is commonly used, and frequently represented by a &quot;sequence logo&quot; plot. . PWMs: Construction . I have curated PWMs from various databases for ~1000 human TFs. . tfdb2 = pd.read_json(&#39;../../AChroMap/data/processed/TF.2022.json&#39;).fillna(value=np.nan) ## prefer nan to None cisbp_pwms = pd.read_pickle(&#39;../../tfdb/data/processed/CISBP_2_PWMs.pickle&#39;) humanTFs_pwms = pd.read_pickle(&#39;../../tfdb/data/processed/HumanTFs_PWMs.pickle&#39;) jaspar2022_pwms = pd.read_pickle(&#39;../../tfdb/data/processed/jaspar2022_PWMs.pickle&#39;) probound_pwms = pd.read_json(&#39;../../AChroMap/data/processed/TF_ProBound.json&#39;, orient=&#39;records&#39;).T # we only get probound as delta G scores, not as PWMs . As an example, consider the Transcription Factor SPI1 / PU.1, for which the following PWMs are registered in the CisBP 2.00 database: . SPI1_pwms = tfdb2.loc[(tfdb2.Name == &#39;SPI1&#39;)] SPI1_cisbp_pwms = cisbp_pwms.loc[SPI1_pwms.CISBP_2_strict.iat[0]] SPI1_humanTFs_pwms = humanTFs_pwms.reindex(SPI1_pwms.HumanTFs.iat[0]).dropna() SPI1_jaspar2022_pwms = jaspar2022_pwms.loc[SPI1_pwms.JASPAR_2022.iat[0]] SPI1_probound_pwms = probound_pwms.loc[SPI1_pwms.ProBound.iat[0]].pwm . # plot PWMs def hide_axes_and_spines(ax, hide_x_axis=True, hide_y_axis=True, spines_to_hide=[&#39;right&#39;,&#39;top&#39;,&#39;left&#39;,&#39;bottom&#39;]): for side in spines_to_hide: ax.spines[side].set_visible(False) if hide_x_axis: ax.get_xaxis().set_visible(False) if hide_y_axis: ax.get_yaxis().set_visible(False) fp = FontProperties(family=&quot;Arial&quot;, weight=&quot;bold&quot;) globscale = 1.35 LETTERS = { &quot;T&quot; : TextPath((-0.305, 0), &quot;T&quot;, size=1, prop=fp), &quot;G&quot; : TextPath((-0.384, 0), &quot;G&quot;, size=1, prop=fp), &quot;A&quot; : TextPath((-0.35, 0), &quot;A&quot;, size=1, prop=fp), &quot;C&quot; : TextPath((-0.366, 0), &quot;C&quot;, size=1, prop=fp) } def letterAt(letter, x, y, yscale=1, ax=None): text = LETTERS[letter] t = mpl.transforms.Affine2D().scale(1*globscale, yscale*globscale) + mpl.transforms.Affine2D().translate(x,y) + ax.transData p = PathPatch(text, lw=0, fc=base_colors[letter], transform=t, alpha=1-0.8*(y&lt;0)) if ax != None: ax.add_artist(p) return p def plot_pwm(pwm, ax=None, base_index=&#39;ACGT&#39;, figsize=(4,2), xtick_offset=0): if ax is None: fig, ax = plt.subplots(figsize=figsize) max_y = 0 min_y = 0 for i, row in enumerate(pwm): x = xtick_offset+i pos_y = 0 neg_y = -0.1 for score, base in sorted(zip(row, base_index)): if score &gt; 0: letterAt(base, x,pos_y, score, ax=ax) pos_y += score if score &lt; 0: neg_y += score letterAt(base, x,neg_y, abs(score), ax=ax) max_y = max(max_y, pos_y) min_y = min(min_y, neg_y) ax.set(xticks=range(-1,len(pwm)+xtick_offset), xlim=(-1, len(pwm)+xtick_offset), ylim=(min_y, max_y)) if min_y &lt; -0.1: ax.set_ylabel(&#39;ΔΔG/RT&#39;, weight=&#39;bold&#39;) hide_axes_and_spines(ax, hide_y_axis=False) else: hide_axes_and_spines(ax) plt.tight_layout() return ax . for (name, SPI1_pwm), offset in zip(SPI1_cisbp_pwms.items(), (0,0,2,0,0,0)): ax = plot_pwm(SPI1_pwm, figsize=((len(SPI1_pwm)+offset+1)*0.25,1), xtick_offset=offset) ax.set_title(name, loc=&#39;left&#39;) . This representation of this matrix visualizes the proportion of occurrences of a base at a particular position in aligned SPI1 binding sites. Since they look similar, we may be tempted to average them to have a single model of PU.1 binding, however it is considered unwise to do so, as TFs are believed to have multiple binding &quot;modes&quot; which refers explicitly to modes in the distribution of sequence-binding affinities. . These PWM models can be fit from a variety of experiments measuring PU.1 binding. In this case, we&#39;re looking at models fit from High-Throughput SELEX data, but other models for PU.1 binding generated from other types of experiments are catalogued at its entry in the HumanTFs database. . PWMs: scoring sequences . If we assume a TF&#39;s PWM catalogues its relative binding preferences to every possible sequence of individual bases, we can use that PWM to evaluate the relative probabilities of TF binding to new sequences. We&#39;ll define the PWM &quot;score&quot; as the (log) ratio of the probability of the sequence with the PWM against random chance. The probability of a sequence under the PWM is $ prod mathrm{PWM}[i][ mathrm{dna}[i]]$. The probability of the sequence under a background model is $ prod mathrm{bg}( mathrm{dna}[i])$ where $ mathrm{bg}$ describes the frequency of each base in the genome (not quite 1/4 in the human genome). We take the logarithm of the ratio of these two probabilities to produce the log-likelihood ratio, which we call our &quot;score&quot;: . $$ mathrm{score}( mathrm{PWM}, j) = log( frac{ prod mathrm{PWM}[i][ mathrm{dna}[j+i]]}{ prod mathrm{bg}( mathrm{dna}[j+i])}) = sum log( frac{ mathrm{PWM}[i][ mathrm{dna}[j+i]]}{ mathrm{bg}( mathrm{dna}[j+i])}) $$ . A positive $ mathrm{score}( mathrm{PWM}, j)$ indicates the subsequence starting at position $j$ is likelier under the PWM model than a random sequence from the human genome, and a negative score indicates the subsequence is more likely to be random. Let&#39;s visualize a PU.1 scoring matrix: . bg = [0.2955, 0.2045, 0.2045, 0.2955] pseudocount = 0.0001 def log_odds_pwm(pwm): return np.log((pwm+pseudocount)/bg) . pwm = SPI1_cisbp_pwms.iloc[1] pwm_name = SPI1_cisbp_pwms.index[0] ax = plot_pwm(log_odds_pwm(pwm), figsize=(4,4)) _ = ax.set_ylabel(&#39;score&#39;, weight=&#39;bold&#39;) . cisbp_score_pwms = cisbp_pwms.apply(log_odds_pwm) humanTFs_score_pwms = humanTFs_pwms.apply(log_odds_pwm) jaspar2022_score_pwms = jaspar2022_pwms.apply(log_odds_pwm) SPI1_cisbp_score_pwms = cisbp_score_pwms.loc[SPI1_pwms.CISBP_2_strict.iat[0]] SPI1_humanTFs_score_pwms = humanTFs_score_pwms.reindex(SPI1_pwms.HumanTFs.iat[0]).dropna() SPI1_jaspar2022_score_pwms = jaspar2022_score_pwms.loc[SPI1_pwms.JASPAR_2022.iat[0]] . Our strategy will be to score genomic regions for TF binding, searching for high PWM scores starting at every offset $j$ in the supplied DNA sequence. Let&#39;s remind ourselves here that in order to find the full set of motif matches in a supplied DNA sequence, we either need to scan the reference genome and its reverse complement, or scan the positive strand with both the forward and reverse-complement PWMs. We opt for the latter approach, and therefore augment our PWM set with reverse-complement PWMs: . plot_pwm(pwm, figsize=(4,1)).set_title(&#39;Forward: &#39;+pwm_name, loc=&#39;left&#39;) plot_pwm(reverse_complement_pwm(pwm), figsize=(4,1)).set_title(&#39;Reverse: &#39;+pwm_name, loc=&#39;left&#39;) None . Since we now have sequence-dependent transcription factor binding models, we will select a sequence which harbors known binding sites for select transcription factors, and see whether the models predict binding of those transcription factors. . As a specific sequence, let&#39;s use the SPI1 promoter. . def get_reference_transcript(gene_name): hg38_reference_annotation = pd.read_csv(&#39;../../AChroMap/data/processed/GRCh38_V29.csv&#39;) reference_transcript = hg38_reference_annotation[(hg38_reference_annotation.gene_name == gene_name) &amp; (hg38_reference_annotation.canonicity == 0)] chrom = reference_transcript.chr.iat[0] strand = reference_transcript.strand.iat[0] tss = (reference_transcript.txStart if all(reference_transcript.strand == 1) else reference_transcript.txEnd).iat[0] return chrom, strand, tss . gene_name = &#39;SPI1&#39; chrom, strand, tss = get_reference_transcript(gene_name) start = tss-400 stop = tss+400 . def get_hg38_bases_local(chrom, start, stop): seqkit_command = f&#39;seqkit subseq /Users/alex/Documents/AChroMap/data/raw/genome/hg38_fa/{chrom}.fa --region {start}:{stop}&#39; dna = subprocess.run(shlex.split(seqkit_command), stdout=subprocess.PIPE).stdout.decode(&#39;utf-8&#39;).split(&#39; n&#39;,1)[1].replace(&#39; n&#39;,&#39;&#39;) return dna . SPI1_promoter_dna_sequence = get_hg38_bases_local(chrom, start, stop) print(SPI1_promoter_dna_sequence) . TTCCAGGGAGGAAACCCTGACTTCCCACTGATAGCAAGCCAGGAGGGCAGTGGGTGGGCTGGCGGGTTCGTGGGCAGGCAGGCAGGCGTCCGAGGGCCACGGGTTGGGCTGGTGGAGGAGTCCCGGTACTCACAGGGGGGACGAGGGGAAACCCTTCCATTTTGCACGCCTGTAACATCCAGCCGGGCTCCGAGTCGGTCAGATCCCCTGCCTCGGTGGGGGCCAATGCAGAGCCCCTCAGGATGGGGTGCCCCGTCAGGGGCTGGACGGTCGTGGGGCGGGTGCAGGGCTCAGGCCTGCCCCCTGAGCTACAGGAGCCCTGGGTGAGCCCCCTCCCTTGACATTGCAGGGCCAGCACAAGTTCCTGATTTTATCGAAGGGCCTGCCGCTGGGAGATAGTCCCCTTGGGGTGACATCACCGCCCCAACCCGTTTGCATAAATCTCTTGCGCTACATACAGGAAGTCTCTGGCCGGCTGGGGCAGGTGGTGCTCAAAGGGCTGGCCTGGGAAGCCATGGGGTCCAGGCCCCCTGCCCAGAGGAAGCTGGGACTGAGAGGGATGACTTTGGGGGCTAAGCTGGGGAGGGAGGATGGGAGGGAGAACGTGTAGCTCTGCCACACCACTGGGAGGCTTTTGCTCTAACCCAACAAATGCCTGCTTCTTTTGAGATCCCTATGTAGCCAACAGTCACCTCATTGGGGTCAGAGCTGGAAGGGGTGGCCTCTTGGGGCCTCCACTTTCTGGAGTCAGCCTTCCTGGGTGAGGGCTCTGATCTAGCAGGCTATCAGGCCTGGCTCTTC . SPI1 promotes its own transcription, by binding to its own promoter. We can scan the SPI1 promoter for significant SPI1 PWM scores to locate the binding site. . base_index = {&#39;a&#39;:0,&#39;c&#39;:1,&#39;g&#39;:2,&#39;t&#39;:3,&#39;A&#39;:0,&#39;C&#39;:1,&#39;G&#39;:2,&#39;T&#39;:3} def scan_sequence(pwm, dna): scores = [] for i in range(len(dna)): score = 0 for j, row in enumerate(pwm): if i+j &lt; len(dna): score += row[base_index[dna[i+j]]] scores.append(score) return np.array(scores) . SPI1_PWM_scores = pd.DataFrame(SPI1_cisbp_score_pwms.apply(scan_sequence, args=(SPI1_promoter_dna_sequence,)).values.tolist(), index=SPI1_cisbp_score_pwms.index).T SPI1_PWM_scores.index += start positive_SPI1_PWM_scores = pd.DataFrame(np.where(SPI1_PWM_scores &gt; 0, SPI1_PWM_scores, np.nan), index=SPI1_PWM_scores.index, columns=SPI1_PWM_scores.columns) . def genomic_xticks(ax, chrom=None): xlims = ax.get_xlim() xtick_vals = ax.get_xticks() ax.set_xticks(xtick_vals) ax.set_xticklabels([&#39;{:.0f}&#39;.format(x) for x in xtick_vals]) ax.set_xlim(xlims) if chrom: ax.set_xlabel(chrom) ax = SPI1_PWM_scores.plot(lw=0.1, xlim=(SPI1_PWM_scores.index.min(),SPI1_PWM_scores.index.max()), legend=False) ax = positive_SPI1_PWM_scores.plot(style=&quot;.&quot;, ax=ax) ax.set_ylabel(&#39;score&#39;) genomic_xticks(ax) def plot_tss(ax, tss, strand, axvline=False): arrow_direction = 8 if strand == -1 else 9 ax.plot(tss, 1, lw=0, markersize=10, c=&#39;deepskyblue&#39;, marker=arrow_direction) ax.text(tss+1,0,gene_name) if axvline: ax.axvline(tss, c=&#39;deepskyblue&#39;, lw=0.5) plot_tss(ax, tss, strand) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-07-19T15:43:30.560584 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ Now we&#39;d like to score every PWM against every offset in the entire reference human genome. In order to accomplish that, we&#39;ll use MOODS, which implements a faster scanning algorithm in C++. We&#39;ll use this script to score the human reference genome with our PWMs. . PWMs: Score cutoffs . Once we have scanned a sequence of genomic DNA, scoring the PWM at every offset, we need to establish which of those scores is &quot;significant&quot; enough that we would predict the existence of a transcription factor binding site at that position in the genome. We can imagine two approaches to distinguish &quot;significant&quot; motif matches for each PWM. Thresholding on a particular score corresponds to predicting the TF is bound to sites which are $e^{ mathrm{score}}$ more likely under the PWM than random. A score cutoff of 6.91 is 1000x more likely under the PWM than random, for every PWM. . Contrarily, if you wanted to choose the 0.1% top scores for each PWM, each PWM would have a unique score cutoff, as each cutoff would depend on the distribution of scores specified by the PWM. At first this may seem surprising, so we&#39;ll explore it empirically for two PWMs: . pwm_names = [&#39;M07944_2.00&#39;,&#39;M03355_2.00&#39;] pwms = cisbp_pwms.loc[pwm_names] score_pwms = cisbp_score_pwms.loc[pwm_names] for name, pwm in pwms.items(): plot_pwm(pwm, figsize=(4,1)).set_title(name, loc=&#39;left&#39;) . def sample_scores_from_pwm(pwm, sample_size=int(1e6)): scores = np.zeros(sample_size) for i in range(len(pwm)): scores += np.random.choice(pwm[i], sample_size, p=bg) return pd.Series(scores) . score_samples = score_pwms.apply(sample_scores_from_pwm).T ax = score_samples.plot.hist(bins=100, alpha=0.5) ax.set(xlabel=&#39;score&#39;) fig_style_2(ax) . Clearly we can see these two PWMs define different score distributions for random sequences. Let&#39;s see what probabilities the highest scores correspond to for each of these PWMs, using MOODS&#39; score cutoff method: . def score_thresholds(score_pwm): min_significance, max_significance = -2, -15 significance_range = min_significance - max_significance pvals = np.logspace(min_significance, max_significance, significance_range*2+1) score_thresholds = [MOODS.tools.threshold_from_p(score_pwm.T.tolist(), bg, p) for p in pvals] return pd.Series(score_thresholds, index=pvals) . score_quantiles = score_pwms.apply(score_thresholds).T.rename_axis(&#39;p&#39;).reset_index() fig, ax = plt.subplots() cols = score_quantiles.columns[1:] for col in cols: score_quantiles.plot(x=col, y=&#39;p&#39;, logy=True, legend=False, ax=ax) ax.set(ylabel=&#39;p_value&#39;, xlabel=&#39;score&#39;) ax.grid(True, ls=&#39;:&#39;) for side in [&quot;right&quot;,&quot;top&quot;]: ax.spines[side].set_visible(False) ax.legend(cols) ax.axhline(1e-3, c=&#39;red&#39;) ax.text(0,2e-3, &#39;p=0.001&#39;) ax.plot(score_quantiles.iloc[2][[&#39;M07944_2.00&#39;,&#39;M03355_2.00&#39;]],(1e-3, 1e-3), marker=&#39;o&#39;, lw=0, c=&#39;red&#39;) None . For each motif, we can compute which score corresponds to each p-value cutoff, and then estimate p-values for scores of motif matches discovered during scanning using an interpolation. We&#39;ll use a generic spline as an interpolation function. . # cisbp_score_quantiles.to_csv(&#39;../data/equilibrium_TFs/cisbp_score_quantiles.csv&#39;, index=False) cisbp_score_quantiles = pd.read_csv(&#39;../notebook_data/equilibrium_TFs/cisbp_score_quantiles.csv&#39;) . def create_score_to_pval_interpolant(motif_name): quantiles = cisbp_score_quantiles[[motif_name, &#39;p&#39;]] quantiles = quantiles[quantiles[motif_name] &gt;= quantiles[motif_name].cummax()].drop_duplicates(subset=[motif_name], keep=&#39;first&#39;) # guarantee strict monotonic increasing score_to_pval_interpolation = interpolate.InterpolatedUnivariateSpline(quantiles[motif_name], quantiles[&#39;p&#39;], ext=3) return score_to_pval_interpolation . # create_score_to_pval_interpolant(motif_name) # tfbs.loc[tfbs.name == motif_name, &#39;p&#39;] = tfbs.loc[tfbs.name == motif_name, &#39;score&#39;].apply(score_to_pval_interpolation) . PWMs: Other formalisms . Unfortunately, the PWM formalism we have introduced misses the biophysical interpretation we have carried throughout our analysis thus far. We can coax a biophysical interpretation from these PWMs as follows (following the approach from Foat, Morozov, Bussemaker, 2006): . If we consider the nucleotides independently, then the ratio of equilibrium binding to a given nucleotide $j$ versus the highest-affinity nucleotide $ mathrm{best}$ at each position is related to the difference in energies of binding: . $$ frac{[TF:N_j]}{[TF:N_{best}]} = frac{K_{a_j}}{K_{a_{best}}} = exp { Delta G_j - Delta G_{best} } $$ . With this expression, we can compute the energy of binding of a TF to a sequence relative to that TF&#39;s energy of binding to its best sequence of nucleotides. However, we need to know an absolute energy of binding to anchor this relative measure. . # define make_energy_pwm() def make_energy_pwm(pwm): if str(pwm) == &#39;nan&#39;: return np.nan pwm = np.array(pwm)+1e-2 pwm = pwm/np.expand_dims(np.sum(pwm, axis=1), axis=1) energy_pwm = np.array([[kbT*ln(fraction/max(row)) for fraction in row] for row in pwm]) return energy_pwm . cisbp_energy_pwms = cisbp_pwms.apply(make_energy_pwm) humanTFs_energy_pwms = humanTFs_pwms.apply(make_energy_pwm) jaspar2022_energy_pwms = jaspar2022_pwms.apply(make_energy_pwm) . We can visualize this &quot;energy PWM&quot; as well. Visualizing energies of particular bases relative to SPI1&#39;s best sequence does not produce a visual representation that&#39;s easy to reason about: . SPI1_cisbp_energy_pwms = cisbp_energy_pwms.loc[SPI1_cisbp_pwms.index] SPI1_cisbp_energy_pwm = SPI1_cisbp_energy_pwms[0] ax = plot_pwm(SPI1_cisbp_energy_pwm) . We can rescale this matrix to the average sequence: . ax = plot_pwm(SPI1_cisbp_energy_pwm - np.expand_dims(SPI1_cisbp_energy_pwm.mean(axis=1), axis=1)) . However, the ideal rescaling of this PWM would indicate whether each nucleotide contributes positively or negatively towards the energy of binding. After all, SPI1 likely doesn&#39;t bind the &quot;average&quot; sequence -- which is to say it&#39;s off rate is higher than it&#39;s on rate. . We chose SPI1 / PU.1 as our prototype in part because its absolute binding energies to various sequences have been measured, allowing us to anchor our relative energies PWM model. Pham et al measured PU.1 binding to a variety of high-affinity sequences by microscale thermophoresis and recorded a $k_d$ of 156nm for the best one. . SPI1_best_nanomolar_kd = 156 SPI1_best_ΔG = kcal_ΔG_from_nanomolar_kd(SPI1_best_nanomolar_kd) SPI1_best_ΔG . 9.648885505793956 . However, the question remains of how to allocate those ~9.6 kcal/mol across the 14 bases of the SPI1 motif. The naive option is to uniformly spread the binding energy across the bases (9.6/14). Instead, we&#39;ll distribute it proportionally to the variance at each position to capture the intuition that the flanking nucleotides contribute less. . # define make_abs_pwm() def make_abs_pwm(pwm, ΔG_of_best_sequence): &#39;&#39;&#39;each base is allocated the absolute value of the variation at that position&#39;&#39;&#39; if str(pwm) == &#39;nan&#39;: return np.nan energy_range = abs(np.min(pwm, axis=1)) energy_fractional_allocation = energy_range/energy_range.sum() energy_per_base = ΔG_of_best_sequence * energy_fractional_allocation abs_pwm = pwm + np.expand_dims(energy_per_base, axis=1) return abs_pwm . SPI1_cisbp_energy_pwm_scaled = make_abs_pwm(SPI1_cisbp_energy_pwm, SPI1_best_ΔG) ax = plot_pwm(SPI1_cisbp_energy_pwm_scaled) . At last we have a visual representation of of a mono-nucleotide sequence preference model which captures our intuitions about the energetics of TF binding. . For a restricted set of TFs with high-quality HT-SELEX data, Rube et al produced relative energy PWMs with higher accuracy in the low-affinity regime. SPI1 is among that privileged set, so we&#39;ll take a look at that PWM for comparison. . SPI1_probound_pwms_scaled = SPI1_probound_pwms.apply(lambda pwm: make_abs_pwm(pwm, SPI1_best_ΔG)) ax = plot_pwm(SPI1_probound_pwms_scaled.iloc[2]) . PWMs: Evaluation . To what extent do these PWM models predict real transcription factor binding? In order to evaluate these models, we would like to compare their predictions with ground truth measurements of transcription factor occupancy. . TF occupancy can be estimated with ChIP. Has been estimated in K562 (and HepG2) | . Limitations: . We only have PWMs for 1000 TFs, | We only have ChIP for 600 TFs | . What&#39;s the intersection? . all_chip_able_targets = pd.read_csv(&#39;/Users/alex/Documents/AChroMap/data/raw/ENCODE/k562_chip/metadata.cleaned.tsv&#39;, sep=&#39; t&#39;).Target . pwm_cols = [&#39;CISBP_2_strict&#39;,&#39;CISBP_2_intermediate&#39;,&#39;CISBP_2_tolerant&#39;,&#39;HumanTFs&#39;,&#39;JASPAR_2022&#39;,&#39;ProBound&#39;] TF_coverage = {pwm_db: tfdb2[tfdb2.set_index(&#39;Name&#39;)[pwm_db].notnull().values].Name for pwm_db in pwm_cols} . fig, axs = plt.subplots(2, len(pwm_cols)//2) for pwm_db, ax in zip(pwm_cols, axs.flatten()): colors = [&#39;dodgerblue&#39;, &#39;seagreen&#39;, &#39;lightsteelblue&#39;] venn_obj = venn3((set(TF_coverage[pwm_db]), set(all_chip_able_targets), set(tfdb2.Name)), (f&#39;{pwm_db} ({len(set(TF_coverage[pwm_db]))})&#39;, f&#39;ChIP in K562 ({len(set(all_chip_able_targets))})&#39;, f&#39;DNA-binding TF ({len(set(tfdb2.Name))})&#39;), colors, alpha=0.6, ax=ax) for text in venn_obj.set_labels: text.set_fontsize(8) for text in [x for x in venn_obj.subset_labels if x]: text.set_fontsize(6) venn_obj.set_labels[0].set_fontweight(700) venn_obj.get_patch_by_id(&#39;111&#39;).set_edgecolor(&#39;green&#39;) . TFs_to_evaluate = set(all_chip_able_targets) &amp; set(TF_coverage[&#39;CISBP_2_strict&#39;]) . pd.Series(list(TFs_to_evaluate)).to_csv(&#39;../notebook_data/TFs_to_evaluate.csv&#39;, index=False, header=False) . In ATAC OCRs . Justify only looking inside ATAC peaks / OCRs. | . explain motivation: want to look in all ATAC regions for PWMs and chip signal in k562s . narrowpeak_cols = [&#39;chrom&#39;,&#39;chromStart&#39;,&#39;chromEnd&#39;,&#39;name&#39;,&#39;score&#39;,&#39;strand&#39;,&#39;signalValue&#39;,&#39;pValue&#39;,&#39;qValue&#39;,&#39;summit&#39;] ATAC_peaks_files = [&#39;/Users/alex/Documents/AChroMap/data/raw/ENCODE/k562_atac/downloads/ENCFF333TAT.bed&#39;, &#39;/Users/alex/Documents/AChroMap/data/raw/ENCODE/k562_atac/downloads/ENCFF558BLC.bed&#39;] ATAC_signal_files = [&#39;/Users/alex/Documents/AChroMap/data/raw/ENCODE/k562_atac/downloads/ENCFF357GNC.bigWig&#39;, &#39;/Users/alex/Documents/AChroMap/data/raw/ENCODE/k562_atac/downloads/ENCFF600FDO.bigWig&#39;] . def filter_overlapping_peaks_for_max_signalValue(filepath, fraction_either=0.8): narrowpeaks_unfiltered = pd.read_csv(f&#39;{filepath}&#39;, sep=&#39; t&#39;, na_values=[&#39;NAN&#39;], header=None, names=narrowpeak_cols) bedops_command = f&quot;bedops -u {filepath} | cut -f1-4,7 | bedmap --fraction-either {fraction_either} --max-element - | sort-bed --unique - &gt; {filepath}.tmp&quot; os.system(bedops_command) narrowPeaks_filtered_peak_names = pd.read_csv(f&#39;{filepath}.tmp&#39;, sep=&#39; t&#39;, na_values=[&#39;NAN&#39;], header=None, names=narrowpeak_cols[:5]).name os.remove(f&#39;{filepath}.tmp&#39;) return narrowpeaks_unfiltered[narrowpeaks_unfiltered.name.isin(narrowPeaks_filtered_peak_names)] . K562_ATAC_peaks_1_filtered = filter_overlapping_peaks_for_max_signalValue(ATAC_peaks_files[0]) K562_ATAC_peaks_2_filtered = filter_overlapping_peaks_for_max_signalValue(ATAC_peaks_files[1]) K562_ATAC_peaks_1_filtered[&#39;signalValue_percentile&#39;] = K562_ATAC_peaks_1_filtered.signalValue.rank(pct=True) K562_ATAC_peaks_2_filtered[&#39;signalValue_percentile&#39;] = K562_ATAC_peaks_2_filtered.signalValue.rank(pct=True) . def get_overlapping_peaks(peaks_bed, chrom, start, stop): intervals = pd.IntervalIndex.from_arrays(peaks_bed.chromStart, peaks_bed.chromEnd) return peaks_bed[(peaks_bed.chrom == chrom) &amp; intervals.overlaps(pd.Interval(start, stop))] . atac_peak_at_SPI1_promoter_1 = get_overlapping_peaks(K562_ATAC_peaks_1_filtered, chrom, start, stop) atac_peak_at_SPI1_promoter_2 = get_overlapping_peaks(K562_ATAC_peaks_2_filtered, chrom, start, stop) . # plot Open Chromatin Regions overlapping SPI1 promoter from two separate K562 bulk ATAC-seq experiments. earliest_start = min(start, atac_peak_at_SPI1_promoter_1.chromStart.iat[0], atac_peak_at_SPI1_promoter_2.chromStart.iat[0]) latest_end = max(stop, atac_peak_at_SPI1_promoter_1.chromEnd.iat[0], atac_peak_at_SPI1_promoter_2.chromEnd.iat[0]) plot_dna_length = (latest_end - earliest_start)*1.1 offset = earliest_start - plot_dna_length*0.05 features = [ GraphicFeature(start=start, end=stop, color=&quot;#ffd700&quot;, label=&quot;±400bp &#39;promoter&#39; around tss&quot;), GraphicFeature(start=tss-30, end=tss, strand=-1, color=&quot;#ffcccc&quot;, label=&quot;tss&quot;), GraphicFeature(start=atac_peak_at_SPI1_promoter_1.chromStart.iat[0], end=atac_peak_at_SPI1_promoter_1.chromEnd.iat[0], color=&quot;#cffccc&quot;, label=&quot;peak called in ATAC dataset 1&quot;), GraphicFeature(start=atac_peak_at_SPI1_promoter_2.chromStart.iat[0], end=atac_peak_at_SPI1_promoter_2.chromEnd.iat[0], color=&quot;#ccccff&quot;, label=&quot;peak called in ATAC dataset 2&quot;) ] record = GraphicRecord(features=features, sequence_length=latest_end*1.2) cropped_record = record.crop((offset, offset+plot_dna_length)) ax, rest = cropped_record.plot(figure_width=10) plt.setp(ax.get_xticklabels(), fontsize=7) None . def get_bigwig_values(url, chrom, start, stop): with pyBigWig.open(url) as bw: values = bw.values(chrom, start, stop) return values . ATAC_bigwig_1 = get_bigwig_values(ATAC_signal_files[0], chrom, earliest_start, latest_end) ATAC_bigwig_2 = get_bigwig_values(ATAC_signal_files[1], chrom, earliest_start, latest_end) . ATAC_bigwig = pd.DataFrame([ATAC_bigwig_1, ATAC_bigwig_2], columns=range(earliest_start, latest_end), index=[&#39;ATAC_1&#39;, &#39;ATAC_2&#39;]).T . ax = ATAC_bigwig.plot.line() plot_tss(ax, tss, strand) genomic_xticks(ax) . from this we conclude that the first set of ATAC peaks is a richer dataset, and proceed with those . ATAC_OCRs_to_evaluate_PWMs_in = K562_ATAC_peaks_1_filtered[K562_ATAC_peaks_1_filtered.score == 1000] . ATAC_OCRs_to_evaluate_PWMs_in.to_csv(&#39;../notebook_data/equilibrium_TFs/K562_ATAC_peaks_filtered.bed&#39;, sep=&#39; t&#39;, index=False) . Get DGF . motif_cluster_and_gene = pd.read_csv(&#39;/Users/alex/Documents/AChroMap/data/raw/Vierstra_supp/motif_cluster_and_gene.csv&#39;, index_col=0) motif_clusters_to_TFs = pd.read_csv(&#39;/Users/alex/Documents/AChroMap/data/raw/Vierstra_supp/motif_clusters_to_TFs.csv&#39;, index_col=0) motif_clusters_to_TFs = motif_clusters_to_TFs.set_index(&#39;Name&#39;)[&#39;gene&#39;].str.split(&#39;;&#39;) DGF_footprint_index = pd.read_csv(&#39;/Users/alex/Documents/AChroMap/data/raw/Vierstra_supp/consensus_index_matrix_full_hg38.index.csv&#39;, index_col=0, header=None).index DGF_samples_index = pd.read_csv(&#39;/Users/alex/Documents/AChroMap/data/raw/Vierstra_supp/consensus_index_matrix_full_hg38.columns.csv&#39;, index_col=0, header=None).index K562_DGF_samples = DGF_samples_index[DGF_samples_index.str.startswith(&#39;K562&#39;)].tolist() . def get_k562_DGF(chrom, start, end): dgf_path = &#39;/Users/alex/Documents/AChroMap/data/raw/Vierstra_supp/consensus_footprints_and_collapsed_motifs_hg38.bed.gz&#39; tabix_coords = chrom+&#39;:&#39;+str(start)+&#39;-&#39;+str(end) cols = [&#39;contig&#39;,&#39;start&#39;,&#39;stop&#39;,&#39;identifier&#39;,&#39;mean_signal&#39;,&#39;num_samples&#39;,&#39;num_fps&#39;,&#39;width&#39;,&#39;summit_pos&#39;,&#39;core_start&#39;,&#39;core_end&#39;,&#39;motif_clusters&#39;] tabix_command = f&#39;tabix {dgf_path} {tabix_coords}&#39; footprints_contained_in_region = read_shell(shlex.split(tabix_command), sep=&#39; t&#39;, header=None, names=cols, dtype={&#39;index_id&#39;: str}) footprints_contained_in_region[&#39;TFs&#39;] = footprints_contained_in_region.motif_clusters.str.split(&#39;;&#39;).apply(lambda l: [motif_clusters_to_TFs[motif_cluster] for motif_cluster in l] if (type(l) == list) else []) first_dgf_index = DGF_footprint_index.get_loc(footprints_contained_in_region.identifier.iloc[0]) last_dgf_index = DGF_footprint_index.get_loc(footprints_contained_in_region.identifier.iloc[-1])+1 footprint_posterior = pd.read_hdf(&#39;/Users/alex/Documents/AChroMap/data/raw/Vierstra_supp/consensus_index_matrix_full_hg38.hdf&#39;, key=&#39;consensus_index_matrix_full_hg38&#39;, start=first_dgf_index, stop=last_dgf_index, columns=K562_DGF_samples) footprint_binary = pd.read_hdf(&#39;/Users/alex/Documents/AChroMap/data/raw/Vierstra_supp/consensus_index_matrix_binary_hg38.hdf&#39;, key=&#39;consensus_index_matrix_full_hg38&#39;, start=first_dgf_index, stop=last_dgf_index, columns=K562_DGF_samples) k562_dgf = footprints_contained_in_region.merge(footprint_posterior, how=&#39;left&#39;, left_on=&#39;identifier&#39;, right_index=True) k562_dgf = k562_dgf.merge(footprint_binary, how=&#39;left&#39;, left_on=&#39;identifier&#39;, right_index=True, suffixes=[&#39;_posterior&#39;,&#39;_binary&#39;]) return k562_dgf . k562_dgf = get_k562_DGF(chrom, start, stop) . k562_dgf.plot.scatter(x=&#39;K562-DS15363_posterior&#39;, y=&#39;K562-DS16924_posterior&#39;, figsize=(4,4), logx=True, logy=True) . &lt;AxesSubplot:xlabel=&#39;K562-DS15363_posterior&#39;, ylabel=&#39;K562-DS16924_posterior&#39;&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-07-19T14:24:49.694426 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ Load K562 RNA . ENCODE_RNA_metadata = pd.read_csv(&#39;../../AChroMap/data/raw/ENCODE/rna/metadata.tsv&#39;, sep=&#39; t&#39;) ENCODE_RNA_metadata_cleaned = pd.read_csv(&#39;../../AChroMap/data/raw/ENCODE/rna/metadata.clean.typed.csv&#39;) ENCODE_polyA_metadata = pd.read_csv(&#39;../../AChroMap/data/raw/ENCODE/polyA/metadata.tsv&#39;, sep=&#39; t&#39;) ENCODE_polyA_metadata_cleaned = pd.read_csv(&#39;../../AChroMap/data/raw/ENCODE/polyA/metadata.clean.typed.csv&#39;) rna_counts = pd.read_csv(&#39;../../AChroMap/data/raw/ENCODE/rna/RSEM_gene/RSEM_gene.counts_matrix.wellexpressed_deseq.csv&#39;, index_col=0) polyA_counts = pd.read_csv(&#39;../../AChroMap/data/raw/ENCODE/polyA/RSEM_gene/RSEM_gene.counts_matrix.wellexpressed_deseq.csv&#39;, index_col=0) K562_reference_polyA = pd.read_csv(&#39;/Users/alex/Desktop/ENCFF472HFI.tsv&#39;, sep=&#39; t&#39;) K562_reference_polyA = K562_reference_polyA[K562_reference_polyA.gene_id.str.startswith(&#39;ENSG&#39;)] K562_reference_polyA[&#39;gene_id&#39;] = K562_reference_polyA.gene_id.str.split(&#39;.&#39;).str[0] K562_reference_polyA = K562_reference_polyA.set_index(&#39;gene_id&#39;) K562_RNA_metadata = ENCODE_RNA_metadata[ENCODE_RNA_metadata[&#39;Biosample term name&#39;] == &#39;K562&#39;] K562_RNA_metadata_cleaned = ENCODE_RNA_metadata_cleaned[ENCODE_RNA_metadata_cleaned[&#39;Biosample term name&#39;] == &#39;K562&#39;] K562_polyA_metadata = ENCODE_polyA_metadata[ENCODE_polyA_metadata[&#39;Biosample term name&#39;] == &#39;K562&#39;] K562_polyA_metadata_cleaned = ENCODE_polyA_metadata_cleaned[ENCODE_polyA_metadata_cleaned[&#39;Biosample term name&#39;] == &#39;K562&#39;] K562_RNA_metadata_cleaned = K562_RNA_metadata_cleaned[K562_RNA_metadata_cleaned.type == &#39;RSEM_gene&#39;] K562_polyA_metadata_cleaned = K562_polyA_metadata_cleaned[K562_polyA_metadata_cleaned.type == &#39;RSEM_gene&#39;] K562_RNA_metadata = K562_RNA_metadata[K562_RNA_metadata[&#39;File accession&#39;].isin(K562_RNA_metadata_cleaned.file)] K562_polyA_metadata = K562_polyA_metadata[K562_polyA_metadata[&#39;File accession&#39;].isin(K562_polyA_metadata_cleaned.file)] K562_RNA_metadata = K562_RNA_metadata[K562_RNA_metadata[&#39;Audit WARNING&#39;].isnull() &amp; K562_RNA_metadata[&#39;Audit ERROR&#39;].isnull() &amp; K562_RNA_metadata[&#39;Audit NOT_COMPLIANT&#39;].isnull()] K562_polyA_metadata = K562_polyA_metadata[K562_polyA_metadata[&#39;Audit WARNING&#39;].isnull() &amp; K562_polyA_metadata[&#39;Audit ERROR&#39;].isnull() &amp; K562_polyA_metadata[&#39;Audit NOT_COMPLIANT&#39;].isnull()] K562_RNA_metadata_cleaned = K562_RNA_metadata_cleaned[K562_RNA_metadata_cleaned.file.isin(K562_RNA_metadata[&#39;File accession&#39;])] K562_polyA_metadata_cleaned = K562_polyA_metadata_cleaned[K562_polyA_metadata_cleaned.file.isin(K562_polyA_metadata[&#39;File accession&#39;])] K562_rna_counts = rna_counts.loc[rna_counts.index.str.startswith(&#39;ENSG&#39;), rna_counts.columns.isin(K562_RNA_metadata[&#39;File accession&#39;])] K562_polyA_counts = polyA_counts.loc[polyA_counts.index.str.startswith(&#39;ENSG&#39;), polyA_counts.columns.isin(K562_polyA_metadata[&#39;File accession&#39;])] K562_rna_counts.index = K562_rna_counts.index.str.split(&#39;.&#39;).str[0] K562_polyA_counts.index = K562_polyA_counts.index.str.split(&#39;.&#39;).str[0] . best_polyA_files = K562_polyA_metadata_cleaned[K562_polyA_metadata_cleaned.experiment.isin([&#39;ENCSR000AEP&#39;,&#39;ENCSR000AEQ&#39;])].file.tolist() best_rna_files = K562_RNA_metadata_cleaned[K562_RNA_metadata_cleaned.experiment.isin([&#39;ENCSR792OIJ&#39;])].file.tolist() def series_to_distplot(s): sns.kdeplot(data=s) sns.rugplot(data=s, height=.1) rna_counts_sum = K562_rna_counts.sum() series_to_distplot(rna_counts_sum) ax = plt.gca() for x in rna_counts_sum[best_rna_files].values: ax.axvline(x, c=&#39;r&#39;, lw=0.3) plt.subplots() polyA_counts_sum = K562_polyA_counts.sum() series_to_distplot(polyA_counts_sum) ax = plt.gca() for x in polyA_counts_sum[best_polyA_files].values: ax.axvline(x, c=&#39;r&#39;, lw=0.3) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-07-20T11:59:09.721224 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-07-20T11:59:09.792664 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ mRNAs_per_cell = 1e5 # citation follows RNAs_per_cell = 4e5 # this one is a guess K562_polyA_TPC = K562_polyA_counts / K562_polyA_counts.sum() * mRNAs_per_cell K562_rna_TPC = K562_rna_counts / K562_rna_counts.sum() * RNAs_per_cell . (Marinov... Wold, 2014) . K562_RNA_TF_TPC = K562_rna_TPC[K562_rna_TPC.index.isin(tfdb2.ID)] K562_polyA_TF_TPC = K562_polyA_TPC[K562_polyA_TPC.index.isin(tfdb2.ID)] . K562_polyA_TF_TPC.index = tfdb2.set_index(&#39;ID&#39;).reindex(K562_polyA_TF_TPC.index).Name.values . plt.rcParams[&#39;figure.figsize&#39;] = [17, 5] g = sns.stripplot(data=K562_polyA_TF_TPC.iloc[:100].T, alpha=0.4) plt.xticks(rotation=-90) g = sns.stripplot(data=K562_polyA_TF_TPC.iloc[:100][best_polyA_files].T, color=&#39;black&#39;, s=2, marker=&quot;D&quot;) # also plot the median None . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-07-20T12:38:35.153413 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ . K562_polyA_TF_TPC.to_csv(&#39;../notebook_data/equilibrium_TFs/K562_TF_RNA.csv&#39;) . RNA_to_protein_linear_scaling_factor = 9800 K562_TF_copy_number = K562_polyA_TF_TPC.replace(0, np.nan).median(axis=1).replace(np.nan, 0) * RNA_to_protein_linear_scaling_factor . (Li,... Biggin, 2014) . plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] K562_TF_copy_number.plot.hist(bins=100, logy=True) . &lt;AxesSubplot:ylabel=&#39;Frequency&#39;&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-07-20T13:50:09.911002 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ K562_TF_nanomolar_conc = K562_TF_copy_number.apply(copy_number_and_cubic_micron_volume_to_molar_concentration, args=(K562_volume_micron_cubed,)) * 1e9 . K562_TF_RNA_concise = pd.concat((tfdb2.set_index(&#39;Name&#39;).ID.reindex(K562_TF_copy_number.index), K562_TF_copy_number.rename(&#39;TF_protein_copy_number_estimate&#39;), K562_TF_nanomolar_conc.rename(&#39;nanomolar_conc&#39;)), axis=1) K562_TF_RNA_concise = K562_TF_RNA_concise.rename_axis(&#39;Name&#39;).reset_index().set_index(&#39;ID&#39;) K562_TF_RNA_concise = K562_TF_RNA_concise.sort_values(&#39;TF_protein_copy_number_estimate&#39;, ascending=False).drop_duplicates(subset=[&#39;Name&#39;]) K562_TF_RNA_concise.to_csv(&#39;../notebook_data/equilibrium_TFs/K562_TF_RNA_concise.csv&#39;) . Evaluation of PWMs at the SPI1 promoter . We&#39;ve just generated a list of OCRs we want to evaluate PWMs for, but let&#39;s start with our single example to determine how to evaluate PWMs vs ChIP. . # chrom, strand, tss = get_reference_transcript(gene_name) # start = tss-400 # stop = tss+400 # K562_TF_RNA = pd.read_csv(&#39;../notebook_data/equilibrium_TFs/K562_TF_RNA.csv&#39;, index_col=0) . Get TF ChIP Peaks at SPI1 Promoter . def get_K562_TF_ChIP_peaks(chrom, start, end): k562_merged_ChIP_path = &#39;/Users/alex/Documents/AChroMap/data/raw/ENCODE/k562_chip/K562_ChIP_merged.bed.gz&#39; tabix_coords = chrom+&#39;:&#39;+str(start)+&#39;-&#39;+str(end) tabix_command = f&#39;tabix {k562_merged_ChIP_path} {tabix_coords}&#39; peaks_contained_in_region = read_shell(shlex.split(tabix_command), sep=&#39; t&#39;, header=None, names=[&#39;chrom&#39;,&#39;chromStart&#39;,&#39;chromEnd&#39;,&#39;name&#39;,&#39;signalValue&#39;]) return peaks_contained_in_region . K562_SPI1_TF_chip_peaks = get_K562_TF_ChIP_peaks(chrom, start, stop) peaks_df = K562_SPI1_TF_chip_peaks[K562_SPI1_TF_chip_peaks.name.isin(TFs_to_evaluate)] . Get TF ChIP signal over background at SPI1 promoter . SPI1_promoter_TF_ChIP_signal = pd.read_csv(&#39;../notebook_data/equilibrium_TFs/SPI1_promoter_TF_ChIP_signal.csv&#39;, index_col=0) SPI1_promoter_TF_ChIP_signal = SPI1_promoter_TF_ChIP_signal.clip(lower=1).replace(1, np.nan) signal_df = SPI1_promoter_TF_ChIP_signal.loc[:, SPI1_promoter_TF_ChIP_signal.columns.str.split(&#39;_&#39;).str[0].isin(TFs_to_evaluate)] signal_df = signal_df[signal_df.max(axis=0).sort_values(ascending=False).index.values] . Get ATAC signal over background at SPI1 promoter . SPI1_promoter_TF_ATAC_signal = pd.Series(get_bigwig_values(ATAC_signal_files[0], chrom, start, stop), index=range(start, stop), name=&#39;ATAC_signal&#39;) SPI1_promoter_TF_ATAC_signal = SPI1_promoter_TF_ATAC_signal.clip(lower=1).replace(1, np.nan) . Get PWM predictions at SPI1 promoter . SPI1_key = f&#39;{chrom}/{atac_peak_at_SPI1_promoter_1.chromStart.iat[0]}-{atac_peak_at_SPI1_promoter_1.chromEnd.iat[0]}&#39; SPI1_cisbp_tfbs = pd.read_hdf(&#39;../../AChroMap/scripts/cisbp2_vs_chip.hdf&#39;, SPI1_key) SPI1_cisbp_tfbs = SPI1_cisbp_tfbs[(SPI1_cisbp_tfbs.start &gt; start) &amp; (SPI1_cisbp_tfbs.end &lt; stop)] SPI1_cisbp_tfbs[&#39;p&#39;] = SPI1_cisbp_tfbs.p.clip(lower=1e-10) SPI1_cisbp_tfbs[&#39;log10p&#39;] = -np.log10(SPI1_cisbp_tfbs.p) . 3D Ridgeline . signal_df = SPI1_promoter_TF_ChIP_signal.loc[:, SPI1_promoter_TF_ChIP_signal.columns.str.split(&#39;_&#39;).str[0].isin(TFs_to_evaluate)] TF_order = signal_df.max(axis=0).sort_values().index.str.split(&#39;_&#39;).str[0].drop_duplicates(keep=&#39;first&#39;) column_order = pd.Series({col: (TF_order.get_loc(col.split(&#39;_&#39;)[0]), int(col.split(&#39;_&#39;)[1])) for col in signal_df.columns}).sort_values().index signal_df = signal_df[column_order] . signal_df_20 = signal_df.iloc[:, -20:] . columns_to_TF = signal_df_20.columns.to_frame()[0].str.split(&#39;_&#39;).str[0].rename(&#39;TF&#39;).rename_axis(&#39;track&#39;).reset_index().reset_index().set_index(&#39;track&#39;) TF_to_columns = columns_to_TF.reset_index().set_index(&#39;TF&#39;) plotted_TFs = set(TF_to_columns.index) . genome_linspace = np.transpose(np.tile(signal_df_20.index.values, (len(signal_df_20.T), 1))) print(&#39;genome_linspace:&#39;, genome_linspace.shape) signal_heights = signal_df_20.values print(&#39;signal_heights: t&#39;, signal_heights.shape) TF_y_index = np.linspace(0,len(signal_df_20.columns)-1,len(signal_df_20.columns)) print(&#39;TF_y_index: t&#39;, TF_y_index.shape) . genome_linspace: (800, 20) signal_heights: (800, 20) TF_y_index: (20,) . signal_verts = [] for y_i in range(len(TF_y_index)): # zero at the beginning and the end to get a nice flat bottom on the polygons xs = np.concatenate([[genome_linspace[0,y_i]], genome_linspace[:,y_i], [genome_linspace[-1,y_i]]]) ys = np.concatenate([[0],signal_heights[:,y_i],[0]]) signal_verts.append(list(zip(xs, ys))) . colors = LinearSegmentedColormap(&#39;colormap&#39;, cm.jet._segmentdata.copy(), 20) colors = [colors(i) for i in range(20)] . peak_verts = [] peak_offsets = [] for col, d in columns_to_TF.iterrows(): for i, peak in peaks_df[peaks_df[&#39;name&#39;] == d.TF].iterrows(): xs = [peak.chromStart, peak.chromStart, peak.chromEnd, peak.chromEnd] ys = [0, peak.signalValue/20, peak.signalValue/20, 0] peak_verts.append(list(zip(xs, ys))) peak_offsets.append(d[&#39;index&#39;]) . tfbs_verts = [] tfbs_offsets = [] for col, d in columns_to_TF.iterrows(): for i, tfbs in SPI1_cisbp_tfbs[SPI1_cisbp_tfbs[&#39;TFs&#39;] == d.TF].iterrows(): xs = [tfbs.start, tfbs.start, tfbs.end, tfbs.end] ys = [0, tfbs.score/50, tfbs.score/50, 0] tfbs_verts.append(list(zip(xs, ys))) tfbs_offsets.append(d[&#39;index&#39;]) . plt.rcParams[&#39;figure.figsize&#39;] = [10, len(signal_df.columns)] fig = plt.figure() ax = fig.add_subplot(111, projection=&#39;3d&#39;) signal_poly = PolyCollection(signal_verts, facecolors=colors) signal_poly.set_alpha(0.7) ax.add_collection3d(signal_poly, zs=TF_y_index, zdir=&#39;y&#39;) peak_poly = PolyCollection(peak_verts, edgecolors=(0,0,0,0.3), facecolors=(0,0,0,0)) # peak_poly.set_alpha(0.4) ax.add_collection3d(peak_poly, zs=peak_offsets, zdir=&#39;y&#39;) tfbs_poly = PolyCollection(tfbs_verts) tfbs_poly.set_alpha(1) ax.add_collection3d(tfbs_poly, zs=tfbs_offsets, zdir=&#39;y&#39;) ax.set_xlim3d(genome_linspace.min(), genome_linspace.max()) ax.set_xlabel(chrom) ax.set_ylim3d(TF_y_index.min(), TF_y_index.max()) ax.set_ylabel(&#39;TF&#39;) ax.set_zlim3d(signal_heights.min(), signal_heights.max()) ax.set_zlabel(&#39;signal fold change over background&#39;) xtick_vals = ax.get_xticks() ax.set_xticks(xtick_vals) ax.set_xticklabels([&#39;{:.0f}&#39;.format(x) for x in xtick_vals]) ax.set_yticks(TF_y_index) ax.set_yticklabels(signal_df.columns) ax.xaxis.pane.fill = False ax.yaxis.pane.fill = False ax.zaxis.pane.fill = False ax.xaxis.pane.set_edgecolor(&#39;w&#39;) ax.yaxis.pane.set_edgecolor(&#39;w&#39;) ax.zaxis.pane.set_edgecolor(&#39;w&#39;) ax.grid(False) ax.get_proj = lambda: np.dot(Axes3D.get_proj(ax), np.diag([1.0, 1.5, 1.0, 1.0])) plt.show() . ValueError Traceback (most recent call last) Input In [156], in &lt;cell line: 23&gt;() 21 ax.set_ylim3d(TF_y_index.min(), TF_y_index.max()) 22 ax.set_ylabel(&#39;TF&#39;) &gt; 23 ax.set_zlim3d(signal_heights.min(), signal_heights.max()) 24 ax.set_zlabel(&#39;signal fold change over background&#39;) 26 xtick_vals = ax.get_xticks() File ~/miniconda3/envs/py39/lib/python3.9/site-packages/mpl_toolkits/mplot3d/axes3d.py:865, in Axes3D.set_zlim3d(self, bottom, top, emit, auto, zmin, zmax) 862 top = zmax 864 self._process_unit_info([(&#34;z&#34;, (bottom, top))], convert=False) --&gt; 865 bottom = self._validate_converted_limits(bottom, self.convert_zunits) 866 top = self._validate_converted_limits(top, self.convert_zunits) 868 old_bottom, old_top = self.get_zlim() File ~/miniconda3/envs/py39/lib/python3.9/site-packages/matplotlib/axes/_base.py:3614, in _AxesBase._validate_converted_limits(self, limit, convert) 3611 converted_limit = convert(limit) 3612 if (isinstance(converted_limit, Real) 3613 and not np.isfinite(converted_limit)): -&gt; 3614 raise ValueError(&#34;Axis limits cannot be NaN or Inf&#34;) 3615 return converted_limit ValueError: Axis limits cannot be NaN or Inf . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-07-13T10:58:49.045547 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ 2D Ridgeline . import matplotlib.style as mplstyle mplstyle.use(&#39;fast&#39;) def style_ax(ax): ax.spines[&#39;top&#39;].set_visible(False) ax.spines[&#39;right&#39;].set_visible(False) ax.spines[&#39;bottom&#39;].set_visible(False) ax.patch.set_alpha(0) . from matplotlib.ticker import Locator class MinorSymLogLocator(Locator): &quot;&quot;&quot; Dynamically find minor tick positions based on the positions of major ticks for a symlog scaling. &quot;&quot;&quot; def __init__(self, linthresh): &quot;&quot;&quot; Ticks will be placed between the major ticks. The placement is linear for x between -linthresh and linthresh, otherwise its logarithmically &quot;&quot;&quot; self.linthresh = linthresh def __call__(self): &#39;Return the locations of the ticks&#39; majorlocs = self.axis.get_majorticklocs() # iterate through minor locs minorlocs = [] # handle the lowest part for i in range(1, len(majorlocs)): majorstep = majorlocs[i] - majorlocs[i-1] if abs(majorlocs[i-1] + majorstep/2) &lt; self.linthresh: ndivs = 10 else: ndivs = 9 minorstep = majorstep / ndivs locs = np.arange(majorlocs[i-1], majorlocs[i], minorstep)[1:] minorlocs.extend(locs) return self.raise_if_exceeds(np.array(minorlocs)) def tick_values(self, vmin, vmax): raise NotImplementedError(&#39;Cannot get tick locations for a &#39; &#39;%s type.&#39; % type(self)) . def style_stripplot(ax): ax.set_xscale(&#39;symlog&#39;, linthresh=2) ax.get_xaxis().set_major_formatter(matplotlib.ticker.ScalarFormatter()) # ax.xaxis.grid(True, which=&#39;minor&#39;) ax.set_xlim([0, 200]) ax.set_xticks([0, 1, 10, 100, 200]) ax.xaxis.set_minor_locator(MinorSymLogLocator(1e-1)) . signal_df2 = signal_df[signal_df.max(axis=0).sort_values(ascending=False).index.values].iloc[:, :10] . K562_polyA_TF_TPC_medians = K562_polyA_TF_TPC.replace(0, np.nan).median(axis=1).fillna(0) . # I want a nucleosome binding energy track on this figure . # chip peaks could be triangles or some other shape -- especially if we had the summit # are the summits always in the middle? # show the motif on the screen somewhere? # fully featured genomics feature track? . # plot the problem statement . # maybe I should be plotting the TF&#39;s p-values rather than scores? coloring by correlation or something? # TFBS: 2 colors: below threshold and above threshold . plot_chip_peaks = True plot_chip_signal = True plot_atac_signal = True plot_tfbs = True plot_dgf = True num_rows = 1+len(signal_df2.columns) plt.rcParams[&#39;figure.figsize&#39;] = [18, num_rows] plt.rcParams[&#39;path.simplify_threshold&#39;] = 1.0 TF_names = signal_df2.columns.str.split(&#39;_&#39;).str[0].unique() fig, axs = plt.subplots(len(TF_names), 2, sharex=&#39;col&#39;, gridspec_kw={&#39;width_ratios&#39;: [3, 1]}) left_axs = [row[0] for row in axs] row_dict = dict(zip(TF_names, axs[:-1])) if plot_atac_signal: SPI1_promoter_TF_ATAC_signal.plot.line(ax=left_axs[-1], ylim=(0, SPI1_promoter_TF_ATAC_signal.max()), xlim=(start, stop), c=&#39;black&#39;, label=&#39;ATAC&#39;) left_axs[-1].set_ylabel(&#39;ATAC&#39;, rotation=0) plot_tss(left_axs[-1], tss, strand, axvline=True) style_ax(left_axs[-1]) for i, (TF_name, row) in enumerate(row_dict.items()): row[0].set_xlim([start, stop]) row[0].set_ylim([0, 30]) style_ax(row[0]) color = &#39;darkblue&#39; if i%2 == 0 else &#39;royalblue&#39; for uid in signal_df2.loc[:, signal_df2.columns.str.split(&#39;_&#39;).str[0] == TF_name].columns: line = row[0].plot(signal_df2.index.values, signal_df2[uid].values, label=uid, clip_on=False, color=color, lw=1) # ax.legend(handles=line, loc=&#39;upper left&#39;, borderaxespad=0, frameon=False) g1 = sns.stripplot(data=K562_polyA_TF_TPC.loc[TF_name].to_frame(), x=TF_name, orient=&#39;h&#39;, alpha=0.5, c=&#39;lightblue&#39;, ax=row[1]) g2 = sns.stripplot(data=K562_polyA_TF_TPC.loc[TF_name, best_polyA_files].to_frame(), x=TF_name, orient=&#39;h&#39;, color=&#39;red&#39;, ax=row[1]) g3 = sns.stripplot(data=K562_polyA_TF_TPC_medians.to_frame().loc[[TF_name]].T, x=TF_name, orient=&#39;h&#39;, color=&#39;black&#39;, marker=&#39;D&#39;, ax=row[1]) style_ax(row[1]) row[1].set_xlim(0, K562_polyA_TF_TPC.max().max()) row[1].set_ylabel(TF_name, rotation=0) # row[1].set_xscale(&#39;symlog&#39;, linthresh=1) # row[1].plot(K562_polyA_TF_TPC_medians.at[TF_name], TF_name, &#39;ko&#39;) if i == 0: row[1].spines[&#39;top&#39;].set_visible(True) style_stripplot(row[1]) if plot_chip_peaks: for index, peak in peaks_df.iterrows(): if peak[&#39;name&#39;] in row_dict.keys(): ax = row_dict[peak[&#39;name&#39;]][0] ax.add_patch(Rectangle((peak.chromStart, 0), peak.chromEnd-peak.chromStart, 30, fc=(1,0,0,np.clip(0.0005*peak.signalValue, a_min=0, a_max=1)), ec=(1,0,0,0.1), zorder=-1, clip_on=False)) if plot_tfbs: tfbs_cm = matplotlib.cm.ScalarMappable(norm=matplotlib.colors.Normalize(vmin=0, vmax=20), cmap=matplotlib.cm.OrRd) for index, tfbs in SPI1_cisbp_tfbs.iterrows(): if tfbs[&#39;TFs&#39;] in row_dict.keys(): ax = row_dict[tfbs[&#39;TFs&#39;]][0] ax.add_patch(Rectangle((tfbs.start, 0), tfbs.end-tfbs.start, (tfbs.log10p-2)*4, fc=tfbs_cm.to_rgba(tfbs.log10p), ec=(0,0,0,0), zorder=10, clip_on=False)) # fc=(0,1,0,np.clip(0.01*tfbs.log10p, a_min=0, a_max=1)), if plot_dgf: last_ax = left_axs[-1] for index, dgf in k562_dgf.iterrows(): alpha = 0.005*(dgf[&#39;K562-DS15363_posterior&#39;] + dgf[&#39;K562-DS16924_posterior&#39;])/2 _,top = fig.transFigure.inverted().transform(left_axs[0].transAxes.transform([0,1])) _,bottom = fig.transFigure.inverted().transform(left_axs[-1].transAxes.transform([0,0])) trans = matplotlib.transforms.blended_transform_factory(left_axs[0].transData, fig.transFigure) fig.add_artist(Rectangle((dgf.core_start,bottom), dgf.core_end-dgf.core_start, top-bottom, transform=trans, fc=(0,0,1,alpha), ec=None, zorder=-10)) genomic_xticks(left_axs[-1], chrom=chrom) axs[-1][1].axis(&#39;off&#39;) axs[0][1].xaxis.set_tick_params(labeltop=True) plt.savefig(&#39;/Users/alex/Desktop/SPI1_promoter_K562_TF_ChIP.png&#39;) None . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-07-20T15:14:24.932483 image/svg+xml Matplotlib v3.5.2, https://matplotlib.org/ Scatterplots . max_chip_peak_height = peaks_df.groupby(&#39;name&#39;)[&#39;signalValue&#39;].max().rename(&#39;max_chip_peak_height&#39;) max_chip_peak_height . name ATF1 278.59146 ATF2 671.55342 ATF3 2017.85285 ATF4 61.95164 ATF7 1206.30707 ... ZKSCAN1 28.54167 ZNF175 50.23833 ZNF281 112.63834 ZNF282 31.21194 ZNF766 56.29987 Name: max_chip_peak_height, Length: 87, dtype: float64 . def set_colors(df, x_col, y_col): df[&#39;c&#39;] = np.nan df.loc[(df[y_col] &gt; 0) &amp; (df[x_col] &gt; 0), &#39;c&#39;] = &#39;g&#39; df.loc[(df[y_col] &gt; 0) &amp; (df[x_col] &lt;= 0), &#39;c&#39;] = &#39;m&#39; df.loc[(df[y_col] &lt;= 0) &amp; (df[x_col] &gt; 0), &#39;c&#39;] = &#39;r&#39; df.loc[(df[y_col] &lt;= 0) &amp; (df[x_col] &lt;= 0), &#39;c&#39;] = &#39;c&#39; return df . K562_TF_RNA = pd.read_csv(&#39;../../back_of_my_envelope/data/equilibrium_TFs/K562_TF_RNA.csv&#39;, index_col=0) K562_TF_RNA = K562_TF_RNA.replace(0, np.nan).median(axis=1).replace(np.nan, 0).rename(&#39;TF_RNA&#39;) K562_TF_RNA . TFAP2A 0.082112 TFAP2B 0.019229 TFAP2C 0.024566 TFAP2D 0.000000 TFAP2E 0.029581 ... MTERF1 8.131813 MTERF2 12.372807 TP53 2.256278 TP63 0.674158 TP73 0.592430 Name: TF_RNA, Length: 1635, dtype: float64 . def process_peak_tfbs_df(tfbs_df): tfbs_df = tfbs_df[tfbs_df.TFs.isin(TFs_to_evaluate)] tfbs_df.p.clip(lower=1e-10, upper=None, inplace=True) tfbs_df[&#39;log10p&#39;] = -np.log10(tfbs_df.p) tfbs_df = tfbs_df.merge(max_chip_peak_height, how=&#39;left&#39;, left_on=&#39;TFs&#39;, right_index=True) tfbs_df = tfbs_df.merge(K562_TF_RNA, how=&#39;left&#39;, left_on=&#39;TFs&#39;, right_index=True) tfbs_df[&#39;score_x_RNA&#39;] = ln(exp(tfbs_df[&#39;score&#39;]) * tfbs_df[&#39;TF_RNA&#39;]) tfbs_df[&#39;log10p_x_RNA&#39;] = tfbs_df[&#39;log10p&#39;] * tfbs_df[&#39;TF_RNA&#39;] return tfbs_df.reset_index(drop=True) # distance to peak center # dgf . tfbs_df = process_peak_tfbs_df(SPI1_cisbp_tfbs) . def lims(series, buffer=0.01): spread = series.max() - series.min() limits = (series.min() - spread*buffer, series.max() + spread*buffer) return limits def log_lims(series, log_buffer=1): lower = np.log10(series[series &gt; 0].min()) - log_buffer upper = np.log10(series[series &gt; 0].max()) + log_buffer return (lower, upper) . def spearman_corr(df, tfbs_col, chip_col): return df.loc[:, [tfbs_col, chip_col]].corr(method=&#39;spearman&#39;).loc[tfbs_col, chip_col] spearman_corr(tfbs_df, &#39;score&#39;, &#39;max_signal&#39;), spearman_corr(tfbs_df, &#39;score_x_RNA&#39;, &#39;max_signal&#39;) . (0.07881793222722186, 0.06831818983387146) . def plot_peak_scatter(df, mode=&#39;hist&#39;, x_col=&#39;score&#39;, y_col=&#39;max_signal&#39;, log=False, legend=False, ylim=(-0.1, 20)): palette={&#39;g&#39;:&#39;g&#39;,&#39;m&#39;:&#39;m&#39;,&#39;r&#39;:&#39;r&#39;,&#39;c&#39;:&#39;c&#39;} df = set_colors(df, x_col, y_col) df[&#39;chip_signalBinary&#39;] = (df[y_col] &gt; 0).astype(int) df[&#39;pwm_scoreBinary&#39;] = (df[x_col] &gt; 0).astype(int) g = sns.JointGrid(data=df, x=x_col, y=y_col, xlim=lims(df[x_col]), ylim=ylim, hue=&#39;c&#39;, palette=palette) g.plot_joint(sns.scatterplot, alpha=0.2, s=5, legend=legend) if mode == &#39;hist&#39;: sns.histplot(data=df, x=x_col, bins=100, ax=g.ax_marg_x, hue=&#39;chip_signalBinary&#39;, palette={0:&#39;r&#39;, 1:&#39;g&#39;}, legend=False, log_scale=(False, True),element=&quot;step&quot;) if log: sns.histplot(data=df, y=y_col, bins=[0, 1]+np.logspace(1, 5).tolist(), ax=g.ax_marg_y, hue=&#39;pwm_scoreBinary&#39;, palette={0:&#39;m&#39;, 1:&#39;g&#39;}, legend=False, log_scale=(True, False),element=&quot;step&quot;) else: sns.histplot(data=df, y=y_col, bins=200, ax=g.ax_marg_y, hue=&#39;pwm_scoreBinary&#39;, palette={0:&#39;m&#39;, 1:&#39;g&#39;}, legend=False, log_scale=(True, False),element=&quot;step&quot;) g.ax_marg_y.tick_params(labeltop=True) g.ax_marg_y.grid(True, axis=&#39;x&#39;, ls=&#39;:&#39;) g.ax_marg_x.tick_params(labelleft=True) g.ax_marg_x.grid(True, axis=&#39;y&#39;, ls=&#39;:&#39;) elif mode==&#39;kde&#39;: sns.kdeplot(data=df, x=x_col, ax=g.ax_marg_x, hue=&#39;chip_signalBinary&#39;, palette={0:&#39;r&#39;, 1:&#39;g&#39;}, fill=True, alpha=0.1, legend=False) sns.kdeplot(data=df, y=y_col, ax=g.ax_marg_y, hue=&#39;pwm_scoreBinary&#39;, palette={0:&#39;m&#39;, 1:&#39;g&#39;}, fill=True, alpha=0.1, legend=False, log_scale=(False, True)) g.fig.set_figwidth(10) g.fig.set_figheight(5) corr = spearman_corr(df, x_col, y_col) g.fig.suptitle(f&#39;Spearman_correlation: {round(corr, 4)}&#39;) if legend: handles, labels = g.ax_joint.get_legend_handles_labels() replacement = {&#39;g&#39;:&#39;Motif match and ChIP peak&#39;, &#39;m&#39;:&#39;ChIP peak without motif match&#39;, &#39;r&#39;:&#39;Motif match without ChIP peak&#39;, &#39;c&#39;:&#39;Neither motif match nor ChIP Peak&#39;} labels = [replacement[x] for x in labels] legend = g.ax_joint.legend(handles, labels, loc=&#39;upper left&#39;) if log: g.ax_joint.set_yscale(&#39;symlog&#39;, linthresh=min(0.1, df[df.max_signal &gt; 0].max_signal.min())) return g, corr . g = plot_peak_scatter(tfbs_df, x_col=&#39;score&#39;, y_col=&#39;max_signal&#39;) . g = plot_peak_scatter(tfbs_df, x_col=&#39;score&#39;, y_col=&#39;max_chip_peak_height&#39;, log=True, ylim=(10, 1e3)) . g = plot_peak_scatter(tfbs_df, x_col=&#39;score_x_RNA&#39;, y_col=&#39;max_signal&#39;) . g = plot_peak_scatter(tfbs_df, x_col=&#39;score_x_RNA&#39;, y_col=&#39;max_chip_peak_height&#39;, log=True, ylim=(10, 1e3)) . Metrics . . tfbs_df . chrom start end name score strand TFs k562_chip_signal_files max_signal p log10p max_chip_peak_height TF_RNA score_x_RNA log10p_x_RNA c chip_signalBinary pwm_scoreBinary . 0 chr11 | 47378177 | 47378186 | M10306_2.00 | 5.672115 | - | IKZF1 | ENCFF957MXZ | 2.06838 | 0.000502 | 3.299445 | NaN | 36.913654 | 9.280697 | 121.794567 | g | 1 | 1 | . 1 chr11 | 47378177 | 47378186 | M10306_2.00 | 5.672115 | - | IKZF1 | ENCFF053QLR | 1.06389 | 0.000502 | 3.299445 | NaN | 36.913654 | 9.280697 | 121.794567 | g | 1 | 1 | . 2 chr11 | 47378177 | 47378191 | M04801_2.00 | 7.176316 | + | ETV5 | ENCFF042WYK | 1.48301 | 0.000069 | 4.161535 | 39.50612 | 9.482606 | 9.425776 | 39.462201 | g | 1 | 1 | . 3 chr11 | 47378177 | 47378191 | M09030_2.00 | 4.500186 | + | E2F1 | ENCFF387AXO | 0.68479 | 0.000608 | 3.216315 | 125.52399 | 8.737605 | 6.667822 | 28.102885 | g | 1 | 1 | . 4 chr11 | 47378177 | 47378191 | M09030_2.00 | 4.500186 | + | E2F1 | ENCFF513XPM | 0.91216 | 0.000608 | 3.216315 | 125.52399 | 8.737605 | 6.667822 | 28.102885 | g | 1 | 1 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 12235 chr11 | 47378961 | 47378972 | M04401_2.00 | 3.655551 | - | KLF6 | ENCFF955XUI | 2.61929 | 0.000232 | 3.635227 | NaN | 5.719905 | 5.399503 | 20.793153 | g | 1 | 1 | . 12236 chr11 | 47378961 | 47378973 | M08281_2.00 | 0.209253 | - | ZNF586 | ENCFF977XAH | 1.42771 | 0.000318 | 3.497270 | NaN | 5.334281 | 1.883407 | 18.655423 | g | 1 | 1 | . 12237 chr11 | 47378962 | 47378975 | M09377_2.00 | 5.301170 | - | SMAD4 | ENCFF836SJA | 3.05519 | 0.000461 | 3.336172 | 119.26441 | 19.787000 | 8.286195 | 66.012841 | g | 1 | 1 | . 12238 chr11 | 47378965 | 47378974 | M03476_2.00 | 6.107840 | + | NFIX | ENCFF431LIE | 2.00159 | 0.000549 | 3.260517 | NaN | 3.746789 | 7.428739 | 12.216468 | g | 1 | 1 | . 12239 chr11 | 47378965 | 47378974 | M03477_2.00 | 5.603724 | + | NFIX | ENCFF431LIE | 2.00159 | 0.000844 | 3.073869 | NaN | 3.746789 | 6.924623 | 11.517139 | g | 1 | 1 | . 12240 rows × 18 columns . def plot_distribs(no, yes, xlabel): fig, (ax0, ax1) = plt.subplots(1, 2) ax0 = no.plot.kde(ax=ax0, xlim=(yes.min(), yes.max()), legend=True) yes.plot.kde(ax=ax0, legend=True) ax0.set_xlabel(xlabel) no_x = no.sort_values() no_cdf = no_x.rank(method=&#39;average&#39;, pct=True) yes_x = yes.sort_values() yes_cdf = yes_x.rank(method=&#39;average&#39;, pct=True) ax1.plot([0]+no_x.tolist(), [0]+no_cdf.tolist(), label=no.name) ax1.plot([0]+yes_x.tolist(), [0]+yes_cdf.tolist(), label=yes.name) ax1.legend() ax1.set_ylim(0, 1) ax1.set_ylabel(&#39;CDF&#39;) ax1.set_xlabel(xlabel) return ax0, ax1 . no = df[df.max_tfbs_score == 0].max_chip.rename(&#39;No TFBS&#39;) yes = df[df.max_tfbs_score &gt; 0].max_chip.rename(&#39;TFBS&#39;) ax0, ax1 = plot_distribs(no, yes, &#39;ChIP signal&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T10:29:47.874059 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ no = df[df.max_chip == 0].max_tfbs_score.rename(&#39;No ChIP&#39;) yes = df[df.max_chip &gt; 0].max_tfbs_score.rename(&#39;ChIP&#39;) ax0, ax1 = plot_distribs(no, yes, &#39;TFBS signal&#39;) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T10:29:48.132447 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ def PPV_TPR_FPR(df, thresh_index, tfbs=&#39;max_tfbs_score&#39;, chip=&#39;max_chip&#39;): df.sort_values(tfbs, inplace=True) negative_prediction = df.iloc[:thresh_index] positive_prediction = df.iloc[thresh_index:] true_negative = sum(negative_prediction[chip] == 0) false_negative = sum(negative_prediction[chip] &gt; 0) false_positive = sum(positive_prediction[chip] == 0) true_positive = sum(positive_prediction[chip] &gt; 0) positive_predictive_value = (true_positive / (true_positive + false_positive)) if (true_positive + false_positive) &gt; 0 else 1 # also called precision true_positive_rate = (true_positive / (true_positive + false_negative)) if (true_positive + false_negative) &gt; 0 else 1 # also called recall false_positive_rate = (false_positive / (false_positive + true_negative)) if (false_positive + true_negative) &gt; 0 else 1 return positive_predictive_value, true_positive_rate, false_positive_rate def rolling_PPV_TPR_FPR(df, tfbs=&#39;max_tfbs_score&#39;, chip=&#39;max_chip&#39;): df.sort_values(tfbs, inplace=True) indices_of_thresholds = np.where(~df[tfbs].duplicated())[0] df = pd.DataFrame([PPV_TPR_FPR(df, thresh_index, tfbs=tfbs, chip=chip) for thresh_index in indices_of_thresholds], columns=[&#39;positive_predictive_value&#39;, &#39;true_positive_rate&#39;, &#39;false_positive_rate&#39;])[::-1] df[&#39;f1&#39;] = 2 * (df.positive_predictive_value * df.true_positive_rate) / (df.positive_predictive_value + df.true_positive_rate) return df def AUROC(stats): auroc = np.trapz(stats.true_positive_rate, stats.false_positive_rate) return auroc def plot_AUROC(stats): auroc = AUROC(stats) ax = stats.plot.line(y=&#39;true_positive_rate&#39;, x=&#39;false_positive_rate&#39;, legend=False, title=f&#39;AUROC: {round(auroc, 3)}&#39;, xlim=(0, 1), ylim=(0, 1)) ax.plot((0,1),(0,1), c=&#39;r&#39;, linestyle=&#39;dotted&#39;) ax.set_aspect(&#39;equal&#39;, adjustable=&#39;box&#39;) ax.set_ylabel(&#39;true_positive_rate&#39;) return ax, auroc . ax, auroc = plot_AUROC(rolling_PPV_TPR_FPR(df)) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T10:29:48.329299 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ Generate reports for each peak . plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] peak_index = 9 df = K562_ATAC_2_tfbs_and_chip[peak_index] . def atac_peak_distrib_plot(peak_index, peaks_df=K562_ATAC_peaks_2_filtered): this_peak = peaks_df.loc[peak_index] g = sns.JointGrid(data=peaks_df, x=&#39;signalValue&#39;, y=&#39;score&#39;, xlim=(0,45), ylim=(0, 1050)) g.plot_joint(sns.histplot) g.plot_marginals(sns.kdeplot) g.fig.suptitle(f&#39;Peak signal percentile rank: {round(this_peak.signalValue_percentile*100, 2)}%&#39;) g.fig.set_figwidth(10) g.fig.set_figheight(5) g.ax_joint.plot(this_peak.signalValue, this_peak.score, markersize=12, c=&#39;red&#39;, marker=&quot;+&quot;, label=f&#39;{peak_index}: &#39;+this_peak[&#39;name&#39;]) g.ax_joint.plot(this_peak.signalValue, this_peak.score, markersize=10, c=&#39;red&#39;, marker=&quot;.&quot;) g.ax_marg_x.axvline(this_peak.signalValue, c=&#39;red&#39;) g.ax_marg_y.axhline(this_peak.score, c=&#39;red&#39;) g.ax_joint.legend(loc=&#39;lower right&#39;) return g . atac_peak_distrib_plot(peak_index) . &lt;seaborn.axisgrid.JointGrid at 0x1b4ffe350&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T10:30:04.337129 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ def hypergeom_pval(df, universe=ChIPable_CISBPable_TFs, tfbs=&#39;pwm_score&#39;, chip=&#39;chip_signalValue&#39;): TFs_with_chip_signal = set(df[df[chip] &gt; 0].index) TFs_with_tfbs = set(df[df[tfbs] &gt; 0].index) # the total number of marbles in the jar M = len(ChIPable_CISBPable_TFs) # the number of red marbles in the jar n = len(TFs_with_chip_signal) # the number of draws from the jar N = len(TFs_with_tfbs) # the number of red marbles drawn x = len(TFs_with_chip_signal &amp; TFs_with_tfbs) pval = hypergeom.sf(x-1, M, n, N) return pval def pwm_chip_overlap_venn(df): fig, ax = plt.subplots() TFs_with_chip_signal = set(df[df.chip_signalValue &gt; 0].index) TFs_with_tfbs = set(df[df.pwm_score &gt; 0].index) pval = hypergeom_pval(df) venn3((set(ChIPable_CISBPable_TFs), TFs_with_tfbs, TFs_with_chip_signal), (f&#39;All TFs we have PWMs and ChIP data for ({len(ChIPable_JASPARable_TFs)})&#39;, f&#39;Has non-zero PWM score at locus ({len(TFs_with_tfbs)})&#39;, f&#39;Has non-zero ChIP signal at locus ({len(TFs_with_chip_signal)})&#39;)) fig.suptitle(f&#39;Hypergeometric -log10(pval): {round(-np.log10(pval),2)}&#39;) return fig, pval . ax, pval = pwm_chip_overlap_venn(df) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T13:43:34.812882 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ TFs_with_SPI1_promoter_chip_signal = set(tfbs_df[tfbs_df.max_chip_peak_height.notnull()].TFs) TFs_with_SPI1_promoter_tfbs = set(tfbs_df.TFs) plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] venn_obj = venn3((TFs_with_SPI1_promoter_tfbs, set(TFs_to_evaluate), TFs_with_SPI1_promoter_chip_signal), (f&#39;Has non-zero PWM score at locus ({len(TFs_with_SPI1_promoter_tfbs)})&#39;, f&#39;All TFs we have PWMs and ChIP data for ({len(TFs_to_evaluate)})&#39;, f&#39;Has a ChIP peak at locus ({len(TFs_with_SPI1_promoter_chip_signal)})&#39;)) for text in venn_obj.set_labels: text.set_fontsize(8) for text in [x for x in venn_obj.subset_labels if x]: text.set_fontsize(6) . stats = rolling_PPV_TPR_FPR(df, tfbs=&#39;pwm_score&#39;, chip=&#39;chip_signalValue&#39;).iloc[1:] . def plot_PR(stats): stats = stats.rename(columns={&#39;positive_predictive_value&#39;:&#39;precision&#39;, &#39;true_positive_rate&#39;: &#39;recall&#39;}) ax = stats.plot.line(y=&#39;precision&#39;, x=&#39;recall&#39;, legend=False, xlim=(0, 1), ylim=(0, 1)) ax.set_aspect(&#39;equal&#39;, adjustable=&#39;box&#39;) ax.set_ylabel(&#39;precision&#39;) ax.set_xlabel(&#39;recall&#39;) f_scores = np.linspace(0.2, 0.8, num=4) lines, labels = [], [] for f_score in f_scores: x = np.linspace(0.01, 1) y = f_score * x / (2 * x - f_score) (l,) = plt.plot(x[y &gt;= 0], y[y &gt;= 0], color=&quot;gray&quot;, alpha=0.2) plt.annotate(&quot;f1={0:0.1f}&quot;.format(f_score), xy=(0.9, y[45] + 0.02)) top_f1 = stats.f1.max() ax.set_title(f&#39;Best F1 score: {round(top_f1, 2)}&#39;) return ax, top_f1 . ax, top_f1 = plot_PR(stats) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T13:43:36.101047 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ def peak_summary(peak_index): peak_df = clean_peak_df(K562_ATAC_2_tfbs_and_chip[peak_index]) g1 = atac_peak_distrib_plot(peak_index) g2 = plot_peak_scatter(peak_df) ax, hypergeom_pval = pwm_chip_overlap_venn(peak_df) stats = rolling_PPV_TPR_FPR(peak_df, tfbs=&#39;pwm_score&#39;, chip=&#39;chip_signalValue&#39;).iloc[1:] ax, top_f1 = plot_PR(stats) ax, auroc = plot_AUROC(stats) return peak_df . peak_df = peak_summary(9) . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T13:43:37.426045 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T13:43:38.020791 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T13:43:38.148149 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T13:43:38.217033 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-04-07T13:43:38.290944 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ def detailed_peak_summary(): pass . . Evaluating across all ATAC peaks . # by peak # by motif # by tf . def evaluate_predictor(df, x_col_name, y_col_name): num_nonzero_predictions num_nonzero_ground_truth corr = spearman_corr(df[x_col_name], df[y_col_name]) stats = rolling_PPV_TPR_FPR(peak_df, tfbs=x_col_name, chip=y_col_name).iloc[1:] top_f1 = stats.f1.max() auroc = AUROC(stats) return (atac_signalValue_percentile, num_TFs_overall, num_chip_peaks, num_tfbs_hits, num_phantom_tfs, corr_without_rna, corr_with_rna, pval, top_f1, auroc) . . def peak_stats(peak_index): atac_signalValue_percentile = K562_ATAC_peaks_2_filtered.loc[peak_index].at[&#39;signalValue_percentile&#39;] peak_df = clean_peak_df(K562_ATAC_2_tfbs_and_chip[peak_index]) num_TFs_overall = len(peak_df) num_chip_peaks = peak_df.chip_signalBinary.sum() num_tfbs_hits = peak_df.pwm_scoreBinary.sum() num_phantom_tfs = len(peak_df[(peak_df.TF_conc == 0) &amp; (peak_df.chip_signalValue &gt; 0)]) corr_without_rna = spearman_corr(peak_df, &#39;pwm_score&#39;, &#39;chip_signalValue&#39;) corr_with_rna = spearman_corr(peak_df, &#39;pwm_score_x_TF_conc&#39;, &#39;chip_signalValue&#39;) pval = hypergeom_pval(peak_df) stats = rolling_PPV_TPR_FPR(peak_df, tfbs=&#39;pwm_score&#39;, chip=&#39;chip_signalValue&#39;).iloc[1:] top_f1 = stats.f1.max() auroc = AUROC(stats) return (atac_signalValue_percentile, num_TFs_overall, num_chip_peaks, num_tfbs_hits, num_phantom_tfs, corr_without_rna, corr_with_rna, pval, top_f1, auroc) . # &#39;num_TFs_overall&#39;, # &#39;num_chip_peaks&#39;, # &#39;num_tfbs_hits&#39;, # &#39;num_phantom_tfs&#39;, # &#39;corr_without_rna&#39;, # &#39;corr_with_rna&#39;, # &#39;pval&#39;, # &#39;top_f1&#39;, # &#39;auroc&#39;) # metrics_df = {i: peak_stats(i) for i in K562_ATAC_2_tfbs_and_chip.keys()} # metrics_df = pd.DataFrame(metrics_df, index=cols).T # metrics_df.to_csv(&#39;../data/equilibrium_TFs/K562_ATAC_PWM_vs_ChIP_baseline_metrics.csv&#39;) metrics_df = pd.read_csv(&#39;../data/equilibrium_TFs/K562_ATAC_PWM_vs_ChIP_baseline_metrics.csv&#39;, index_col=0) . metrics_df = pd.concat((K562_ATAC_peaks_2_filtered.signalValue, metrics_df), axis=1).rename(columns={&#39;signalValue&#39;:&#39;atac_signalValue&#39;}) . set_matplotlib_formats(&#39;png&#39;) metrics_df.plot.scatter(x=&#39;atac_signalValue&#39;, y=&#39;num_chip_peaks&#39;, alpha=0.3, s=0.1) . &lt;AxesSubplot:xlabel=&#39;atac_signalValue&#39;, ylabel=&#39;num_chip_peaks&#39;&gt; . Per TF, Motif . # engine = create_engine(&#39;sqlite:////Users/alex/Documents/back_of_my_envelope/data/sqlite.db&#39;, echo=False) # with engine.begin() as connection: # for key, df in cisbp2_vs_chip: # df[&#39;key&#39;] = key # df.to_sql(&#39;cisbp2_vs_chip&#39;, connection, if_exists=&quot;append&quot;, index=False) . intervals_df = pd.read_csv(&#39;/Users/alex/Documents/AChroMap/scripts/K562_ATAC_peaks_1.csv&#39;, header=None) . def _key(chrom, start, stop): return f&#39;/{chrom}/{start}-{stop}&#39; . K562_TF_RNA = pd.read_csv(&#39;../../back_of_my_envelope/data/equilibrium_TFs/K562_TF_RNA.csv&#39;, index_col=0) K562_TF_RNA = K562_TF_RNA.replace(0, np.nan).median(axis=1).replace(np.nan, 0).rename(&#39;TF_RNA&#39;) K562_TF_RNA . TFAP2A 0.082112 TFAP2B 0.019229 TFAP2C 0.024566 TFAP2D 0.000000 TFAP2E 0.029581 ... MTERF1 8.131813 MTERF2 12.372807 TP53 2.256278 TP63 0.674158 TP73 0.592430 Name: TF_RNA, Length: 1635, dtype: float64 . def get_K562_TF_ChIP_peaks(chrom, start, end): k562_merged_ChIP_path = &#39;/Users/alex/Documents/AChroMap/data/raw/ENCODE/k562_chip/K562_ChIP_merged.bed.gz&#39; tabix_coords = chrom+&#39;:&#39;+str(start)+&#39;-&#39;+str(end) tabix_command = f&#39;tabix {k562_merged_ChIP_path} {tabix_coords}&#39; peaks_contained_in_region = read_shell(shlex.split(tabix_command), sep=&#39; t&#39;, header=None, names=[&#39;chrom&#39;,&#39;chromStart&#39;,&#39;chromEnd&#39;,&#39;name&#39;,&#39;signalValue&#39;]) return peaks_contained_in_region . def process_peak_tfbs_df(tfbs_df): tfbs_df = tfbs_df[tfbs_df.TFs.isin(TFs_to_evaluate)] tfbs_df.p.clip(lower=1e-10, upper=None, inplace=True) tfbs_df[&#39;log10p&#39;] = -np.log10(tfbs_df.p) # tfbs_df = tfbs_df.merge(max_chip_peak_height, how=&#39;left&#39;, left_on=&#39;TFs&#39;, right_index=True) tfbs_df = tfbs_df.merge(K562_TF_RNA, how=&#39;left&#39;, left_on=&#39;TFs&#39;, right_index=True) tfbs_df[&#39;score_x_RNA&#39;] = ln(exp(tfbs_df[&#39;score&#39;]) * tfbs_df[&#39;TF_RNA&#39;]) tfbs_df[&#39;log10p_x_RNA&#39;] = tfbs_df[&#39;log10p&#39;] * tfbs_df[&#39;TF_RNA&#39;] return tfbs_df.reset_index(drop=True) # distance to peak center # dgf . def spearman_corr(df, x_col, y_col): return df.loc[:, [x_col, y_col]].corr(method=&#39;spearman&#39;)[x_col].get(y_col, np.nan) . len(TFs_to_evaluate) . 225 . with open(&#39;/Users/alex/Desktop/corrs.pickle&#39;, &#39;rb&#39;) as pickle_f: corrs = pickle.load(pickle_f) . overlaps_promoters = pd.read_csv(&#39;/Users/alex/Desktop/test1.txt&#39;, header=None) . overlaps_promoters.value_counts() . 0 67053 dtype: int64 . Probably no longer relevant: . # define draw_config() for plotting def draw_config(TFBSs, TF_conc, cooperativities, config=None, len_DNA=1000): if config is None: config = [0]*len(TFBSs) TF_colors = dict(zip(list(TF_conc.keys()), list(TABLEAU_COLORS.values()))) plt.rcParams[&#39;figure.figsize&#39;] = [12, 0.5+np.sqrt(len(TFs))] fig, axs = plt.subplots(ncols=2, sharey=True, gridspec_kw={&#39;width_ratios&#39;: [4, 1]}) genome_track_ax = draw_genome_track(axs[0], config, TFBSs, cooperativities, TF_colors, len_DNA=len_DNA) conc_plot_ax = draw_concentration_plot(axs[1], TF_conc, TF_colors) return genome_track_ax, conc_plot_ax def draw_concentration_plot(conc_plot_ax, TF_conc, TF_colors): conc_plot_ax.barh(range(len(TF_conc.keys())), TF_conc.values(), align=&#39;edge&#39;, color=list(TF_colors.values()), alpha=0.9) for p in conc_plot_ax.patches: conc_plot_ax.annotate(str(p.get_width())+&#39;nm&#39;, (p.get_width() + 10*(p.get_width()&gt;0), p.get_y() * 1.02), fontsize=&#39;x-small&#39;) conc_plot_ax.axes.get_yaxis().set_visible(False) conc_plot_ax.axes.get_xaxis().set_visible(False) conc_plot_ax.set_frame_on(False) return conc_plot_ax def draw_genome_track(genome_track_ax, config, TFBSs, cooperativities, TF_colors, len_DNA=1000): genome_track_ax.set(ylabel=&#39;TFs&#39;, ylim=[-1, len(TF_colors.keys())+1], yticks=range(len(TFs)), yticklabels=TFs, xlabel=&#39;Genome&#39;, xlim=[0, len_DNA]) for i, tfbs in TFBSs.iterrows(): tfbs_scale = np.clip(0.01*np.exp(tfbs.dG-7), 0, 1) genome_track_ax.add_patch(Rectangle((tfbs.start, TFs.index(tfbs.TF)), len_TFBS, 0.8, fc=TF_colors[tfbs.TF], alpha=tfbs_scale)) genome_track_ax.add_patch(Rectangle((tfbs.start, TFs.index(tfbs.TF)), len_TFBS, 0.1*tfbs_scale, fc=TF_colors[tfbs.TF], alpha=1)) genome_track_ax.annotate(str(int(tfbs.dG))+&#39;kcal/Mol&#39;, (tfbs.start, TFs.index(tfbs.TF)-0.3), fontsize=&#39;xx-small&#39;) genome_track_ax.add_patch(Polygon([[tfbs.start+2, TFs.index(tfbs.TF)], [tfbs.start+5,TFs.index(tfbs.TF)+0.8],[tfbs.start+8, TFs.index(tfbs.TF)]], fc=TF_colors[tfbs.TF], alpha=config[i])) cm = matplotlib.cm.ScalarMappable(norm=matplotlib.colors.Normalize(vmin=-3, vmax=3), cmap=matplotlib.cm.PiYG) for i, rest in cooperativities.items(): for j, C_AB in rest.items(): tfbs_i = TFBSs.iloc[i] tfbs_j = TFBSs.iloc[j] xa = tfbs_i.start+(len_TFBS/2) xb = tfbs_j.start+(len_TFBS/2) ya = TFs.index(tfbs_i.TF) yb = TFs.index(tfbs_j.TF) genome_track_ax.plot([xa, (xa+xb)/2, xb], [ya+0.9, max(ya, yb)+1.2, yb+0.9], color=cm.to_rgba(C_AB)) genome_track_ax.grid(axis=&#39;y&#39;, lw=0.1) genome_track_ax.set_frame_on(False) return genome_track_ax . Let&#39;s now proceed to a slightly more complex regulatory region, with 20 binding sites for 10 TFs . # draw our model regulatory region: TFs, TF_conc, TFBSs, cooperativities = create_environment(len_DNA=200, num_TFs=10, num_TFBS=20) ax = draw_config(TFBSs, TF_conc, cooperativities, len_DNA=200) plt.tight_layout() . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-02-04T11:37:39.954187 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ Notice first that when binding sites overlap slightly, we&#39;ve introduced a free energy penalty of competition, denoted by a pink line between the binding sites, and when they stronly overlap, we&#39;ve disallowed those configurations, denoted by a red line. . We notice a problem with evaluating our $p_ mathrm{config}$ expression with realistic regulatory DNA: the number of configurations grows exponentially in the number of transcription factor binding sites ($2^{| mathrm{TFBS}|}$). Only 20 Transcription Factor Binding sites entails ~1 million configurations, and so ~1 million terms in the denominator $Z$. Computing probabilities of configurations exactly then becomes intractable for realistic scenarios: we need to proceed by sampling. . Thankfully there&#39;s a dynamic programming approach to computing Z. . config = np.round(np.random.rand(len(TFBSs))).astype(int) . Which we can plot, and compute the associated log-statistical-weight: . axs = draw_config(config) plt.tight_layout() print(&#39;log(p_config) =&#39;, log_P_config(config)) . log(p_config) = -1.4748275325663975 . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-02-03T18:15:21.883707 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ References . Calculating transcription factor binding maps for chromatin | . Multiple TFs: Nucleosome-mediated Cooperativity . nucleosomes as a soft AND gate . Direct cooperativity (driven by protein-protein interactions) between transcription factors exerts significant control over transcription when it occurs, but it appears to be the exception, not the rule. More common is indirect cooperativity mediated by nucleosomes. Nucleosomes can be thought of as repressive transcription factors with large footprints and relatively non-specific sequence-dependent binding affinities. When multiple transcription factors bind independently in the footprint of a nucleosome, they do so cooperatively, despite not making physical contact with one another. . Including nucleosomes in our description of chromatin produces a new set of interactions, which require energy parameters. Those are: . Nucleosome:DNA interactions | Nucleosome:TF interactions | Nucleosome:Nucleosome interactions | . Nucleosome:DNA . Nucleosomes have at least a 5000-fold range of affinities for differing DNA sequences. . What controls nucleosome positions? Nucleosomes do not bind specific 147-bp sequences, but they do have preferences for certain periodic patterns, and disfavor certain other patterns. Nucleosomes are canonically wrapped by 147bp of DNA, but due to nucleosome crowding and nucleosome beathing, they are often wrapped by fewer bases. . For our model, we will say that any stretch of DNA [of lengths 100-147bp] can be wrapped by a nucleosome, with an energy which is derived from the [sequence model here]. . def nucleosome_energy_from_sequence(sequence): &#39;&#39;&#39; tells you the binding energy &#39;&#39;&#39; pass . . Nucleosome:TF . Nucleosomes and Transcription Factors were considered to sterically block one another from binding the same stretch of DNA, however, we now know that many TFs can co-bind DNA and stabilize nucleosomal binding to a piece of DNA. . For simplicity, we&#39;ll assume we&#39;re only considering transcription factors which cannot co-bind DNA with nucleosomes, and impose a large ΔG penalty for nucleosome and TF co-binding. . Nucleosome:Nucleosome . Nucleosomes are spaced by stretches of free DNA called linker DNA, which have characterisitic lengths. Those specific lengths are believed to facilitate nucleosome arrays forming higher-order chromatin structures. . def energy_of_spacing_between_nucleosomes(nucleosome_positions): &#39;&#39;&#39; &#39;&#39;&#39; pass . nanomolar_kd_from_kcal_ΔG(23.8*kbT) . 0.04610959744808222 . nanomolar_kd_from_kcal_ΔG(14.4*kbT) . 557.3903692694596 . # Resgen: chip, dgf, and atac # chip: bigwig, bed # dgf: bed # atac: bigwig, bed . send blog post for feedback: . Jeremy / Leonid | Advait / Bin Zhang | Anders | Kellis lab | Vlad Teif, other online nucleosome people | TF people? | Muir Morrison / Rob Philips | Bruce Tidor? | . transfer matrix: probably won&#39;t use . # the PWMs are concatenated head to tail on the y/i axis (and expanded ACGT). The next base is on the x/j axis: there are 4 values in the row. # the start of each motif is that value * concentration # I need hypothetical absolute max kd&#39;s ΔG&#39;s. Then everything is relative to that. Does the transfer matrix sum energies or something else? # how does the particular sequence enter the matrix multiplication? You&#39;re choosing a path through the matrix. # Does that mean the matrix at each base is different? Or there are 4 matrices again? # yeah I think there have to be 4 matrices (or 6 if you include methylation). Wait since matrices are for each pair of positions, we need 16 acctually? . sum(tfdb.log_pwm.apply(len)) . 12757 . transfer_matrix_a = np.zeros((len(tf_states), len(tf_states))) # transfer_matrix_c = np.zeros((len(tf_states), len(tf_states))) # transfer_matrix_g = np.zeros((len(tf_states), len(tf_states))) # transfer_matrix_t = np.zeros((len(tf_states), len(tf_states))) . tfdb.log_pwm . TFAP2A [[-0.5324, 0.34450000000000003, -1.5585, 0.530... TFAP2B [[-2.4892, 0.5962000000000001, 1.0115, -2.6127... TFAP2C [[-0.5975, -0.163, -1.1323, 0.7243], [-1.3232,... TFAP2D [[0.8455, -1.4861, 0.1063, -1.8089], [-5.6699,... TFAP2E [[-5.6699, 0.43660000000000004, 1.1706, -5.669... ... BATF3 [[-0.8147000000000001, 0.11900000000000001, 0.... CREB1 [[-0.049100000000000005, -0.20500000000000002,... TP53 [[0.1729, -0.6791, 0.6519, -0.661], [0.7944, -... TP63 [[-0.5391, -1.3228, 1.0218, -0.394300000000000... TP73 [[0.08610000000000001, -0.6413, 0.738200000000... Name: log_pwm, Length: 1080, dtype: object . base_index = {&#39;a&#39;:0,&#39;c&#39;:1,&#39;g&#39;:2,&#39;t&#39;:3} . tf_states = pd.Index([(tf, i) for tf, log_pwm in tfdb.log_pwm.items() for i in range(len(log_pwm))]) . def transfer_matrix_index(TF, offset): return tf_states.get_loc((TF, offset)) . for TF, pwm in tfdb.log_pwm.items(): for offset, row in enumerate(pwm): i = transfer_matrix_index(TF, offset) transfer_matrix_a[i][i+1] = pwm[offset][base_index[&#39;a&#39;]] . - IndexError Traceback (most recent call last) &lt;ipython-input-231-ffe1fe50396a&gt; in &lt;module&gt; 4 i = transfer_matrix_index(TF, offset) 5 -&gt; 6 transfer_matrix_a[i][i+1] = pwm[offset][base_index[&#39;a&#39;]] 7 IndexError: index 12757 is out of bounds for axis 0 with size 12757 . Verify against proteomics . df = pd.read_csv(&#39;https://gygi.hms.harvard.edu/data/ccle/protein_quant_current_normalized.csv.gz&#39;) df = df[[&#39;Protein_Id&#39;, &#39;Gene_Symbol&#39;, &#39;Description&#39;, &#39;Group_ID&#39;, &#39;Uniprot&#39;, &#39;Uniprot_Acc&#39;, &#39;K562_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE_TenPx25&#39;]].rename(columns={&#39;K562_HAEMATOPOIETIC_AND_LYMPHOID_TISSUE_TenPx25&#39;:&#39;Gygi_K562&#39;}) . updates, missing, names_updated = namespace_mapping(df.Gene_Symbol) . passed 12755 symbols 31 names contained whitespace. Stripping... 558 duplicates. 12197 uniques. querying 1-1000...done. querying 1001-2000...done. querying 2001-3000...done. querying 3001-4000...done. querying 4001-5000...done. querying 5001-6000...done. querying 6001-7000...done. querying 7001-8000...done. querying 8001-9000...done. querying 9001-10000...done. querying 10001-11000...done. querying 11001-12000...done. querying 12001-12197...done. Finished. 728 input query terms found dup hits: [(&#39;ARX&#39;, 2), (&#39;NCL&#39;, 2), (&#39;CNP&#39;, 2), (&#39;RPF1&#39;, 2), (&#39;HYPK&#39;, 2), (&#39;FH&#39;, 3), (&#39;RPL17&#39;, 3), (&#39;ATF2&#39;, 2), 13 input query terms found no hit: [&#39;FLJ22184&#39;, &#39;L1RE1&#39;, &#39;MT-ND5&#39;, &#39;MT-ND4&#39;, &#39;MT-CO1&#39;, &#39;MT-CYB&#39;, &#39;MT-ND1&#39;, &#39;GAGE3&#39;, &#39;MT-ATP8&#39;, &#39;hCG_198 unchanged: 11537; updates: 647; missing: 13 . df.Gene_Symbol = names_updated . k562_TF_proteomics = df.groupby(&#39;Gene_Symbol&#39;)[&#39;Gygi_K562&#39;].max().reindex(tfdb.index) . sum(k562_TF_proteomics.notnull()) / len(k562_TF_proteomics) . 0.387037037037037 . k562_TF_proteomics . TFAP2A -2.802736 TFAP2B -2.548439 TFAP2C -3.410715 TFAP2D NaN TFAP2E NaN ... BATF3 NaN CREB1 0.484013 TP53 -3.214319 TP63 -0.861330 TP73 NaN Name: Gygi_K562, Length: 1080, dtype: float64 . tf_proteomics_validation = pd.concat((K562_TF_nanomolar_conc.rename(&#39;[TF] predicted from ENCODE RNA&#39;), k562_TF_proteomics), axis=1) tf_proteomics_validation . [TF] predicted from ENCODE RNA Gygi_K562 . TFAP2A 0.519441 | -2.802736 | . TFAP2B 0.121646 | -2.548439 | . TFAP2C 0.155407 | -3.410715 | . TFAP2D 0.000000 | NaN | . TFAP2E 0.187127 | NaN | . ... ... | ... | . BATF3 3.407311 | NaN | . CREB1 80.409642 | 0.484013 | . TP53 14.273234 | -3.214319 | . TP63 4.264729 | -0.861330 | . TP73 3.747720 | NaN | . 1080 rows × 2 columns . supp3 = pd.read_excel(&#39;~/Desktop/geiger_supp/mcp.M111.014050-3.xlsx&#39;, skiprows=[0]) supp3 = supp3[[&#39;Protein IDs&#39;, &#39;Protein Names&#39;, &#39;Gene Names&#39;, &#39;Uniprot&#39;, &#39;Peptides&#39;,&#39;Razor + unique Peptides&#39;, &#39;Unique Peptides&#39;, &#39;Sequence Coverage [%]&#39;,&#39;Mol. Weight [kDa]&#39;, &#39;PEP&#39;, &#39;iBAQ K562_1&#39;,&#39;iBAQ K562_2&#39;, &#39;iBAQ K562_3&#39;,&#39;LFQ Intensity K562_1&#39;, &#39;LFQ Intensity K562_2&#39;, &#39;LFQ Intensity K562_3&#39;,]] . supp3[&#39;Gene Names&#39;] = supp3[&#39;Gene Names&#39;].str.split(&#39;;&#39;) . sum(supp3[&#39;Gene Names&#39;].isna()) / len(supp3) . 0.060758414997869624 . supp3_genes = [x for l in supp3[&#39;Gene Names&#39;].values if str(l) != &#39;nan&#39; for x in l] . updates, missing, names_updated = namespace_mapping(supp3_genes) . passed 30872 symbols 2285 duplicates. 28587 uniques. querying 1-1000...done. querying 1001-2000...done. querying 2001-3000...done. querying 3001-4000...done. querying 4001-5000...done. querying 5001-6000...done. querying 6001-7000...done. querying 7001-8000...done. querying 8001-9000...done. querying 9001-10000...done. querying 10001-11000...done. querying 11001-12000...done. querying 12001-13000...done. querying 13001-14000...done. querying 14001-15000...done. querying 15001-16000...done. querying 16001-17000...done. querying 17001-18000...done. querying 18001-19000...done. querying 19001-20000...done. querying 20001-21000...done. querying 21001-22000...done. querying 22001-23000...done. querying 23001-24000...done. querying 24001-25000...done. querying 25001-26000...done. querying 26001-27000...done. querying 27001-28000...done. querying 28001-28587...done. Finished. 1899 input query terms found dup hits: [(&#39;GJC1&#39;, 2), (&#39;ATP6C&#39;, 2), (&#39;A15&#39;, 2), (&#39;MYPOP&#39;, 2), (&#39;LAG1&#39;, 4), (&#39;LASS1&#39;, 2), (&#39;UOG1&#39;, 2), (&#39;SDP1 8595 input query terms found no hit: [&#39;FAM1B&#39;, &#39;DKFZp686P0738&#39;, &#39;hCG_23354&#39;, &#39;KIAA0693&#39;, &#39;HSPC198&#39;, &#39;BM-004&#39;, &#39;NKD&#39;, &#39;PP7246&#39;, &#39;hCG_18772 unchanged: 9507; updates: 10576; missing: 8595 . supp3[&#39;gene_name&#39;] = [[] for _ in range(len(supp3))] for i, names in supp3[&#39;Gene Names&#39;].items(): if str(names) != &#39;nan&#39;: for name in names: if name in updates: supp3.iloc[i].gene_name.append(updates[name]) elif name not in missing: supp3.iloc[i].gene_name.append(name) . supp3[&#39;ambiguous&#39;] = False for i, names in supp3[&#39;gene_name&#39;].items(): if len(names) == 0: supp3.loc[i, &#39;gene_name&#39;] = np.nan elif all(name == names[0] for name in names): supp3.loc[i, &#39;gene_name&#39;] = names[0] else: supp3.loc[i, &#39;ambiguous&#39;] = True . len(supp3[supp3.ambiguous]) / len(supp3) . 0.11231359181934385 . Mann_K562 = supp3[supp3.gene_name.isin(tfdb.index)].set_index(&#39;gene_name&#39;).drop(&#39;Gene Names&#39;, axis=1) Mann_K562 = Mann_K562[[&#39;LFQ Intensity K562_1&#39;,&#39;LFQ Intensity K562_2&#39;,&#39;LFQ Intensity K562_3&#39;]].rename(columns={&#39;LFQ Intensity K562_1&#39;:&#39;Mann_K562_1&#39;,&#39;LFQ Intensity K562_2&#39;:&#39;Mann_K562_2&#39;,&#39;LFQ Intensity K562_3&#39;:&#39;Mann_K562_3&#39;}) Mann_K562 = Mann_K562.reset_index().iloc[Mann_K562.notnull().sum(axis=1).reset_index().groupby(&#39;gene_name&#39;)[0].idxmax().values].set_index(&#39;gene_name&#39;).reindex(tfdb.index) Mann_K562 = Mann_K562.median(axis=1) . Mann_K562 . TFAP2A NaN TFAP2B NaN TFAP2C NaN TFAP2D NaN TFAP2E NaN .. BATF3 NaN CREB1 NaN TP53 NaN TP63 NaN TP73 NaN Length: 1080, dtype: float64 . tf_proteomics_validation = pd.concat((tf_proteomics_validation, Mann_K562.rename(&#39;Mann_K562&#39;)), axis=1) . tf_proteomics_validation.plot.scatter(x=&#39;[TF] predicted from ENCODE RNA&#39;, y=&#39;Gygi_K562&#39;, logx=True) . &lt;AxesSubplot:xlabel=&#39;[TF] predicted from ENCODE RNA&#39;, ylabel=&#39;Gygi_K562&#39;&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-02-24T18:38:31.021492 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ tf_proteomics_validation.plot.scatter(x=&#39;[TF] predicted from ENCODE RNA&#39;, y=&#39;Mann_K562&#39;, logx=True) . &lt;AxesSubplot:xlabel=&#39;[TF] predicted from ENCODE RNA&#39;, ylabel=&#39;Mann_K562&#39;&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-02-24T18:39:25.544396 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/ tf_proteomics_validation.plot.scatter(x=&#39;Gygi_K562&#39;, y=&#39;Mann_K562&#39;) . &lt;AxesSubplot:xlabel=&#39;Gygi_K562&#39;, ylabel=&#39;Mann_K562&#39;&gt; . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2022-02-24T18:39:23.630016 image/svg+xml Matplotlib v3.5.1, https://matplotlib.org/",
            "url": "https://alexlenail.me/back_of_my_envelope/2022/01/12/equilibrium_TFs.html",
            "relUrl": "/2022/01/12/equilibrium_TFs.html",
            "date": " • Jan 12, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Enzyme Kinetic Parameter Inference",
            "content": "# imports import os, sys, pickle, time from itertools import combinations_with_replacement, product from collections import Counter, namedtuple from io import StringIO import h5py from pathlib import Path import numpy as np import pandas as pd import matplotlib.pyplot as plt import matplotlib.ticker as mtick import matplotlib.patches as patches from matplotlib.colors import to_hex import plotly.graph_objs as go import plotly.express as px from plotly.subplots import make_subplots import seaborn as sns import scipy.stats from scipy.stats import multivariate_normal from ipywidgets import interact, interactive, IntSlider, SelectionSlider, fixed from IPython.display import display, clear_output %config InlineBackend.figure_format = &#39;retina&#39; %matplotlib inline # from IPython.display import set_matplotlib_formats # set_matplotlib_formats(&#39;svg&#39;) plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] plt.rcParams[&#39;figure.dpi&#39;] = 140 plt.rcParams[&#39;agg.path.chunksize&#39;] = 10000 plt.rcParams[&#39;animation.html&#39;] = &#39;jshtml&#39; plt.rcParams[&#39;hatch.linewidth&#39;] = 0.3 exp = np.exp sqrt = np.sqrt Π = np.prod π = np.pi N = np.random.normal def hex_to_rgb(h): return [int(h.lstrip(&#39;#&#39;)[i:i+2], 16)/256 for i in (0, 2, 4)] matplotlib_colors = plt.rcParams[&#39;axes.prop_cycle&#39;].by_key()[&#39;color&#39;] import warnings warnings.filterwarnings(action=&#39;once&#39;) . # resize figure special function from IPython.core.display import Image, HTML import io import binascii def resize_fig(width, height): s = io.BytesIO() plt.savefig(s, format=&#39;png&#39;, bbox_inches=&quot;tight&quot;, dpi=200) plt.close() return f&#39;&lt;img width=&quot;{width}&quot; height=&quot;{height}&quot; class=&quot;keep_dims&quot; src=&quot;data:image/png;base64,{binascii.b2a_base64(s.getvalue()).decode()}&amp;#10;&quot;&gt;&#39; . Background . $$ newcommand{ kon}{k_{ mathrm{on}}} newcommand{ koff}{k_{ mathrm{off}}} newcommand{ kcat}{k_{ mathrm{cat}}} newcommand{ kuncat}{k_{ mathrm{uncat}}} newcommand{ kms}{k_{m, mathrm{S}}} newcommand{ kmp}{k_{m, mathrm{P}}} newcommand{ dSdt}{ frac{d[ mathrm{S}]}{dt}} newcommand{ dEdt}{ frac{d[ mathrm{E}]}{dt}} newcommand{ dESdt}{ frac{d[ mathrm{ES}]}{dt}} newcommand{ dPdt}{ frac{d[ mathrm{P}]}{dt}}$$Enzyme Kinetics . Enzymes catalyze many critical chemical reactions in cells. . Describing a cell with a mathematical model (a long-standing goal of computational biologists) would entail modelling each enzyme-catalyzed chemical reaction. . However, although we may know the scheme for many enzymatic reactions (the responsible enzyme, the associated substrates, and resultant products) we are often missing many of the details needed to construct a faithful mathematical model of the reaction. . Let&#39;s begin by introducing the mathematical model used to describe enzymatic reaction schemes. Consider the following enzymatically-catalyzed (uni uni) chemical reaction scheme: . $$ E+S underset{ koff}{ overset{ kon}{ rightleftarrows}} ES underset{ kuncat}{ overset{ kcat}{ rightleftarrows}}E+P $$ . In this scheme E is an enzyme, S is its substrate, ES is the enzyme-substrate complex, which is an intermediate, and P is the product of the reaction. Each of those chemical species has a concentration in a fixed volume, which we denote with brackets (e.g. $[ mathrm{E}]$ = enzyme concentration). . If we make the simplifying assumption that the 4 molecular species are &#39;well-mixed&#39; in solution, we can invoke the &#39;Law of Mass Action&#39; under which the rate of each of the four included reactions is linear in the concentrations of the reactants (with an associated coefficient called the rate constant). The reactions in the above scheme are: enzyme-substrate association ($ kon$), dissociation ($ koff$), enzyme catalysis of substrate into product ($ kcat$), and enzyme-product re-association (&quot;uncatalysis&quot;, $ kuncat$). The designation of &#39;substrate&#39; and &#39;product&#39; is our choice -- the model is entirely symmetric, which is reflected in the associated ODEs: . $$ begin{aligned} frac{d[ mathrm{S}]}{dt} &amp;= k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] frac{d[ mathrm{E}]}{dt} &amp;= k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] + k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] frac{d[ mathrm{ES}]}{dt} &amp;= - k_{ mathrm{off}}[ mathrm{ES}] + k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] - k_{ mathrm{cat}}[ mathrm{ES}] + k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] frac{d[ mathrm{P}]}{dt} &amp;= k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] end{aligned}$$This differential equation model describing the (deterministic) chemical kinetics for an enzymatically-catalyzed reaction in well-mixed conditions contains 4 kinetic parameters, i.e. 4 degrees of freedom, which we do not know a priori. These will be the subject of inference. . Note: the intracellular environment is not best described as well-mixed, and models of &#8217;Macromolecular Crowding&#8217; have led to more accurate rate laws for these reactions in vivo. However, we will retain the well-mixed assumption for now. . Parameter Inference . There are 3 typical problems associated with ODE models: . Supplied with a complete specification of the system, the forward problem is to integrate the differential equations from some initial conditions forwards in time and predict the trajectory of the system. This is what is typically meant by &quot;solving&quot; the ODE system, but exact analytical solutions are rare, and numerical methods are often brought to bear to approximate system trajectories. | Supplied with one or more trajectories (data) but incomplete specification of the system, the inverse problem is to estimate parameters of the system (coefficients in the ODE expressions). | Finally, given some manipulable inputs, the control problem is to drive the system towards some desired state. | . This post will explore a range of approaches for the inverse problem. Our goal will be to estimate the kinetic parameters of enzymatically-catalyzed chemical reactions from timeseries of concentrations of the molecular species. . Note: enzyme kinetic parameters are typically not inferred from metabolite timeseries data using the methods we will describe, but instead from specific enzyme assays. However, at the moment, these assays are limited to studying one enzyme at a time. The inference approaches described in this post can leverage data from emerging high-throughput assays, which measure many molecular concentrations at once. . The determination of the kinetic parameters for the enzymatic reactions of life is a major project, and reported values have been tabulated in databases such as BRENDA. However, my experience with these databases has been that the reported kinetic parameters are not internally consistent. . The Michaelis-Menten/Briggs-Haldane Approximation . Two assumptions commonly made at this point are: . to assume the initial substrate concentration is much larger than the enzyme concentration ($[ mathrm{S_0}] gg [ mathrm{E_0}]$). | to suppose that the rates of enzyme-substrate association ($ kon$) and dissociation ($ koff$) are greater than the rates of catalysis and uncatalysis (i.e. $ kon$, $ koff$ $ gg$ $ kcat$, $ kuncat$). | These assumptions permit a timescale separation argument called the &quot;Quasi-Steady-State Approximation&quot; (QSSA) in which we set $ dESdt = 0$, which enables the derivation of the traditional Reversible Michaelis-Menten/Briggs-Haldane expression: . $$ begin{aligned} frac{d[ mathrm{P}]}{dt} &amp;= frac{ frac{ kcat , [ mathrm{E_T}] [ mathrm{S}]}{K_{m, mathrm{S}}} - frac{ koff , [ mathrm{E_T}] [ mathrm{P}]}{K_{m, mathrm{P}}}} {1+ frac{[ mathrm{S}]}{K_{m, mathrm{S}}} + frac{[ mathrm{P}]}{K_{m, mathrm{P}}}} frac{d[ mathrm{S}]}{dt} &amp;= - frac{d[ mathrm{P}]}{dt} end{aligned}$$in which we have introduced the &quot;Michaelis Constants&quot;: $K_{m, mathrm{S}} = frac{ koff + kcat}{ kon}$ and $K_{m, mathrm{P}} = frac{ koff + kcat}{ kuncat}$. . The QSSA reduces the system from 4 variables to 2. However, there are still 4 kinetic parameters to estimate in this reduced model. . Note: another assumption typically made at this point is to assume that catalysis is irreversible ($ kuncat = 0$), leading to a further simplified expression for the rate of product formation $ frac{d[ mathrm{P}]}{dt}$. However, this assumption is quite often inaccurate, so we will not make it. . Exploring the Forward Model . A Standard Example . Before we explore techniques to estimate enzyme kinetic parameters from timeseries data, we need to generate timeseries data to begin with. We can accomplish that by fixing kinetic parameters, then solving the forward problem. It will turn out that integrating the differential equations forwards is a subroutine of both approaches to the inverse problem we&#39;ll see in this post, so developing a method for the forward problem is hardly wasted effort. . In order to produce a trajectory, we need to set initial conditions. We&#39;ll integrate the reaction kinetics of a hypothetical in vitro experiment, in which a fixed quantity of enzyme and substrate are added to the reaction at the outset, then left to react. . Note: in vivo we would expect the concetration of enzyme to vary over time, and the substrate to be replenished. We will generalize this approach to a more biologically-relevant setting in a future post. . Our initial conditions are: . $[E]_0$, the initial enzyme concentration, is set to 1mM (miliMolar, i.e. 1000μM). | $[S]_0$, the initial substrate concentration is set to 10mM. | . default_initial_conditions = { &#39;S_0&#39;: 10e3, &#39;E_0&#39;: 1e3, &#39;ES_0&#39;: 0.0, &#39;P_0&#39;: 0.0 } . Next, let&#39;s fix some generic rate constants: . $ kon ,$ of $10^6$ events per Mol per second, or 1 per μM per second, is a typical rate for enzyme-substrate binding. | $ koff ,$ of 500/s results in a $ koff$/$ kon$ = $k_d$ of 500 μM, which is a typical $k_d$. | $ kcat ,$ is 30/s, a fairly slow but respectable $ kcat$. | $ kuncat ,$ of $ frac{ kon}{10}$ is often considered as the boundary for the QSSA to hold (so 0.1 per μM per second). Let&#39;s use $ kuncat = frac{ kon}{100} = $ 0.01/μM for good measure. | . Our units are μM and seconds. . default_kinetic_params = { &#39;k_on&#39;: 1, &#39;k_off&#39;: 500, &#39;k_cat&#39;: 30, &#39;k_uncat&#39;: 0.01 } def k_ms(p): return (p[&#39;k_off&#39;] + p[&#39;k_cat&#39;]) / p[&#39;k_on&#39;] def k_mp(p): return (p[&#39;k_off&#39;] + p[&#39;k_cat&#39;]) / p[&#39;k_uncat&#39;] default_kinetic_params[&#39;k_ms&#39;] = k_ms(default_kinetic_params) default_kinetic_params[&#39;k_mp&#39;] = k_mp(default_kinetic_params) . To simulate the kinetics with little derivative steps, we need a step size, and a number of total steps: . dt = 1e-6 steps = 5e5 . There are a variety of numerical methods to integrate systems of differential equations. The most straightforward is Euler&#39;s method, which we&#39;ve written down explicitly for this system below: . def integrate_euler_full(kinetic_params, dt=dt, steps=steps, initial_conditions=default_initial_conditions): S, E, ES, P = initial_conditions.values() k_on, k_off, k_cat, k_uncat, k_ms, k_mp = kinetic_params.values() traj = [[S, E, ES, P]] for _ in range(int(steps)): dS = k_off * ES - k_on * E * S dE = k_off * ES - k_on * E * S + k_cat * ES - k_uncat * E * P dES = k_on * E * S - k_off * ES - k_cat * ES + k_uncat * E * P dP = k_cat * ES - k_uncat * E * P S += dS * dt E += dE * dt ES += dES * dt P += dP * dt traj.append([S, E, ES, P]) return pd.DataFrame(traj, columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;], index=np.around(np.linspace(0, dt*steps, int(steps)+1), 6)) . We&#39;ll also write down Euler&#39;s method for the Michaelis-Menten/Briggs-Haldane kinetics . # define integrate_euler_MM(), which integrates the Michaelis-Menten/Briggs-Haldane kinetics def integrate_euler_MM(kinetic_params, dt=dt, steps=steps, initial_conditions=default_initial_conditions): S, E, ES, P = initial_conditions.values() k_on, k_off, k_cat, k_uncat, k_ms, k_mp = kinetic_params.values() traj = [P] for _ in range(int(steps)): dP = ((k_cat * E * S) / k_ms - (k_off * E * P) / k_mp) / (1 + S / k_ms + P / k_mp) dS = -dP P += dP * dt S += dS * dt traj.append(P) return pd.Series(traj, name=&#39;P_MM&#39;, index=np.around(np.linspace(0, dt*steps, int(steps)+1), 6)).to_frame() . Now we can integrate the reaction kinetics, and plot the trajectory. We&#39;ll overlay the Michaelis-Menten/Briggs-Haldane kinetics with dotted lines on top of the full kinetics (solid). . traj_euler_full = integrate_euler_full(default_kinetic_params) traj_euler_mm = integrate_euler_MM(default_kinetic_params) . # figure styles def fig_style(ax): for side in [&quot;right&quot;,&quot;top&quot;]: ax.spines[side].set_visible(False) ax.set_xlabel(&#39;time (s)&#39;, weight=&#39;bold&#39;) ax.set_ylabel(&#39;concentration (μM)&#39;, weight=&#39;bold&#39;) def param_string(E_0=None, S_0=None, k_on=None, k_off=None, k_cat=None, k_uncat=None, k_ms=None, k_mp=None, **kwargs): return f&#39;[k_on= {k_on}/μM/s] [k_off = {k_off}/s] [k_cat = {k_cat}/s] [k_uncat = {k_uncat}/μM/s] [E₀ = {int(E_0)}μM] [S₀ = {int(S_0)}μM]&#39; c = { &#39;S&#39;: &#39;dodgerblue&#39;, &#39;E&#39;: &#39;sienna&#39;, &#39;ES&#39;: &#39;blue&#39;, &#39;P&#39;: &#39;darkblue&#39;, &#39;S_MM&#39;: &#39;steelblue&#39;, &#39;P_MM&#39;: &#39;slateblue&#39;, &#39;k_on&#39;: &#39;mediumseagreen&#39;, &#39;k_off&#39;: &#39;olive&#39;, &#39;k_cat&#39;: &#39;darkgreen&#39;, &#39;k_uncat&#39;: &#39;darkgoldenrod&#39;, &#39;k_m&#39;: &#39;olivedrab&#39;, &#39;k_ms&#39;: &#39;forestgreen&#39;, &#39;k_mp&#39;: &#39;darkkhaki&#39;, } c = {k:to_hex(v) for k,v in c.items()} def color(columns): return [c[col] for col in columns] . # plot the integrated kinetics ax = traj_euler_full.plot.line(title=param_string(**default_initial_conditions, **default_kinetic_params), color=color(traj_euler_full.columns)) traj_euler_mm.plot.line(ax=ax, color=color(traj_euler_mm.columns), linestyle=&#39;--&#39;) fig_style(ax) . We can plainly see the validity of the Quasi-Steady-State Approximation (QSSA) in action in the trajectory: Enzyme E and Substrate S rapidly form Enzyme-Substrate complex ES, the concentration of which remains relatively constant throughout the course of the reaction (recall the QSSA is the approximation that $ dESdt = 0$). Thus, the Michaelis-Menten/Briggs-Haldane product concentration trajectory P_MM well approximates the full kinetics trajectory for the concentration of product P, since the requisite assumptions are valid, namely, (1) $[ mathrm{S_0}] gg [ mathrm{E_0}]$ and (2) $ kon$, $ koff$ $ gg$ $ kcat$, $ kuncat$. . In practice, Michaelis-Menten/Briggs-Haldane kinetics are often assumed by default, risking the possibility of their misapplication. Let&#39;s take this opportunity to explore how the MM/BH kinetics diverge from the full kinetics when we violate the requisite assumptions. . Breaking the Michaelis-Menten/Briggs-Haldane Assumptions: Initial Substrate:Enzyme Ratio . Suppose first the number of molecules of substrate is not much greater than the number of molecules of enzyme, which is a plausible regime for certain reactions in vivo. . initial_conditions = { &#39;S_0&#39;: 2e3, &#39;E_0&#39;: 1e3, &#39;ES_0&#39;: 0.0, &#39;P_0&#39;: 0.0 } . traj_euler_full_2 = integrate_euler_full(default_kinetic_params, steps=2e5, initial_conditions=initial_conditions) traj_euler_mm_2 = integrate_euler_MM(default_kinetic_params, steps=2e5, initial_conditions=initial_conditions) ax = traj_euler_full_2.plot.line(title=param_string(**initial_conditions, **default_kinetic_params), color=color(traj_euler_full_2.columns)) traj_euler_mm_2.plot.line(ax=ax, color=color(traj_euler_mm_2.columns), linestyle=&#39;--&#39;) fig_style(ax) . Then P_MM worsens significantly as an estimate of P. . Breaking the Michaelis-Menten/Briggs-Haldane Assumptions: Fast Enzyme-Substrate Complex Kinetics . Suppose further that the rates of association and dissociation of enzyme with subtstrate are not substantially faster than those of enzyme and product. . kinetic_params = { &#39;k_on&#39;: 0.05, &#39;k_off&#39;: 1, &#39;k_cat&#39;: 50, &#39;k_uncat&#39;: 0.5 } kinetic_params[&#39;k_ms&#39;] = k_ms(kinetic_params) kinetic_params[&#39;k_mp&#39;] = k_mp(kinetic_params) . traj_euler_full_3 = integrate_euler_full(kinetic_params, initial_conditions=initial_conditions) traj_euler_mm_3 = integrate_euler_MM(kinetic_params, initial_conditions=initial_conditions) ax = traj_euler_full_3.plot.line(title=param_string(**initial_conditions, **kinetic_params), color=color(traj_euler_full_3.columns)) traj_euler_mm_3.plot.line(ax=ax, color=color(traj_euler_mm_3.columns), linestyle=&#39;--&#39;) fig_style(ax) . Then the Michaelis-Menten/Briggs-Haldane kinetics diverge further. . In each of these latter trajectories, the criteria to make the Michaelis-Menten/Briggs-Haldane approximation are violated, leading to poor approximations to the full kinetics. We belabor this point here because in the following, we will seek to infer the parameters of the kinetics, and our inference will fit poorly if we fit to inappropriate kinetic expressions. . Comparing Integrators . All of the above trajectories are generated by Euler&#39;s Method, the most intuitive ODE integration technique. Unfortunately, Euler&#39;s Method&#39;s naïvete has drawbacks: . The order of the error is large with respect to the timestep size. | The method is slow, due to the uniformity of the timestep sizes. | . A variety of faster and more accurate (albeit more complicated) integrators have been proposed, many of which have implementations in scipy&#39;s integrate package. Due to their superior speeds and accuracies, we&#39;ll use these methods during inference. As a sanity check, we compare our basic Euler Method solver to scipy&#39;s: . # define integrate_scipy_full and scipy_MM integrate_scipy_MM (and helpers) to integrate chemical kinetics with scipy from scipy.integrate import solve_ivp def dy_full(t, y, k_on, k_off, k_cat, k_uncat, *args): # Y ordered S,E,ES,P dy = np.zeros(4) dy[0] = k_off * y[2] - k_on * y[1] * y[0] dy[1] = k_off * y[2] - k_on * y[1] * y[0] + k_cat * y[2] - k_uncat * y[1] * y[3] dy[2] = k_on * y[1] * y[0] - k_off * y[2] - k_cat * y[2] + k_uncat * y[1] * y[3] dy[3] = k_cat * y[2] - k_uncat * y[1] * y[3] return dy def dy_MM(t, y, S_0, E_0, ES_0, P_0, k_on, k_off, k_cat, k_uncat, k_ms, k_mp): # Y ordered S,P dy = np.zeros(2) dy[1] = ((k_cat * E_0 * y[0]) / k_ms - (k_off * E_0 * y[1]) / k_mp) / (1 + y[0] / k_ms + y[1] / k_mp) dy[0] = -dy[1] return dy def integrate_scipy_full(kinetic_params, initial_conditions=default_initial_conditions, dt=dt, steps=steps, atol=1e-6): t_span = (0, dt*steps) t_eval = np.around(np.linspace(t_span[0],t_span[1],1001), decimals=5) y0 = list(initial_conditions.values()) try: sol = solve_ivp(dy_full, t_span, y0, args=(*kinetic_params.values(),), t_eval=t_eval, first_step=dt, method=&#39;LSODA&#39;, atol=atol) return pd.DataFrame(sol.y.T, index=sol.t, columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;]) except: return pd.DataFrame(columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;]) def integrate_scipy_MM(kinetic_params, initial_conditions=default_initial_conditions, dt=dt, steps=steps): t_span = (0, dt*steps) t_eval = np.around(np.linspace(t_span[0],t_span[1],1001), decimals=5) y0 = [initial_conditions[&#39;S_0&#39;], initial_conditions[&#39;P_0&#39;]] try: sol = solve_ivp(dy_MM, t_span, y0, args=(*initial_conditions.values(), *kinetic_params.values()), t_eval=t_eval, first_step=dt) return pd.DataFrame(sol.y.T, index=sol.t, columns=[&#39;S_MM&#39;, &#39;P_MM&#39;]) except: return pd.DataFrame(columns=[&#39;S_MM&#39;, &#39;P_MM&#39;]) . # solve the system with both integrators, for default parameters traj_scipy_full = integrate_scipy_full(default_kinetic_params) ax = traj_scipy_full.plot.line(title=param_string(**default_initial_conditions, **default_kinetic_params), color=color(traj_scipy_full.columns), alpha=0.5) traj_euler_full.plot.line(ax=ax, color=color(traj_euler_full.columns), linestyle=&#39;--&#39;) fig_style(ax) . # solve the system with both integrators, for unusual parameters kinetic_params = { &#39;k_on&#39;: 0.02, &#39;k_off&#39;: 5, &#39;k_cat&#39;: 10, &#39;k_uncat&#39;: 0.00001, } kinetic_params[&#39;k_ms&#39;] = k_ms(kinetic_params) kinetic_params[&#39;k_mp&#39;] = k_mp(kinetic_params) start = time.process_time() traj_euler_full_4 = integrate_euler_full(kinetic_params, initial_conditions=initial_conditions) euler_time = time.process_time() - start start = time.process_time() traj_scipy_full_4 = integrate_scipy_full(kinetic_params, initial_conditions=initial_conditions) scipy_time = time.process_time() - start ax = traj_scipy_full_4.plot.line(title=param_string(**initial_conditions, **kinetic_params), color=color(traj_scipy_full_4.columns), alpha=0.5) traj_euler_full_4.plot.line(ax=ax, color=color(traj_euler_full_4.columns), linestyle=&#39;--&#39;) fig_style(ax) . The lack of deviation gives us confidence both integration techniques are accurate. Meanwhile, . f&#39;our naïve code takes {round(euler_time, 2)}s, whereas the optimized scipy code takes {round(scipy_time, 4)}s to generate the same trajectory.&#39; . &#39;our naïve code takes 1.16s, whereas the optimized scipy code takes 0.0064s to generate the same trajectory.&#39; . Inference . We have seen how the trajectory of the chemical system is a function of the kinetic parameters. We would now like to invert that function to recover the kinetic parameters from an observed trajectory. . Suppose we know the initial concentrations of Enzyme E and Substrate S, and we measure the concentration of product P over the course of the reaction, which yields the following dataset: . # plot inverse problem setting measurement_times = np.arange(10+1)/20 observations = traj_scipy_full.loc[measurement_times, &#39;P&#39;] ax = observations.plot.line(marker=&#39;o&#39;, lw=0, color=color([&#39;P&#39;]), legend=True) traj_scipy_full.loc[0, [&#39;E&#39;, &#39;S&#39;]].to_frame().T.plot.line(ax=ax, marker=&#39;o&#39;, lw=0, color=color(traj_scipy_full.columns), legend=True) fig_style(ax) . There are two families of approaches to solving this inverse problem. We will explore the simplest variant of each type. . Note: If we had measurements for $ dPdt$ for various concentrations of $[ mathrm{S}]$, $[ mathrm{P}]$, and $[ mathrm{E}]$ we could estimate the kinetic parameters via nonlinear regression, a much simpler approach, which some readers may be familiar with. Concretely, supposing we had a set of measurements for the variables in brown, a nonlinear regression would permit us to fit the parameters in blue: $$ color{saddlebrown}{ dPdt} color{black} = frac{ frac{ color{dodgerblue}{ kcat} , color{saddlebrown}{[ mathrm{E_T}]} color{saddlebrown}{[ mathrm{S}]}} { color{dodgerblue}{K_{m, mathrm{S}}}} - frac{ color{dodgerblue}{ koff} , color{saddlebrown}{[ mathrm{E_T}]} color{saddlebrown}{[ mathrm{P}]}}{ color{dodgerblue}{K_{m, mathrm{P}}}}} {1+ frac{ color{saddlebrown}{[ mathrm{S}]}}{ color{dodgerblue}{K_{m, mathrm{S}}}} + frac{ color{saddlebrown}{[ mathrm{P}]}}{ color{dodgerblue}{K_{m, mathrm{P}}}}} $$ If we had assumed the reaction were irreversible ($k_{ mathrm{uncat}} = 0$), the Michaelis-Menten/Briggs-Haldane expression would have simplified further to $$ color{saddlebrown}{ dPdt} color{black} = frac{ color{dodgerblue}{ kcat} , color{saddlebrown}{[ mathrm{E_T}]} color{saddlebrown}{[ mathrm{S}]}} { color{dodgerblue}{K_{m, mathrm{S}}} color{black} + color{saddlebrown}{[ mathrm{S}]}} $$ Where $ color{dodgerblue}{ kcat} , color{saddlebrown}{[ mathrm{E_T}]}$ is often consolidated as $ color{dodgerblue}{V_{max}}$. It&#39;s difficult to imagine an assay for the activity of many enzymes in a cell at once. Careful Mass Spectrometry-based metabolomics and proteomics, or clever microscopy might measure $[ mathrm{S}]$, $[ mathrm{P}]$, and $[ mathrm{E}]$ but unlikely $ dPdt$ for many enzymes. We would presumably not be able to approximate $ dPdt$ via finite differences either, due to the likely sparsity of the measurement in time compared to the rates of the reactions. The computational approaches covered in this post are more elaborate (and expensive), but do not require measurement of $ dPdt$, making them better suited to existing assays. Bayesian Approach: Inference by Sampling . [We assume the reader is familiar with Bayesian Inference in other settings.] . The goal of the Bayesian approach is to characterize a posterior distribution of kinetic parameters which could plausibly have generated the data. Bayes Theorem defines the posterior as the product of the prior and likelihood (up to a constant factor). Thus the Bayesian approach entails defining a prior and a likelihood for our problem. . Prior . If the kinetic parameters of our enzyme are not unlike the kinetic parameters of other enzymes, then the empirical distribution of kinetic parameters of other enzymes is a good prior for the parameters of our enzyme. . Since databases of observed enzyme kinetic parameters (e.g. BRENDA, SabioRK) appear to be unreliable, we&#39;ll use a previously curated set of kinetic parameters (from the supplement of Bar-Even et. al.). . This database lists $k_{ mathrm{m}}$ and $ kcat$ for both &quot;forwards&quot; and &quot;reverse&quot; reactions with respect to which direction biologists believe is &quot;productive&quot;, from which we can parlay distributions for $ kms$ and $ kcat$ from reactions in the forwards direction, and $ kmp$ and $ koff$ from reverse reactions. . # import kinetic parameter database df = pd.read_excel(&#39;../data/Enzyme_Kinetic_Parameter_Inference/Moderately_Efficient_Enzyme/bi2002289_si_003.xls&#39;, 1)[[&#39;Reaction direction (KEGG)&#39;,&#39;KM (µM)&#39;,&#39;kcat (1/sec)&#39;]] empirical_kms = df.loc[df[&#39;Reaction direction (KEGG)&#39;] == 1, &#39;KM (µM)&#39;].dropna().rename(&#39;k_ms&#39;) empirical_kmp = df.loc[df[&#39;Reaction direction (KEGG)&#39;] == -1, &#39;KM (µM)&#39;].dropna().rename(&#39;k_mp&#39;) empirical_kcat = df.loc[df[&#39;Reaction direction (KEGG)&#39;] == 1, &#39;kcat (1/sec)&#39;].dropna().rename(&#39;k_cat&#39;) empirical_koff = df.loc[df[&#39;Reaction direction (KEGG)&#39;] == -1, &#39;kcat (1/sec)&#39;].dropna().rename(&#39;k_off&#39;) empirical_joint_forward_params = df.loc[df[&#39;Reaction direction (KEGG)&#39;] == 1, [&#39;KM (µM)&#39;,&#39;kcat (1/sec)&#39;]].dropna().rename(columns={&#39;KM (µM)&#39;:&#39;k_ms&#39;, &#39;kcat (1/sec)&#39;:&#39;k_cat&#39;}) empirical_joint_reverse_params = df.loc[df[&#39;Reaction direction (KEGG)&#39;] == -1, [&#39;KM (µM)&#39;,&#39;kcat (1/sec)&#39;]].dropna().rename(columns={&#39;KM (µM)&#39;:&#39;k_mp&#39;, &#39;kcat (1/sec)&#39;:&#39;k_off&#39;}) . # figure styles def fig_style_2(ax): for side in [&quot;right&quot;,&quot;top&quot;,&quot;left&quot;]: ax.spines[side].set_visible(False) ax.get_yaxis().set_visible(False) . # plot km distribution in log-space log_empirical_kms = np.log(empirical_kms) log_empirical_kmp = np.log(empirical_kmp) log_kms_normal = scipy.stats.norm(loc=log_empirical_kms.mean(), scale=log_empirical_kms.std()) log_kmp_normal = scipy.stats.norm(loc=log_empirical_kmp.mean(), scale=log_empirical_kmp.std()) ax = log_empirical_kms.plot.hist(bins=500, alpha=0.3, density=1, legend=True) log_empirical_kmp.plot.hist(bins=500, ax=ax, alpha=0.3, density=1, legend=True) ax.set_xlabel(&#39;log(k_m[µM]) histogram&#39;, weight=&#39;bold&#39;) fig_style_2(ax) # x1 = np.linspace(log_kms_normal.ppf(0.01), log_kms_normal.ppf(0.99), 100) # ax.plot(x1, log_kms_normal.pdf(x1)*ax.get_ylim()[1]*3, &#39;-&#39;, lw=0.6, color=&#39;dodgerblue&#39;) # x2 = np.linspace(log_kmp_normal.ppf(0.01), log_kmp_normal.ppf(0.99), 100) # ax.plot(x2, log_kmp_normal.pdf(x2)*ax.get_ylim()[1]*3, &#39;-&#39;, lw=0.8, color=&#39;peru&#39;) . This plot is surprising: according to this database, enzymes appear to have roughly equal binding affinity for their substrates and products. . # plot kcat distribution in log-space log_empirical_kcat = np.log(empirical_kcat) log_empirical_koff = np.log(empirical_koff) log_kcat_normal = scipy.stats.norm(loc=log_empirical_kcat.mean(), scale=log_empirical_kcat.std()) log_koff_normal = scipy.stats.norm(loc=log_empirical_koff.mean(), scale=log_empirical_koff.std()) ax = log_empirical_kcat.plot.hist(bins=500, alpha=0.3, density=1, legend=True) log_empirical_koff.plot.hist(bins=500, ax=ax, alpha=0.3, density=1, legend=True) x1 = np.linspace(log_kcat_normal.ppf(0.01), log_kcat_normal.ppf(0.99), 100) ax.plot(x1, log_kcat_normal.pdf(x1)*ax.get_ylim()[1]*3, &#39;-&#39;, lw=0.4, color=&#39;dodgerblue&#39;) x2 = np.linspace(log_koff_normal.ppf(0.01), log_koff_normal.ppf(0.99), 100) ax.plot(x2, log_koff_normal.pdf(x2)*ax.get_ylim()[1]*3, &#39;-&#39;, lw=0.6, color=&#39;peru&#39;) ax.set_xlabel(&#39;log(k_cat[1/s]) histogram&#39;, weight=&#39;bold&#39;) fig_style_2(ax) . On the other hand, they have a fairly strong preference for catalyzing the reaction biologists think of as forwards (~10x). . Since these empirical distributions over $ kms$ and $ kcat$ in the forwards direction and $ kmp$ and $ koff$ in the reverse direction look sufficiently like normals in log space, so we&#39;ll treat them as lognormals. However, we would like our inference procedure to estimate $ kon$, $ koff$, $ kcat$, and $ kuncat$. We can rearrange the expressions for $ kms$ and $ kmp$ to get expressions for the two parameters we&#39;re missing: . $$ kon = frac{ koff + kcat}{ kms} quad mathrm{and} quad kuncat = frac{ koff + kcat}{ kmp}$$ . Conveniently, the ratio of lognormal variables $ frac{X_1}{X_2}$ is also lognormal with $ mu_{1/2} = mu_1 - mu_2$ and $ sigma^2_{1/2} = sigma^2_1 + sigma^2_2 - sigma_{x_1, x_2}$. In order to use that fact, we say the sum of the random variables $ koff + kcat$ is also log-normally distributed. We compute its mean and variance empirically. . kcat_plus_koff = pd.Series(np.repeat(empirical_kcat.values, len(empirical_koff)) + np.tile(empirical_koff.values, len(empirical_kcat))) log_kcat_plus_koff_mean = np.log(kcat_plus_koff).mean() log_kcat_plus_koff_var = np.log(kcat_plus_koff).var() . This permits us to produce empirical distributions for $ kon$ and $ kuncat$, . log_kon_normal = scipy.stats.norm(loc=log_kcat_plus_koff_mean-log_empirical_kms.mean(), scale=sqrt(log_kcat_plus_koff_var+log_empirical_kms.var())) log_kuncat_normal = scipy.stats.norm(loc=log_kcat_plus_koff_mean-log_empirical_kmp.mean(), scale=sqrt(log_kcat_plus_koff_var+log_empirical_kmp.var())) . which, along with our empirical distributions for $ koff$ and $ kcat$, define a prior over the 4 kinetic parameters we wish to infer. . We might ask whether these are correlated lognormals... . pp = sns.pairplot(np.log(empirical_joint_forward_params), kind=&quot;kde&quot;, plot_kws={&#39;linewidths&#39;:0.5, &#39;color&#39;:&#39;darkolivegreen&#39;}) k_ms_univariate_density = pp.diag_axes[0].get_children()[0] k_ms_univariate_density.set_edgecolor(c[&#39;k_ms&#39;]) k_ms_univariate_density.set_facecolor(hex_to_rgb(c[&#39;k_ms&#39;]) + [0.1]) k_cat_univariate_density = pp.diag_axes[1].get_children()[0] k_cat_univariate_density.set_edgecolor(c[&#39;k_cat&#39;]) k_cat_univariate_density.set_facecolor(hex_to_rgb(c[&#39;k_cat&#39;]) + [0.1]) fig1 = resize_fig(400, 400) pp = sns.pairplot(np.log(empirical_joint_reverse_params), kind=&quot;kde&quot;, plot_kws={&#39;linewidths&#39;:0.5, &#39;color&#39;:&#39;grey&#39;}) k_mp_univariate_density = pp.diag_axes[0].get_children()[0] k_mp_univariate_density.set_edgecolor(c[&#39;k_mp&#39;]) k_mp_univariate_density.set_facecolor(hex_to_rgb(c[&#39;k_mp&#39;]) + [0.1]) k_off_univariate_density = pp.diag_axes[1].get_children()[0] k_off_univariate_density.set_edgecolor(c[&#39;k_off&#39;]) k_off_univariate_density.set_facecolor(hex_to_rgb(c[&#39;k_off&#39;]) + [0.1]) fig2 = resize_fig(400, 400) HTML(&#39;&lt;style&gt;.keep_dims{float:left;}&lt;/style&gt;&#39;+fig1+fig2+&#39;&lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt;&#39;) . ...Not enough to include covariances in the prior. We set the prior covariance to be a diagonal matrix: . # define prior_cov to be a diagonal covariance matrix prior_cov = np.diag([log_kon_normal.var(), log_koff_normal.var(), log_kcat_normal.var(), log_kuncat_normal.var()]) . # define functions relating to the prior distribution def prior_pdf(k_on=None, k_off=None, k_cat=None, k_uncat=None, **kwargs): return ( log_kon_normal.pdf(k_on) * log_koff_normal.pdf(k_off) * log_kcat_normal.pdf(k_cat) * log_kuncat_normal.pdf(k_uncat)) def prior_logpdf(k_on=None, k_off=None, k_cat=None, k_uncat=None, **kwargs): return ( log_kon_normal.logpdf(k_on) + log_koff_normal.logpdf(k_off) + log_kcat_normal.logpdf(k_cat) + log_kuncat_normal.logpdf(k_uncat)) def sample_prior(): # returns [k_on, k_off, k_cat, k_uncat] return { &#39;k_on&#39;: log_kon_normal.rvs(), &#39;k_off&#39;: log_koff_normal.rvs(), &#39;k_cat&#39;: log_kcat_normal.rvs(), &#39;k_uncat&#39;: log_kuncat_normal.rvs()} . Now that we have a prior, let&#39;s examine where the default parameters introduced in §2.1 land in this distribution. I had claimed they were &quot;typical&quot;. . # plot log-space kinetic parameter distributions, with default parameters presented previously overlaid fig, axs = plt.subplots(2,2,constrained_layout=True) def plot_distrib(distrib, ax, title, param): ax.set_xlim(-14,14) ax.set_ylim(0,0.15) x = np.linspace(distrib.ppf(0.001), distrib.ppf(0.999), 100) y = distrib.pdf(x) color = c[param] ax.plot(x, y, &#39;-&#39;, lw=0.7, color=color) ax.fill_between(x, 0, y, color=color, alpha=0.1) ax.axvline(np.log(default_kinetic_params[param]), 0, 1, linestyle=&#39;--&#39;, color=color) ax.xaxis.set_ticks(np.arange(-14, 14.01, 2)) ax.set_xlabel(title, weight=&#39;bold&#39;) fig_style_2(ax) plot_distrib(log_kon_normal, axs[0][0], &#39;log(k_on[µM])&#39;, &#39;k_on&#39;) plot_distrib(log_koff_normal, axs[0][1], &#39;log(k_off[1/s])&#39;, &#39;k_off&#39;) plot_distrib(log_kuncat_normal, axs[1][0], &#39;log(k_uncat[µM])&#39;, &#39;k_uncat&#39;) plot_distrib(log_kcat_normal, axs[1][1], &#39;log(k_cat[1/s])&#39;, &#39;k_cat&#39;) . Likelihood . We need to define a likelihood $p(D| theta)$ which measures the probability of producing the observed data given settings of the kinetic parameters $ theta = { kon, koff, kcat, kuncat }$. Our data $D = { mathrm{obs}_{[ mathrm{P}]}(t) , ; t in 0...0.5 }$ are an observed trajectory of concentrations of reaction product P. Each setting of the kinetic parameters corresponds to a trajectory of concentrations of P (via a numerical integration). Intuitively, parameter sets which result in trajectories very near the observed trajectory are more likely. Therefore, our likelihood should measure the distance between the observed $ { mathrm{obs}_{[ mathrm{P}]}(t) , ; t in 0...0.5 }$ and predicted $ { u_{[ mathrm{P}]}(t, theta) , ; t in 0...0.5 }$. . How far should the predicted trajectory be allowed to stray from the measured $ { mathrm{obs}_{[ mathrm{P}]}(t) }$? The likelihood is really our statement about the presumed noise in our measurements. If we believe our measurements to be noiseless, then our likelihood should concentrate tightly around our measurements (a dirac $ delta$ in the limit), and we would only admit kinetic parameters that interpolate the observed $ { mathrm{obs}_{[ mathrm{P}]}(t) }$ almost exactly. In reality, no measurement is noiseless, so we propose the following noise model: . Supposing the detection of each molecule of P is an independent binary random variable with error rate $ sigma$ then the aggregate random variable $ mathrm{N}_{[ mathrm{P}]}(t)$ is gaussian-distributed $ sim mathcal{N}( mathrm{obs}_{[ mathrm{P}]}(t), , sigma cdot sqrt{ mathrm{obs}_{[ mathrm{P}]}(t)} )$. The variance of the gaussian grows as the square root of the mean, via a Central Limit Theorem argument. We can represent this noise model (and consequently, likelihood) visually as: . σ = 5 # arbitrary magic number represents detection noise level . # plot intuition for likelihood definition plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] ax = observations.rename(&#39;observations&#39;).plot.line(marker=&#39;.&#39;, lw=0, color=color([&#39;P&#39;]), legend=True, markersize=2) domain = np.linspace(0,10000,1000) for x, y in observations.iloc[1:].items(): distrib = scipy.stats.norm(loc=y, scale=np.sqrt(y)*σ) ax.fill_betweenx(domain, [x]*1000, x2=x+distrib.pdf(domain)/distrib.pdf(y)/150, color=color([&#39;P&#39;]), alpha=0.2) fig_style(ax) . Concretely, the likelihood is the product distribution of each of the gaussian marginals centered around the measurements. These form a multivariate normal, diagonal since we don&#39;t model covariances. . $$p(D| theta) = displaystyle prod_{t in mathrm{obs}} p_t left(u_{[ mathrm{P}]}(t, theta) right) textrm{ where } p_t textrm{ is the probability density function of } mathrm{N}_{[ mathrm{P}]}(t) sim mathcal{N} left( mathrm{obs}_{[ mathrm{P}]}(t), , sigma cdot sqrt{ mathrm{obs}_{[ mathrm{P}]}(t) } right)$$ . Which leaves us with a &quot;hyperparameter&quot; $ sigma$, which we have set arbitrarily above. . likelihood_dist = multivariate_normal(mean=observations.values[1:], cov=σ * np.diag(sqrt(observations.values[1:]))) def likelihood_logpdf(ut): return likelihood_dist.logpdf(ut) . . Note: We will supply noiseless measurements to our inference algorithms. However, our inference procedures will assume noise in the measurements. . Metropolis-Hastings . We can now evaluate the prior $p( theta)$ and the likelihood $p(D| theta)$ of kinetic parameters $ theta = { kon, koff, kcat, kuncat }$. Those two distributions permit us to elaborate an Markov Chain Monte Carlo (MCMC) routine to sample from the posterior $p( theta|D) propto p(D| theta) cdot p( theta)$. The algorithm is as follows: . Repeat: . Draw kinetic parameters from the proposal distribution. | Integrate the system with the proposed kinetic parameters. | Evaluate the likelihood of the trajectory generated in step 2. | Accept/Reject the proposal by a Metropolis-Hastings criterion. | Append the current kinetic parameters to the Markov Chain. | Construct a proposal distribution around the current kinetic parameters. | Since the likelihood assigns most of the probability mass to a fairly narrow region of parameter space, most parameter sets have extremely low probability. In order to preserve some numerical stability, we log-transform the typical Metropolis-Hastings expressions. So typically $π_t = mathrm{likelihood _pdf}(u_t) cdot mathrm{prior _pdf}(θ_t)$ and the acceptance criterion is $ frac{π_{t+1}}{π_t} &gt; mathrm{rand}([0,1])$. In log space, the acceptance criterion becomes: $ log(π_{t+1}) - log(π_t) &gt; log( mathrm{rand}([0,1]))$ with $ log(π_t) = mathrm{likelihood _logpdf}(u_t) + mathrm{prior _logpdf}(θ_t)$. . def MH_MCMC(chain_length=1e3): θt = sample_prior() ut = simulate_measurements(exp_params(θt)) πt = likelihood_logpdf(ut) + prior_logpdf(**θt) if all(ut == 0): return MH_MCMC(chain_length) cov = np.eye(4) * 5e-4 i = 0 accept_ratio = 0 chain = [] samples = [] while i &lt; chain_length: θtp1 = proposal(θt, cov) utp1 = simulate_measurements(exp_params(θtp1)) πtp1 = likelihood_logpdf(utp1) + prior_logpdf(**θtp1) if πtp1 - πt &gt; np.log(np.random.rand()): θt, ut, πt = θtp1, utp1, πtp1 accept_ratio += 1 chain.append(θt) samples.append(ut) i += 1 if i % 100 == 0 and i &gt; 300: # cov = pd.DataFrame(chain[100:]).cov() print(i, end=&#39; r&#39;) chain = pd.DataFrame(chain) samples = pd.DataFrame(np.hstack((np.zeros((len(chain), 1)), samples)), columns=observations.index) accept_ratio = accept_ratio/chain_length return chain, samples, accept_ratio . Our proposal density for the time being can be a simple isotropic gaussian around the current parameters. We could update our Gaussian&#39;s covariance over the course of sampling, but that proved to be unhelpful for this problem. . def proposal(θt, cov): μ = [θt[&#39;k_on&#39;], θt[&#39;k_off&#39;], θt[&#39;k_cat&#39;], θt[&#39;k_uncat&#39;]] θtp1 = dict(zip([&#39;k_on&#39;, &#39;k_off&#39;, &#39;k_cat&#39;, &#39;k_uncat&#39;], np.random.multivariate_normal(μ, cov))) return θtp1 . # define a few extra helpers called from our MCMC routine def exp_params(log_kinetic_params): return {name: exp(val) for name, val in log_kinetic_params.items()} def simulate_measurements(kinetic_params): u = integrate_scipy_full(kinetic_params) return (u.loc[measurement_times, &#39;P&#39;].ravel()[1:] if len(u) &gt; 0 else np.zeros(10)) . Now let&#39;s put it into practice: . chain_length = 1e3 chain, samples, accept_ratio = MH_MCMC(chain_length=chain_length) print(&#39;accept_ratio:&#39;, accept_ratio) . accept_ratio: 0.209 . # plotting functions and figure styles def fig_style_3(ax): for side in [&quot;right&quot;,&quot;top&quot;]: ax.spines[side].set_visible(False) ax.set_xlabel(&#39;chain&#39;, weight=&#39;bold&#39;) ax.set_ylabel(&#39;log parameter values&#39;, weight=&#39;bold&#39;) def plot_chain(chain, ax=None): &#39;&#39;&#39;Note: chain is expected to be in log-parameter space (natural log)&#39;&#39;&#39; if ax is None: fig, ax = plt.subplots() chain.plot.line(xlim=(0,len(chain)), color=[c[param_name] for param_name in chain.columns], ax=ax) for param_name in chain.columns: param_value = default_kinetic_params[param_name] ax.axhline(np.log(param_value), lw=0.5, color=c[param_name], linestyle=&#39;--&#39;) ax.fill_between(np.arange(len(chain)), chain[param_name], np.repeat(np.log(param_value), len(chain)), color=c[param_name], alpha=0.05) fig_style_3(ax) def plot_samples(samples, ax=None): if ax is None: fig, ax = plt.subplots() alpha = max(1/np.sqrt(len(samples)), 0.1) observations.plot.line(marker=&#39;o&#39;, lw=0, color=c[&#39;P&#39;], ylim=(-300, 10800), ax=ax, legend=True) samples.T.plot.line(colormap=plt.get_cmap(&#39;plasma&#39;), alpha=alpha, ax=ax, legend=False, zorder=1) fig_style(ax) . plot_chain(chain) . # Marginal densities of parameter sets visited by the Markov Chain sns.pairplot(chain, kind=&quot;kde&quot;) HTML(resize_fig(600, 600)) . plot_samples(samples) . # define MCMC_run(), which runs MCMC and visualizes the result in one step. def MCMC_run(): chain, samples, accept_ratio = MH_MCMC(chain_length=chain_length) fig, axs = plt.subplots(1, 2) plot_chain(chain, ax=axs[0]) plot_samples(samples, ax=axs[1]) print(&#39;accept_ratio:&#39;, accept_ratio) return chain, samples, accept_ratio . chain_1, samples_1, accept_ratio_1 = MCMC_run() . accept_ratio: 0.288 . chain_2, samples_2, accept_ratio_2 = MCMC_run() . accept_ratio: 0.285 . chain_3, samples_3, accept_ratio_3 = MCMC_run() . accept_ratio: 0.302 . The above chains tell us something interesting: it appears to be possible to closely fit the observed data with very different parameter sets than the ones used to generate the observed trajectory -- except for $k_{ mathrm{cat}}$, which must be accurate. There must exist some subspace of parameters which yield similar $[ mathrm{P}](t)$ curves. We&#39;ll explore the topic of parameter identifiability in a future blog post. . Frequentist Approach: Inference by Optimization . In the previous section, we conducted a random walk in parameter space, biasing our random walk towards regions of the parameter space where both the prior probability and likelihood were greater. After a certain number of samples (the &quot;burn in&quot; phase), the samples from our random walk could be said to be drawn from the (exact) posterior distribution over the kinetic parameters. . An alternative approach begins with another premise: . Suppose we want to incorporate no prior knowledge, and let the timeseries data alone govern our determination of our enzyme&#39;s kinetic parameters. | Suppose as well that instead of searching for a distribution of plausible parameters, we&#39;re only interested in finding the single most likely set of parameters. | . These two choices recast the inference task as an optimization problem. We&#39;ll explore two approaches to optimize the kinetic parameters to fit the observed data. . Forward Sensitivities . Optimization problems require an objective, such as minimizing a loss (or cost) function. Let&#39;s use the conventional squared error between our observations $ mathrm{obs}(t)$ and our trajectory $u(t, theta)$ at the observed timepoints, scaled in accordance with the basic noise model we described in §3.1.2: $G(u(t, theta)) = displaystyle sum_{t in mathrm{obs}} left( frac{ mathrm{obs}(t) - u(t, theta)}{ sigma cdot sqrt{ mathrm{obs}(t)}} right)^2$. . # plot intuition for squared loss definition plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] ax = observations.rename(&#39;observations d(t)&#39;).plot.line(marker=&#39;o&#39;, lw=0, color=color([&#39;P&#39;]), legend=True, markersize=5, ylim=(-5e2,1e4), title=&#39;Intuition for the Squared Error Loss&#39;) (observations * 1.1).rename(&#39;simulation u(t)&#39;).plot.line(marker=&#39;o&#39;, lw=0.4, color=plt.get_cmap(&#39;plasma&#39;)(0.8), legend=True, markersize=3) # total_err = 0 for x, y in observations.iloc[1:].items(): rect = patches.Rectangle((x, y), y*0.1/1e4*0.225, y*0.1, linewidth=1, edgecolor=&#39;r&#39;, facecolor=&#39;mistyrose&#39;, lw=0.3) ax.add_patch(rect) fig_style(ax) . def loss(u): if not all(observations.index.isin(u.index)): return np.nan return sum(((observations - u.loc[observations.index, &#39;P&#39;])/(σ * np.sqrt(observations))).dropna()**2) . In order to optimize $ theta$ with respect to to our loss function $G$, we need a means to evaluate the gradient of the loss with respect to the parameters. Recall the gradient is the vector of first derivatives of $G$ with respect to each parameter $ theta_i$. The simplest way to compute each entry of the gradient ($ frac{dG(u(t, theta))}{d theta_i}$) would be to evaluate $G$ slightly above and below $ theta_i$ to numerically approximate the derivative. Concatenating those (for each $ theta_i$) would yield a numerical approximation of the gradient vector. This technique is called Finite Differences, and it&#39;s valid, though impractical. We&#39;ll implement it to check the validitiy of gradients we compute by other means. . def finite_differences(_, θ): grad = {} for k,v in θ.items(): ϵ = np.sqrt(v * 1e-15) grad[k] = (loss(integrate_scipy_full({**θ, **{k:v+ϵ}})) - loss(integrate_scipy_full({**θ, **{k:v-ϵ}}))) / (2*ϵ) return grad . Beyond Finite Differences, we might try to analytically derive an expression for the gradient: . $$ frac{d}{d theta_i}G(u(t, theta)) = frac{d}{d theta_i} sum_{t in mathrm{obs}} left( frac{ mathrm{obs}(t) - u(t, theta)}{ sigma cdot sqrt{ mathrm{obs}(t)}} right)^2 = sum_{t in mathrm{obs}} left[ 2 left( frac{ mathrm{obs}(t) - u(t, theta)}{( sigma cdot sqrt{ mathrm{obs}(t)})^2} right) cdot frac{-du(t, theta)}{d theta_i} right]$$However, the quantity $ frac{du(t, theta)}{d theta_i}$ (called the sensitivity of the solution to a parameter) is not immediately available. We can derive it as follows: . Our original differential equation is $ frac{du(t, theta)}{dt} = f(u(t, theta), theta)$. If we take $ frac{ partial}{ partial theta_i} left[ frac{du(t, theta)}{dt} right] = frac{ partial}{ partial theta_i} left[ f(u(t, theta), theta) right]$, we can rearrange as $ frac{d}{dt} left[ frac{ partial u(t, theta)}{ partial theta_i} right] = frac{ partial}{ partial theta_i} left[ f(u(t, theta), theta) right]$ and then integrate over $t$ for . $$ int_{t_0}^T frac{d}{dt} left[ frac{ partial u(t, theta)}{ partial theta_i} right] mathrm{d}t = int_{t_0}^T frac{ partial}{ partial theta_i} left[ f(u(t, theta), theta) right] mathrm{d}t = int_{t_0}^T left[ frac{ partial f}{ partial u} Big|_{u(t, theta), theta} cdot frac{ partial u}{ partial theta_i} + frac{ partial f}{ partial theta_i} Big|_{u(t, theta), theta} right] mathrm{d}t$$What we&#39;ve done is define an ODE whose solution (integral) is that missing quantity, the sensitivity $ frac{du(t, theta)}{d theta_i}$. This ODE is aptly named the forward sensitivity ODE. We can integrate both the original ODE and the sensitivity ODE forwards in time together from $t_0$ to $T$. . But first, we need to understand the constituent expressions: $ frac{ partial f}{ partial u} Big|_{u(t, theta), theta}$ , $ frac{ partial u}{ partial theta_i}$ and $ frac{ partial f}{ partial theta_i} Big|_{u(t, theta), theta}$ . Recall, . $$ frac{du}{dt} = frac{d}{dt} begin{bmatrix}[ mathrm{S}] [ mathrm{E}] [ mathrm{ES}] [ mathrm{P}] end{bmatrix} = begin{bmatrix} k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] k_{ mathrm{off}}[ mathrm{ES}] - k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] + k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] - k_{ mathrm{off}}[ mathrm{ES}] + k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] - k_{ mathrm{cat}}[ mathrm{ES}] + k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] k_{ mathrm{cat}}[ mathrm{ES}] - k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] end{bmatrix} = f(u(t, theta), theta)$$$ frac{ partial f}{ partial u} Big|_{u(t, theta), theta}$ is the derivative of the derivative $f$ with respect to the state $u$. Since both the state $u$ and its derivative $f$ are 4D, this quantity is a 4x4 Jacobian: . $$ frac{df}{du} = begin{bmatrix} frac{df}{[ mathrm{S}]} &amp; frac{df}{[ mathrm{E}]} &amp; frac{df}{[ mathrm{ES}]} &amp; frac{df}{[ mathrm{P}]} end{bmatrix} = begin{bmatrix} -k_{ mathrm{on}}[ mathrm{E}] &amp; -k_{ mathrm{on}}[ mathrm{S}] &amp; k_{ mathrm{off}} &amp; 0 -k_{ mathrm{on}}[ mathrm{E}] &amp; -k_{ mathrm{on}}[ mathrm{S}] - k_{ mathrm{uncat}}[ mathrm{P}] &amp; k_{ mathrm{off}} + k_{ mathrm{cat}} &amp; -k_{ mathrm{uncat}}[ mathrm{E}] k_{ mathrm{on}}[ mathrm{E}] &amp; k_{ mathrm{on}}[ mathrm{S}] + k_{ mathrm{uncat}}[ mathrm{P}] &amp; -k_{ mathrm{off}} - k_{ mathrm{cat}} &amp; k_{ mathrm{uncat}}[ mathrm{E}] 0 &amp; -k_{ mathrm{uncat}}[ mathrm{P}] &amp; k_{ mathrm{cat}} &amp; -k_{ mathrm{uncat}}[ mathrm{E}] end{bmatrix}$$ def f_u_Jacobian(S, E, ES, P, k_on, k_off, k_cat, k_uncat): return np.array([ [-k_on * E, -k_on * S, k_off, 0], [-k_on * E, -k_on * S - k_uncat * P, k_off + k_cat, -k_uncat * E], [k_on * E, k_on * S + k_uncat * P, -k_off - k_cat, k_uncat * E], [0, -k_uncat * P, k_cat, -k_uncat * E] ]) . $ frac{ partial f}{ partial theta_i} Big|_{u(t, theta), theta}$ is the derivative of the derivative $f$ with respect to one of the parameters $ theta_i$. . $$ frac{ partial f}{ partial k_{ mathrm{on}}} = begin{bmatrix} -[ mathrm{E}][ mathrm{S}] -[ mathrm{E}][ mathrm{S}] [ mathrm{E}][ mathrm{S}] 0 end{bmatrix}, qquad frac{ partial f}{ partial k_{ mathrm{off}}} = begin{bmatrix} [ mathrm{ES}] [ mathrm{ES}] -[ mathrm{ES}] 0 end{bmatrix}, qquad frac{ partial f}{ partial k_{ mathrm{cat}}} = begin{bmatrix} 0 [ mathrm{ES}] -[ mathrm{ES}] [ mathrm{ES}] end{bmatrix}, qquad frac{ partial f}{ partial k_{ mathrm{uncat}}} = begin{bmatrix} 0 -[ mathrm{E}][ mathrm{P}] [ mathrm{E}][ mathrm{P}] -[ mathrm{E}][ mathrm{P}] end{bmatrix}, qquad $$ def f_k_on(S, E, ES, P): return np.array([[-E*S, -E*S, E*S, 0]]).T def f_k_off(S, E, ES, P): return np.array([[ES, ES, -ES, 0]]).T def f_k_cat(S, E, ES, P): return np.array([[0, ES, -ES, ES]]).T def f_k_uncat(S, E, ES, P): return np.array([[0, -E*P, E*P, -E*P]]).T cols = [v+u for u in [&#39;&#39;, &#39;_k_on&#39;, &#39;_k_off&#39;, &#39;_k_cat&#39;, &#39;_k_uncat&#39;] for v in [&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;]] . $ frac{ partial u}{ partial theta_i}$ is the variable of integration, which means we only need to define a boundary condition for it, in this case, an initial value: . $$ frac{ partial u}{ partial theta_i} Big|_{t_0} = frac{ partial}{ partial theta_i} u(0, theta) $$ . But since in our case, our fixed initial condition $u(0, theta)$ does not depend on $ theta$, $ frac{ partial u}{ partial theta_i} Big|_{t_0} = 0$. . Now we&#39;re ready to augment our original Euler method to compute both $ int_{t_0}^T frac{du(t, theta)}{dt} mathrm{d}t$ as before and add $ int_{t_0}^T frac{ partial}{ partial theta_i} left[ f(u(t, theta), theta) right] mathrm{d}t$. . # define integrate_euler_full_sensitivities(), which integrates the full kinetics and sensitivity ODE with Euler&#39;s Method def integrate_euler_full_sensitivities(kinetic_params, dt=dt, steps=steps, initial_conditions=default_initial_conditions): k_on, k_off, k_cat, k_uncat, k_ms, k_mp = kinetic_params.values() S, E, ES, P = initial_conditions.values() u_k_on = np.zeros((4,1)) u_k_off = np.zeros((4,1)) u_k_cat = np.zeros((4,1)) u_k_uncat = np.zeros((4,1)) traj = [[S, E, ES, P, *u_k_on.flatten(), *u_k_off.flatten(), *u_k_cat.flatten(), *u_k_uncat.flatten()]] for i in range(int(steps)): S += (k_off * ES - k_on * E * S) * dt E += (k_off * ES - k_on * E * S + k_cat * ES - k_uncat * E * P) * dt ES += (k_on * E * S - k_off * ES - k_cat * ES + k_uncat * E * P) * dt P += (k_cat * ES - k_uncat * E * P) * dt f_u = f_u_Jacobian(S, E, ES, P, k_on, k_off, k_cat, k_uncat) u_k_on += (f_u @ u_k_on + f_k_on(S, E, ES, P)) * dt u_k_off += (f_u @ u_k_off + f_k_off(S, E, ES, P)) * dt u_k_cat += (f_u @ u_k_cat + f_k_cat(S, E, ES, P)) * dt u_k_uncat += (f_u @ u_k_uncat + f_k_uncat(S, E, ES, P)) * dt traj.append([S, E, ES, P, *u_k_on.T[0].copy(), *u_k_off.T[0].copy(), *u_k_cat.T[0].copy(), *u_k_uncat.T[0].copy()]) return pd.DataFrame(traj, columns=cols, index=np.around(np.linspace(0, dt*steps, int(steps)+1), 6)) . # integrate system ODE and sensitivity ODE together, and plot the trajectories start = time.process_time() traj_euler_full_sensitivities = integrate_euler_full_sensitivities(default_kinetic_params) euler_time = time.process_time() - start ODE_columns = traj_euler_full_sensitivities.columns[:4] sensitivity_columns = traj_euler_full_sensitivities.columns[4:] P_sensitivity_columns = traj_euler_full_sensitivities.columns[7::4] fig, axs = plt.subplots(1, 2) traj_euler_full_sensitivities[ODE_columns].plot.line(ax=axs[0], color=color(ODE_columns)) traj_euler_full_sensitivities[sensitivity_columns].plot.line(ax=axs[1], color=color(sensitivity_columns.str.split(&#39;_&#39;).str[0])) fig_style(axs[0]) fig_style(axs[1]) axs[1].set_ylabel(&#39;Sensitivity dθ/dt&#39;) plt.tight_layout() . Unfortunately, as before, our simple-minded python code, although conceptually helpful, is too slow to use repeatedly inside a loop. Let&#39;s once again re-structure this code for scipy. . # define integrate_scipy_full_sensitivities (and helpers), which integrates the full kinetics and sensitivities with scipy def dy_full_sensitivities(t, y, k_on, k_off, k_cat, k_uncat, *args): # Y ordered S,E,ES,P dy = np.zeros(20) dy[0] = k_off * y[2] - k_on * y[1] * y[0] dy[1] = k_off * y[2] - k_on * y[1] * y[0] + k_cat * y[2] - k_uncat * y[1] * y[3] dy[2] = k_on * y[1] * y[0] - k_off * y[2] - k_cat * y[2] + k_uncat * y[1] * y[3] dy[3] = k_cat * y[2] - k_uncat * y[1] * y[3] f_u = f_u_Jacobian(*y[0:4], k_on, k_off, k_cat, k_uncat) dy[4:8] = np.dot(f_u, y[4:8]) + f_k_on(*y[0:4]).T dy[8:12] = np.dot(f_u, y[8:12]) + f_k_off(*y[0:4]).T dy[12:16] = np.dot(f_u, y[12:16]) + f_k_cat(*y[0:4]).T dy[16:20] = np.dot(f_u, y[16:20]) + f_k_uncat(*y[0:4]).T return dy def integrate_scipy_full_sensitivities(kinetic_params, initial_conditions=default_initial_conditions, dt=dt, steps=steps, atol=1e-8): t_span = (0, dt*steps) t_eval = np.around(np.linspace(t_span[0],t_span[1],1001), decimals=5) y0 = list(initial_conditions.values()) + [0]*16 try: sol = solve_ivp(dy_full_sensitivities, t_span, y0, args=(*kinetic_params.values(),), t_eval=t_eval, first_step=dt, method=&#39;LSODA&#39;, atol=atol) return pd.DataFrame(sol.y.T, index=sol.t, columns=cols) except: return pd.DataFrame(columns=cols) . # benchmark our naive code against scipy&#39;s integrator for the sensitivity equations start = time.process_time() traj_scipy_full_sensitivities = integrate_scipy_full_sensitivities(default_kinetic_params) scipy_time = time.process_time() - start ax = traj_euler_full_sensitivities[sensitivity_columns].plot.line(color=color(sensitivity_columns.str.split(&#39;_&#39;).str[0]), alpha=0.5, legend=False) traj_scipy_full_sensitivities[sensitivity_columns].plot.line(ax=ax, color=color(sensitivity_columns.str.split(&#39;_&#39;).str[0]), linestyle=&#39;--&#39;, legend=False) ax.set_ylabel(&#39;Sensitivity dθ/dt&#39;, weight=&#39;bold&#39;) ax.set_xlabel(&#39;time (s)&#39;, weight=&#39;bold&#39;) print(f&#39;Our naïve code takes {round(euler_time, 2)}s, whereas the optimized scipy code takes {round(scipy_time, 4)}s to generate the same trajectory.&#39;) . Our naïve code takes 22.08s, whereas the optimized scipy code takes 0.1982s to generate the same trajectory. . Recall, computing the sensitivity of the solution with respect to the parameters $ frac{du(t, theta)}{d theta_i}$ was in service of computing the gradient of our loss function with respect to the parameters: . $$ frac{dG(u(t, theta))}{d theta_i} = sum_{t in mathrm{obs}} left[ 2 left( frac{ mathrm{obs}(t) - u(t, theta)}{( sigma cdot sqrt{ mathrm{obs}(t)})^2} right) cdot frac{-du(t, theta)}{d theta_i} right]$$Now, since we set up this problem such that we only observe $ mathrm{obs}_{[ mathrm{P}]}(t)$, we are only able to compare the integrated kinetics of $ u_{[ mathrm{P}]}(t, theta)$ and so our gradient expression becomes: . $$ frac{dG(u(t, theta))}{d theta_i} = sum_{t in mathrm{obs}} left[ 2 left( frac{( mathrm{obs}_{[ mathrm{P}]}(t) - u_{[ mathrm{P}]}(t, theta))}{( sigma cdot sqrt{ mathrm{obs}_{[ mathrm{P}]}(t)})^2} right) cdot frac{ -d u_{[ mathrm{P}]}(t, theta)}{d theta_i} right]$$ . # define gradient_of_loss() which returns the gradient of the loss with respect to each parameter def gradient_of_loss_via_sensitivities(integrated_system_and_sensitivities, _): diff = 2*(observations - integrated_system_and_sensitivities.loc[observations.index, &#39;P&#39;]) / (σ * np.sqrt(observations))**2 P_k = -integrated_system_and_sensitivities.loc[observations.index, P_sensitivity_columns] grad = P_k.multiply(diff, axis=&#39;rows&#39;).sum() grad.index = grad.index.str.lstrip(&#39;P_&#39;) return grad.to_dict() . We notice that $ frac{ d u_{[ mathrm{P}]}(t, theta)}{dk_{ mathrm{uncat}}}$ reaches $O(10^6)$. This difference of the scales of the sensitivities may be because the parameters span many orders of magnitude, so the response of the system to small perturbations in some parameters may be much greater than others, especially integrated over time. . # plot the subset of sensitivities which impinge on [P] -- notice the scale of dP/dk_uncat! ax = traj_scipy_full_sensitivities[P_sensitivity_columns].plot.line(color=color(P_sensitivity_columns.str.split(&#39;_&#39;, 1).str[1])) ax.set_xlabel(&#39;time (s)&#39;, weight=&#39;bold&#39;) ax.set_ylabel(&#39;Sensitivity dθ/dt&#39;, weight=&#39;bold&#39;) None . We&#39;ve set ourselves the task of optimizing the 4 ODE parameters to minimize the squared error with respect to an observed timeseries. We need somewhere to begin optimization from. Let&#39;s use the means of the prior distributions (from §3.1.1) for each parameter as a starting point. . θ_0 = {&#39;k_on&#39;: exp(log_kon_normal.mean()), &#39;k_off&#39;: exp(log_koff_normal.mean()), &#39;k_cat&#39;: exp(log_kcat_normal.mean()), &#39;k_uncat&#39;: exp(log_kuncat_normal.mean())} . Our gradient descent routine iterates a loop: . Integrate the system ODE and sensitivity ODE with the current parameters. | Compute the gradient of the loss with the current parameters. | Update the parameters with a gradient step | Our optimization routine will use one extra trick: a momentum term. This amounts to updating the gradient step expression from . $$ theta_{t+1} = theta_t - eta cdot frac{dG(u(t, theta))}{d theta} qquad mathrm{to} qquad begin{aligned} v_{t+1} &amp;= gamma cdot v_t + frac{dG(u(t, theta))}{d theta} theta_{t+1} &amp;= theta_t - eta cdot v_t end{aligned}$$This expression has two hyperparamters: $ eta$, the learning rate and $ gamma$, the momentum parameter. We&#39;ll set $ eta = 0.01$ at first and decrease it as we converge towards a minimum. We set $ gamma$ to the typical 0.9. . # define optimize_by_gradient_descent Optimization_Record = namedtuple(&#39;Optimization_Record&#39;, [&#39;θ&#39;, &#39;u&#39;, &#39;loss&#39;, &#39;G_θ&#39;]) def optimize_by_gradient_descent(θ_0, integrate=integrate_scipy_full_sensitivities, gradient=gradient_of_loss_via_sensitivities): &#39;&#39;&#39; signatures: - integrate(θ_t) - gradient(u_t, θ_t) &#39;&#39;&#39; θ_t = dict(θ_0) v_t = {k: 0 for k in θ_0.keys()} u = integrate(θ_t) curr_loss = loss(u) η = 1e-2 γ = 0.9 θ_record = [θ_t] v_record = [v_t] u_record = [u] loss_record = [curr_loss] grad_record = [] while η &gt;= 1e-30: G_θ, *details = gradient(u, θ_t) v_t = {k: γ * v_t[k] + G_θ[k] for k in v_t.keys()} θ_t = {k: max(θ_t[k] - η * v_t[k], 0) for k in θ_t.keys()} next_u = integrate(θ_t) next_loss = loss(next_u) if next_loss &lt; curr_loss: u = next_u curr_loss = next_loss v_record.append(v_t) θ_record.append(θ_t) u_record.append(u) loss_record.append(curr_loss) grad_record.append(G_θ) clear_output(wait=True) print(θ_0, &#39; n tLoss: &#39;, np.round(curr_loss, 6), &#39; -&gt; &#39;, np.round(next_loss, 6), &#39; n t|Gradient|: &#39;, np.linalg.norm(list(G_θ.values())), &#39; n t|v_t|: &#39;, np.linalg.norm(list(v_t.values())), &#39; n tη: &#39;, η, &#39; n t&#39;, θ_t) else: η = η/np.sqrt(10) # print(&#39; tη: &#39;, η) v_t = {k: 0 for k in θ_0.keys()} θ_t = θ_record[-1] continue θ_record = pd.DataFrame(θ_record) loss_record = pd.Series(loss_record) grad_record = pd.DataFrame(grad_record) return Optimization_Record(θ=θ_record, u=u_record, loss=loss_record, G_θ=grad_record) . optimization_record = optimize_by_gradient_descent(θ_0) . {&#39;k_on&#39;: 1.0489415890739007, &#39;k_off&#39;: 9.301874926576735, &#39;k_cat&#39;: 26.789395694394965, &#39;k_uncat&#39;: 0.8975846605968499} Loss: 2.135936 -&gt; 2.135936 |Gradient|: 1.756622982117719 |v_t|: 1.756622982117719 η: 3.1622776601683754e-12 {&#39;k_on&#39;: 3.6718623703555924, &#39;k_off&#39;: 9.116898206276698, &#39;k_cat&#39;: 27.228235334781886, &#39;k_uncat&#39;: 0.7150114110837106} . # plot result of optimization, starting from mean parameter values def plot_optimization_trajectory(optimization_record): plt.rcParams[&#39;figure.figsize&#39;] = [12, 4] fig, axs = plt.subplots(1, 2) num_iterations = len(optimization_record.u) alpha = max(1/np.sqrt(num_iterations), 0.1) for i, u_t in enumerate(optimization_record.u): u_t[&#39;P&#39;].plot.line(ax=axs[0], legend=False, zorder=1, c=plt.get_cmap(&#39;plasma&#39;)(i/num_iterations), alpha=alpha) observations.plot.line(marker=&#39;o&#39;, lw=0, color=c[&#39;P&#39;], ylim=(-300, 10800), ax=axs[0], legend=True) fig_style(axs[0]) optimization_record.loss.plot.line(ax=axs[1], ylim=(0, optimization_record.loss.max()*1.1)) final_loss = optimization_record.loss.iloc[-1] axs[1].text(0, final_loss+optimization_record.loss.max()/50, str(np.round(final_loss, 3)), c=&#39;red&#39;) axs[1].axhline(final_loss, c=&#39;r&#39;, linestyle=&#39;--&#39;, lw=0.5) axs[1].xaxis.set_major_locator(mtick.MaxNLocator(integer=True)) axs[1].set_xlabel(&#39;iteration&#39;, weight=&#39;bold&#39;) axs[1].set_ylabel(&#39;Loss&#39;, weight=&#39;bold&#39;) for side in [&quot;right&quot;,&quot;top&quot;]: axs[1].spines[side].set_visible(False) . plot_optimization_trajectory(optimization_record) . We said initially we didn&#39;t want to rely on prior knowledge of typical enzyme parameters in the sensitivity-based approach, but we&#39;ve used them above to define our starting point for optimization, $ theta_0$. In many settings, we may not have a good estimate of where to begin from, and the conventional approach is to try multiple seeds. Let&#39;s try outlandishly wrong starting points, and see whether our gradient descent routine is able to find parameters which fit the data. . # define procedure to sample outlandish points, and run batch optimization from each of those seeds def prior_samples(n): prior_draws = [] while len(prior_draws) &lt; n: draw = sample_prior() if all([(np.linalg.norm(np.array(list(draw.values())) - np.array(list(prior_draw.values()))) &gt; 1) for prior_draw in prior_draws]): prior_draws.append(draw) return prior_draws def optimize_parametersets(parametersets): optimization_records = [optimize_by_gradient_descent(θ_0) for θ_0 in parametersets] os.system(&quot;printf &#39; a&#39;&quot;) return optimization_records optimization_runs_pickle_path = Path(&#39;../data/Enzyme_Kinetic_Parameter_Inference/optimization_runs.pickle&#39;) def get_optimization_runs(): if optimization_runs_pickle_path.is_file(): with optimization_runs_pickle_path.open(&#39;rb&#39;) as f: optimization_records = pickle.load(f) # some sort of QC here? return optimization_records return None def compute_optimization_runs(): draws = prior_samples(10) optimization_records = optimize_parametersets([exp_params(draw) for draw in draws]) with optimization_runs_pickle_path.open(&#39;wb&#39;) as f: pickle.dump(optimization_records, f) os.system(&quot;printf &#39; a&#39;&quot;) return optimization_records def get_or_compute_optimization_runs(): return get_optimization_runs() or compute_optimization_runs() . optimization_records = get_or_compute_optimization_runs() . # Plot results of optimizations of 10 seeds: Loss trajectories and |gradient| trajectories def plot_optimization_records_losses_and_magnitudes(optimization_records, until=2000): plt.rcParams[&#39;figure.figsize&#39;] = [12, 4] fig, axs = plt.subplots(1, 2) optimization_records_losses = pd.DataFrame([optimization_record.loss for optimization_record in optimization_records]).T.rename_axis(&#39;iteration&#39;) optimization_records_losses.plot.line(ax=axs[0], xlim=(0, until), logy=True, title=&#39;Loss trajectories for 10 draws from the prior&#39;).set_ylabel(&#39;log(Loss)&#39;, fontdict={&#39;weight&#39;:&#39;bold&#39;}) optimization_records_gradient_magnitudes = pd.DataFrame([np.linalg.norm(r.G_θ, axis=1) for r in optimization_records]).T.rename_axis(&#39;iteration&#39;) optimization_records_gradient_magnitudes.plot.line(ax=axs[1], xlim=(0, until), logy=True, title=&#39;Gradient magnitudes for 10 draws from the prior&#39;).set_ylabel(&#39;log(|gradient|)&#39;, fontdict={&#39;weight&#39;:&#39;bold&#39;}) plot_optimization_records_losses_and_magnitudes(optimization_records) . As we did not add noise to our measurements, a loss of 0 is possible. However, none of our optimizations reach 0 loss. We would anticipate the magnitude of our gradients to approach 0 as well, as optimization proceeds successfully. Let&#39;s dig into these optimization runs a little further... . # define plot_optimization_trajectories() def plot_optimization_trajectories(optimization_records, parameter_trajectory_is_in_log_space=False): plt.rcParams[&#39;figure.figsize&#39;] = [12, 4*len(optimization_records)] fig, axs = plt.subplots(len(optimization_records), 2) for i, record in enumerate(optimization_records): P_traj = pd.concat([df[&#39;P&#39;] for df in record.u], axis=1) P_traj.columns = range(len(P_traj.columns)) plot_samples(P_traj.T, ax=axs[i][0]) axs[i][0].set_title(f&#39;prior draw {i}&#39;, fontdict={&#39;weight&#39;:&#39;bold&#39;}).set_c(matplotlib_colors[i]) if parameter_trajectory_is_in_log_space: plot_chain(record.θ, ax=axs[i][1]) else: plot_chain(np.log(record.θ), ax=axs[i][1]) . # plot the optimization trajectories warnings.filterwarnings(&#39;ignore&#39;) plot_optimization_trajectories(optimization_records) plt.tight_layout() . Some of our optimizations succeed fit the data, whereas some fail to. Once again, even those that fit the data quite well (and therefore approach zero loss) do not recover the original parameters the trajectory was generated with. This result warrants a closer inspection of the loss surface. . Visualizing $G(u(t, theta))$, which is a $ R^4 mapsto R^1$ function, is tricky, but we can get a feel for it by examining orthogonal 2D slices. . First, we need to evaluate the loss everywhere on a grid. . # define functions to evaluate the loss on each point on a grid plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] warnings.filterwarnings(&#39;once&#39;) θ_opt = {key: val for key, val in default_kinetic_params.items() if key in [&#39;k_on&#39;, &#39;k_off&#39;, &#39;k_cat&#39;, &#39;k_uncat&#39;]} def parameter_loss(k_on,k_off,k_cat,k_uncat): return loss(integrate_scipy_full({&#39;k_on&#39;:k_on,&#39;k_off&#39;:k_off,&#39;k_cat&#39;:k_cat,&#39;k_uncat&#39;:k_uncat})) loss_hypergrid_hdf5_path = Path(&#39;../data/Enzyme_Kinetic_Parameter_Inference/loss_hypergrid.hdf5&#39;) def get_or_compute_global_loss_hypergrid(): return get_loss_hypergrid(&#39;global_loss_hypergrid&#39;) or compute_global_loss_hypergrid() def get_or_compute_optimization_neighborhood_loss_hypergrid(θ_records, θ_opt): return get_loss_hypergrid(&#39;optimization_neighborhood_loss_hypergrid&#39;) or compute_optimization_neighborhood_loss_hypergrid(θ_records, θ_opt) def get_or_compute_optimum_neighborhood_loss_hypergrid(θ_opt): return get_loss_hypergrid(&#39;optimum_neighborhood_loss_hypergrid&#39;) or compute_point_neighborhood_loss_hypergrid(θ_opt) def get_loss_hypergrid(dset_name): if loss_hypergrid_hdf5_path.is_file(): with h5py.File(loss_hypergrid_hdf5_path, &#39;r&#39;) as h5f: dset = h5f.get(dset_name) loss_hypergrid = np.array(dset) if (loss_hypergrid.ndim and loss_hypergrid.size): # check non-empty indices = dset.attrs.get(&#39;indexes&#39;) return indices, loss_hypergrid return None def compute_loss_hypergrid(indices, name=None): loss_hypergrid = np.vectorize(parameter_loss)(*np.meshgrid(*indices, sparse=True)) if name: with h5py.File(loss_hypergrid_hdf5_path, &#39;a&#39;) as h5f: if name in h5f: print(name + &#39; already exists in file, overwriting...&#39;) del h5f[name] dset = h5f.create_dataset(name, data=loss_hypergrid) dset.attrs[&#39;index_names&#39;] = [&#39;k_on&#39;,&#39;k_off&#39;,&#39;k_cat&#39;,&#39;k_uncat&#39;] dset.attrs[&#39;indexes&#39;] = indices os.system(&quot;printf &#39; a&#39;&quot;) return loss_hypergrid def compute_global_loss_hypergrid(grid_size=11): x = np.logspace(-4, 6, grid_size) indices = [x, x, x, x] return indices, compute_loss_hypergrid(&#39;global_loss_hypergrid&#39;, indices) def compute_optimization_neighborhood_loss_hypergrid(θ_records, θ_opt, grid_size=15, name=&#39;optimization_neighborhood_loss_hypergrid&#39;): Min = [min([θ_record[k].min() for θ_record in θ_records] + [θ_opt[k]]) for k in θ_opt.keys()] Max = [max([θ_record[k].max() for θ_record in θ_records] + [θ_opt[k]]) for k in θ_opt.keys()] indices = [np.linspace(lower*0.9, upper*1.1, grid_size) for lower, upper in zip(Min, Max)] return indices, compute_loss_hypergrid(indices, name=name) def compute_point_neighborhood_loss_hypergrid(θ, grid_size=15, name=&#39;optimum_neighborhood_loss_hypergrid&#39;): indices = [np.linspace(p-p*0.8, p+p*0.8, grid_size) for p in θ.values()] return indices, compute_loss_hypergrid(indices, name=name) . global_indices, global_loss_hypergrid = get_or_compute_global_loss_hypergrid() global_loss_hypergrid.shape . (11, 11, 11, 11) . optimum_neighborhood_indices, optimum_neighborhood_loss_hypergrid = get_or_compute_optimum_neighborhood_loss_hypergrid(θ_opt) optimum_neighborhood_loss_hypergrid.shape . (15, 15, 15, 15) . # Define interactive loss landscape visualization def explore_loss_landscape(k_on, k_off, k_cat, k_uncat, scales, loss_hypergrid, θ_records, θ_opt, cmin=0, cmax=3000): params = θ_opt.keys() n = len(params) fig = make_subplots(rows=n-1, cols=n-1, shared_xaxes=True, shared_yaxes=True) for i, param1 in enumerate(params): for j, param2 in enumerate(params): if i &gt; j: z = np.squeeze(loss_hypergrid[None if &#39;k_on&#39; in [param1, param2] else k_on, None if &#39;k_off&#39; in [param1, param2] else k_off, None if &#39;k_cat&#39; in [param1, param2] else k_cat, None if &#39;k_uncat&#39; in [param1, param2] else k_uncat]).T # Contour fig.add_trace( go.Contour(z=z, x=scales[j], y=scales[i], coloraxis=&quot;coloraxis&quot;, contours_coloring=&#39;heatmap&#39;), row=i, col=j+1 ) # Optimum star if len(θ_opt.keys()): fig.add_trace( go.Scatter(x=[θ_opt[param2]], y=[θ_opt[param1]], mode=&#39;markers&#39;, marker=dict(symbol=&#39;star-dot&#39;, color=&#39;limegreen&#39;, line_color=&#39;black&#39;, line_width=0.2, size=12), showlegend=False, name=&quot;optimum&quot;), row=i, col=j+1 ) # Optimization trajectory lines if len(θ_records): for n, (θ_record, c) in enumerate(zip(θ_records, matplotlib_colors+[&#39;red&#39;]*4)): fig.add_trace( go.Scatter(x=θ_record[param2], y=θ_record[param1], mode=&#39;lines&#39;, line=dict(color=c), showlegend=False, name=f&quot;draw {n}&quot;), row=i, col=j+1 ) fig.add_trace( go.Scatter(x=[θ_record[param2].iloc[-1]], y=[θ_record[param1].iloc[-1]], mode=&#39;markers&#39;, marker=dict(symbol=&#39;diamond&#39;, color=c, size=5), showlegend=False), row=i, col=j+1 ) if i == len(params)-1: fig.update_xaxes(title_text=param2, row=3, col=j+1) if j == 0: fig.update_yaxes(title_text=param1, row=i, col=1) fig.update_layout(height=1000, width=1000, coloraxis=dict(colorscale=&#39;magma&#39;, reversescale=True, cmin=cmin, cmax=cmax)) # fig.show() return fig.to_html(include_plotlyjs=&#39;cdn&#39;, include_mathjax=False) def explore_global_loss_hypergrid(k_on, k_off, k_cat, k_uncat, scales, loss_hypergrid, log_θ_records, θ_opt): &#39;&#39;&#39;Note, this function expects `scales`, `θ_record`, and `θ_opt` to have been log&#39;d (base 10)&#39;&#39;&#39; k_on = int(np.log10(k_on)+4) k_off = int(np.log10(k_off)+4) k_cat = int(np.log10(k_cat)+4) k_uncat = int(np.log10(k_uncat)+4); return explore_loss_landscape(k_on, k_off, k_cat, k_uncat, scales, loss_hypergrid, log_θ_records, θ_opt) def explore_neighborhood_loss_hypergrid(k_on, k_off, k_cat, k_uncat, scales, loss_hypergrid, θ_records, θ_opt): k_on = np.where(scales[0] == k_on)[0][0] k_off = np.where(scales[1] == k_off)[0][0] k_cat = np.where(scales[2] == k_cat)[0][0] k_uncat = np.where(scales[3] == k_uncat)[0][0] return explore_loss_landscape(k_on, k_off, k_cat, k_uncat, scales, loss_hypergrid, θ_records, θ_opt) . We&#39;ll first explore the loss function on a grid in $ log_{10}$ space. This will give us a feel for the global shape of the loss surface, so long as we&#39;re mindful of the $ log_{10}$-distortion. We can also project the optimization trajectories onto each 2D slice (as well as the global optimum), while remembering that the trajectories are 4D, so their projections may not look appear to be optimizing the loss in each 2D slice. We can also take the opportunity to visualize the MCMC trajectories as a comparison (in red). . Note: Run the notebook to interactively explore this landscape with sliders that translate the slices through the 4D space. . # global view of optimization landscape sliders = [SelectionSlider(options=index, description=name, value=index[len(index)//2]) for name, index in zip([&#39;k_on&#39;,&#39;k_off&#39;,&#39;k_cat&#39;,&#39;k_uncat&#39;], global_indices)] w = interactive(explore_global_loss_hypergrid, k_on=sliders[0], k_off=sliders[1], k_cat=sliders[2], k_uncat=sliders[3], scales=fixed(np.log10(global_indices)), loss_hypergrid=fixed(global_loss_hypergrid), log_θ_records=fixed([np.log10(r.θ+1e-4) for r in optimization_records] + [np.log10(np.exp(c)) for c in (chain, chain_1, chain_2, chain_3)]), θ_opt=fixed({k: np.log10(v) for k,v in θ_opt.items()})) display(w) HTML(w.result) # fig.result.update_xaxes(range=[-4, 6], dtick=2) # fig.result.update_yaxes(range=[-4, 6], dtick=2) . . . . Note: The contour plots above suggest local optima, but those are artifacts of plotly&#8217;s contour function and the sparsity of our grid. To understand why our optimizations are failing to reach the optimum, we can also explore the loss around the optimum, or around the termination points of each optimization. Let&#39;s see the neighborhood of the optimum. . # local view of optimization landscape sliders = [SelectionSlider(options=index, description=name, value=index[len(index)//2]) for name, index in zip([&#39;k_on&#39;,&#39;k_off&#39;,&#39;k_cat&#39;,&#39;k_uncat&#39;], optimum_neighborhood_indices)] w = interactive(explore_neighborhood_loss_hypergrid, k_on=sliders[0], k_off=sliders[1], k_cat=sliders[2], k_uncat=sliders[3], scales=fixed(optimum_neighborhood_indices), loss_hypergrid=fixed(optimum_neighborhood_loss_hypergrid), θ_records=fixed([]), θ_opt=fixed(θ_opt)) display(w) HTML(w.result) . . . The optimum falls in a valley, which, once attained, likely has a very small gradient. This corresponds to the valley we saw in the $ log_{10}$-scaled global loss landscape above. Small gradients can be difficult to compute accurately with finite numerical precision, and our optimizer will stop once it&#39;s unable to distinguish which direction is downhill, because the loss surface is locally flat, and tiny steps in the direction of the approximate gradient do not decrease the loss. . Our parameters span many orders of magnitude. In our MCMC approach to this problem, we dealt with our kinetic parameters in log space. Let&#39;s take a quick detour and try gradient-based optimization for the log-parameters. . Forward Sensitivities in Log Space . Many of the expressions derived in the previous section remain the same when we optimize the loss $G$ with respect to the log-parameters. The Jacobian $ frac{ partial f}{ partial u} Big|_{u(t, theta), theta}$ remains the same, however, the $ frac{ partial f}{ partial theta} Big|_{u(t, theta), theta}$ terms are replaced by $ frac{ partial f}{ partial log( theta)} Big|_{u(t, theta), theta}$ terms: . $$ frac{ partial f}{ partial log(k_{ mathrm{on}})} = begin{bmatrix} -k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] -k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] k_{ mathrm{on}}[ mathrm{E}][ mathrm{S}] 0 end{bmatrix}, qquad frac{ partial f}{ partial log(k_{ mathrm{off}})} = begin{bmatrix} k_{ mathrm{off}}[ mathrm{ES}] k_{ mathrm{off}}[ mathrm{ES}] -k_{ mathrm{off}}[ mathrm{ES}] 0 end{bmatrix}, qquad frac{ partial f}{ partial log(k_{ mathrm{cat}})} = begin{bmatrix} 0 k_{ mathrm{cat}}[ mathrm{ES}] -k_{ mathrm{cat}}[ mathrm{ES}] k_{ mathrm{cat}}[ mathrm{ES}] end{bmatrix}, qquad frac{ partial f}{ partial log(k_{ mathrm{uncat}})} = begin{bmatrix} 0 -k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] -k_{ mathrm{uncat}}[ mathrm{E}][ mathrm{P}] end{bmatrix}, qquad $$ def f_log_k_on(S, E, ES, P, k_on): return np.array([[-k_on*E*S, -k_on*E*S, k_on*E*S, 0]]).T def f_log_k_off(S, E, ES, P, k_off): return np.array([[k_off*ES, k_off*ES, -k_off*ES, 0]]).T def f_log_k_cat(S, E, ES, P, k_cat): return np.array([[0, k_cat*ES, -k_cat*ES, k_cat*ES]]).T def f_log_k_uncat(S, E, ES, P, k_uncat): return np.array([[0, -k_uncat*E*P, k_uncat*E*P, -k_uncat*E*P]]).T . We&#39;ll skip straight to the scipy implementation. . # define integrate_scipy_log_sensitivities (and helpers), which integrates the full kinetics and sensitivities with respect to the log&#39;d parameters with scipy def dy_log_sensitivities(t, y, k_on, k_off, k_cat, k_uncat, *args): # Y ordered S,E,ES,P dy = np.zeros(20) dy[0] = k_off * y[2] - k_on * y[1] * y[0] dy[1] = k_off * y[2] - k_on * y[1] * y[0] + k_cat * y[2] - k_uncat * y[1] * y[3] dy[2] = k_on * y[1] * y[0] - k_off * y[2] - k_cat * y[2] + k_uncat * y[1] * y[3] dy[3] = k_cat * y[2] - k_uncat * y[1] * y[3] f_u = f_u_Jacobian(*y[0:4], k_on, k_off, k_cat, k_uncat) dy[4:8] = np.dot(f_u, y[4:8]) + f_log_k_on(*y[0:4], k_on).T dy[8:12] = np.dot(f_u, y[8:12]) + f_log_k_off(*y[0:4], k_off).T dy[12:16] = np.dot(f_u, y[12:16]) + f_log_k_cat(*y[0:4], k_cat).T dy[16:20] = np.dot(f_u, y[16:20]) + f_log_k_uncat(*y[0:4], k_uncat).T return dy def integrate_scipy_log_sensitivities(kinetic_params, initial_conditions=default_initial_conditions, dt=dt, steps=steps): &#39;&#39;&#39;Note this function assumes the kinetic params are not in log space -- exp() them beforehand&#39;&#39;&#39; t_span = (0, dt*steps) t_eval = np.around(np.linspace(t_span[0],t_span[1],1001), decimals=5) y0 = list(initial_conditions.values()) + [0]*16 try: sol = solve_ivp(dy_log_sensitivities, t_span, y0, args=(*kinetic_params.values(),), t_eval=t_eval, first_step=dt, method=&#39;LSODA&#39;) return pd.DataFrame(sol.y.T, index=sol.t, columns=cols) except: return pd.DataFrame(columns=cols) . traj_scipy_log_sensitivities = integrate_scipy_log_sensitivities(default_kinetic_params) fig, axs = plt.subplots(1, 2) traj_scipy_log_sensitivities[ODE_columns].plot.line(ax=axs[0], color=color(ODE_columns)) traj_scipy_log_sensitivities[sensitivity_columns].plot.line(ax=axs[1], color=color(sensitivity_columns.str.split(&#39;_&#39;).str[0])) fig_style(axs[0]) fig_style(axs[1]) axs[1].set_ylabel(&#39;Sensitivity dθ/dt&#39;) plt.tight_layout() . We&#39;ll once more start from the mean of the prior, . log_θ_0 = {&#39;k_on&#39;: log_kon_normal.mean(), &#39;k_off&#39;: log_koff_normal.mean(), &#39;k_cat&#39;: log_kcat_normal.mean(), &#39;k_uncat&#39;: log_kuncat_normal.mean()} . optimization_record = optimize_by_gradient_descent(log_θ_0, integrate=lambda log_θ: integrate_scipy_log_sensitivities(exp_params(log_θ))) . {&#39;k_on&#39;: 0.04778164537946772, &#39;k_off&#39;: 2.2302159848479026, &#39;k_cat&#39;: 3.288006126168655, &#39;k_uncat&#39;: -0.1080478337126154} Loss: 0.697513 -&gt; 0.697513 |Gradient|: 0.5847699040405534 |v_t|: 0.5847699040405534 η: 9.999999999999989e-11 {&#39;k_on&#39;: 1.1154074189761212, &#39;k_off&#39;: 1.754124991901947, &#39;k_cat&#39;: 3.3975347971126704, &#39;k_uncat&#39;: 0} . plot_optimization_trajectory(optimization_record) . This seems promising. Let&#39;s once more start from many initial points. . # Define functions to run multiple log-parameter optimizations log_optimization_runs_pickle_path = Path(&#39;../data/Enzyme_Kinetic_Parameter_Inference/log_optimization_runs.pickle&#39;) def optimize_log_parametersets(log_parametersets): optimization_records = [optimize_by_gradient_descent(log_θ_0, integrate=lambda log_θ: integrate_scipy_log_sensitivities(exp_params(log_θ))) for log_θ_0 in log_parametersets] os.system(&quot;printf &#39; a&#39;&quot;) return optimization_records def get_log_optimization_runs(): if log_optimization_runs_pickle_path.is_file(): with log_optimization_runs_pickle_path.open(&#39;rb&#39;) as f: log_optimization_records = pickle.load(f) # some sort of QC here? return log_optimization_records return None def compute_log_optimization_runs(): draws = prior_samples(10) optimization_records = [record for record in optimize_log_parametersets(draws) if record] with log_optimization_runs_pickle_path.open(&#39;wb&#39;) as f: pickle.dump(optimization_records, f) os.system(&quot;printf &#39; a&#39;&quot;) return optimization_records def get_or_compute_log_optimization_runs(): return get_log_optimization_runs() or compute_log_optimization_runs() . log_optimization_records = get_or_compute_log_optimization_runs() . plot_optimization_records_losses_and_magnitudes(log_optimization_records) . # plot the optimization trajectories warnings.filterwarnings(&#39;ignore&#39;) plot_optimization_trajectories(log_optimization_records, parameter_trajectory_is_in_log_space=True) plt.tight_layout() . Steps in log space can be quite large, often yielding much faster convergences. We see some trajectories still fail to approach optima. . Adjoint Method . There exists another way to evalate the gradient of the loss with respect to the parameters. Our intention is not to improve the accuracy of the gradients, but instead the asymptotic computational complexity of evaluating the gradient, and thus decrease the runtime for optimizing the parameters of systems with many parameters. . Our enzyme kinetics system has 4 parameters, which is not many, so we will not experience a notable speedup in our optimizations, but including the approach is perhaps easier to illustrate granularly for a small system. . In the Forward Sensitivities approach, a system of Ordinary Differential Equations in 4 variables with 4 parameters had us integrating 16 sensitivity variables: $ frac{ partial [ mathrm{X}_i]}{ partial theta_j}$ for each combination of $[ mathrm{X}_i]$ and $ theta_j$. The number of sensitivity ODE expressions scales as $O(| mathrm{X}| cdot | theta|)$. The Adjoint Method for ODEs will permit us to reduce that to $O(| mathrm{X}| + | theta|)$. Let&#39;s walk through the derivation. Fair warning: it&#39;s lengthy (at least by my standards). . Derivation: . We had chosen our loss to be . $$G(u(t, theta)) = sum_{t in mathrm{obs}} left( frac{ mathrm{obs}(t) - u(t, theta)}{ sigma cdot sqrt{ mathrm{obs}(t)}} right)^2 $$ Re-write $G$ as an integral of the instantaneous loss over continuous time, for which we can use dirac deltas $ delta$ . $$ begin{aligned}G(u(t, theta)) &amp;= int_{t_0}^T left[ left( frac{ mathrm{obs}(t) - u(t, theta)}{ sigma cdot sqrt{ mathrm{obs}(t)}} right)^2 cdot sum_{t_i in mathrm{obs}} delta(t_i-t) right] , mathrm{d}t &amp;= int_{t_{0}}^{T}g(u(t, theta)) , mathrm{d}t end{aligned}$$ We want to specify the constraint that $ frac{du}{ , mathrm{d}t} = f(u(t, theta), theta)$ throughout the domain which we can do via lagrange multipliers. Introduce the auxiliary vector variable $ lambda$ . $$G(u(t, theta)) = int_{t_{0}}^{T}g(u(t, theta)) , mathrm{d}t+ int_{t_{0}}^{T} lambda^{ intercal}(t) left( frac{du}{ , mathrm{d}t}-f(u(t, theta), theta) right) , mathrm{d}t$$ Now, take $ frac{ partial}{ partial theta_i}$ to evaluate the iᵗʰ entry of the gradient. Apply the chain rule to find the derivative of the RHS. . $$ frac{ partial}{ partial theta_i}G(u(t, theta)) = int_{t_{0}}^{T} left( frac{ partial g}{ partial theta_i}+ frac{ partial g}{ partial u} frac{ partial u}{ partial theta_i} right) , mathrm{d}t+ int_{t_{0}}^{T} lambda^{ intercal}(t) left( frac{d}{d theta_i} frac{ partial u}{ partial t}- left( frac{ partial f}{ partial u} frac{ partial u}{ partial theta_i}+ frac{ partial f}{ partial theta_i} right) right) , mathrm{d}t$$ extract the last integral from that expression, and split it into two. . $$ int_{t_{0}}^{T} lambda^{ intercal}(t) left( frac{d}{d theta_i} frac{ partial u}{ partial t}- left( frac{ partial f}{ partial u} frac{ partial u}{ partial theta_i}+ frac{ partial f}{ partial theta_i} right) right) , mathrm{d}t = int_{t_{0}}^{T} lambda^{ intercal}(t) left( frac{d}{d theta_i} frac{ partial u}{ partial t} right) , mathrm{d}t- int_{t_{0}}^{T} lambda^{ intercal}(t) left( frac{ partial f}{ partial u} frac{ partial u}{ partial theta_i}+ frac{ partial f}{ partial theta_i} right) , mathrm{d}t$$ For the first of those two expressions, apply integration by parts . $$ int_{t_{0}}^{T} lambda^{ intercal}(t) left( frac{d}{d theta_i} frac{ partial u}{ partial t} right) , mathrm{d}t = big[ lambda^{ intercal}(t) frac{ partial u}{ partial theta_i} big]_{t_{0}}^{T}- int_{t_{0}}^{T} left( frac{d lambda^{ intercal}(t)}{ , mathrm{d}t} frac{ partial u}{ partial theta_i} right) , mathrm{d}t$$ Now form the resultant expression . $$ begin{aligned} frac{d}{d theta_i}G(u(t, theta)) &amp; = int_{t_{0}}^{T} left( frac{ partial g}{ partial theta_i}+ frac{ partial g}{ partial u} frac{ partial u}{ partial theta_i} right) , mathrm{d}t+ left[ big[ lambda^{ intercal}(t) frac{ partial u}{ partial theta_i} big]_{t_{0}}^{T}- int_{t_{0}}^{T} left( frac{d lambda^{ intercal}(t)}{ , mathrm{d}t} frac{ partial u}{ partial theta_i} right) , mathrm{d}t- int_{t_{0}}^{T} lambda^{ intercal}(t) left( frac{ partial f}{ partial u} frac{ partial u}{ partial theta_i}+ frac{ partial f}{ partial theta_i} right) , mathrm{d}t right] % &amp; = big[ lambda^{ intercal}(t) frac{ partial u}{ partial theta_i} big]_{t_{0}}^{T}+ int_{t_{0}}^{T} left( frac{ partial g}{ partial theta_i}+ frac{ partial g}{ partial u} frac{ partial u}{ partial theta_i}- frac{d lambda^{ intercal}(t)}{ , mathrm{d}t} frac{ partial u}{ partial theta_i}- lambda^{ intercal}(t) left( frac{ partial f}{ partial u} frac{ partial u}{ partial theta_i}+ frac{ partial f}{ partial theta_i} right) right) , mathrm{d}t end{aligned}$$ Now here&#39;s the magic step. If we require: . $$ begin{aligned} frac{d lambda^{ intercal}(t)}{ , mathrm{d}t} &amp;=- frac{ partial f}{ partial u} lambda^{ intercal}(t)+ frac{ partial g}{ partial u}^{ intercal} % lambda(T) &amp;=0 end{aligned}$$ Then our expression simplifies . $$ begin{aligned} frac{d}{d theta_i}G(u(t, theta)) &amp;=- big[ lambda^{ intercal}(t) frac{ partial u}{ partial theta_i} big]_{t_{0}}^{T}+ int_{t_{0}}^{T} left( frac{ partial g}{ partial theta_i}+ frac{ partial g}{ partial u} frac{ partial u}{ partial theta_i}- left(- frac{ partial f}{ partial u} lambda(t)+ frac{ partial g}{ partial u}^{ intercal} right) frac{ partial u}{ partial theta_i}- lambda^{ intercal}(t) left( frac{ partial f}{ partial u} frac{ partial u}{ partial theta_i}+ frac{ partial f}{ partial theta_i} right) right) , mathrm{d}t % &amp; =- big[0 cdot frac{ partial u}{ partial theta_i} Big|_T- lambda^{ intercal}(t_{0}) cdot frac{ partial u}{ partial theta_i} Big|_{t_0} big]+ int_{t_{0}}^{T} left( frac{ partial g}{ partial theta_i}+ frac{ partial g}{ partial u} frac{ partial u}{ partial theta_i}+ frac{ partial f}{ partial u} frac{ partial u}{ partial theta_i} lambda^{ intercal}(t)- frac{ partial g}{ partial u} frac{ partial u}{ partial theta_i}- lambda^{ intercal}(t) frac{ partial f}{ partial u} frac{ partial u}{ partial theta_i}- lambda^{ intercal}(t) frac{ partial f}{ partial theta_i} right) , mathrm{d}t % &amp; = int_{t_{0}}^{T} left( frac{ partial g}{ partial theta_i}- lambda^{ intercal}(t) frac{ partial f}{ partial theta_i} right) , mathrm{d}t end{aligned}$$ The Adjoint Method expression for the gradient of the loss $G$ with respect to the parameters $ theta$ is $ frac{dG(u(t, theta))}{d theta_i} = int_{t_{0}}^{T} left( frac{ partial g}{ partial theta_i}- lambda^{ intercal}(t) frac{ partial f}{ partial theta_i} right) , mathrm{d}t$. The savings over the forward sensitivities gradient expression results from the fact that $ lambda^{ intercal}(t)$ is the same for every $ theta_i$. The Adjoint Method expression contains three terms: . $ frac{ partial g}{ partial theta_i} = 0$ in our case, because our loss function $G(u(t, theta)) = sum_t ( frac{ mathrm{obs}(t) - u(t, theta)}{ sigma cdot sqrt{ mathrm{obs}(t)}})^2$ contains no explicit $ theta$ term, as it might if our loss included a regularization term. | $ frac{ partial f}{ partial theta_i}$ appeared in our forward sensitivity ODEs. It hasn&#39;t changed. | That leaves us with $ lambda^{ intercal}(t)$, which we need to compute. In order to cancel terms in our derivation, we had defined $ lambda^{ intercal}(t)$ via an ODE: $$ begin{aligned} frac{d lambda^{ intercal}(t)}{dt} &amp; =- frac{ partial f}{ partial u} lambda^{ intercal}(t)+ frac{ partial g}{ partial u}^{ intercal} % lambda(T) &amp; =0 end{aligned}$$ We can solve for $ lambda^{ intercal}(t)$ by integrating this &quot;adjoint ODE&quot;, however, since the boundary condition (the &quot;initial value&quot;) occurs at the last timepoint, we need to integrate this differential expression backwards in time. $$- frac{d lambda^{ intercal}(t)}{dt} = frac{ partial f}{ partial u} lambda^{ intercal}(t)- frac{ partial g}{ partial u}^{ intercal}$$ This adjoint ODE includes yet more terms: $ frac{ partial f}{ partial u}$ and $ frac{ partial g}{ partial u}^{ intercal}$. | $ frac{ partial f}{ partial u}$ is the Jacobian, also unchanged from our forward sensitivity ODEs. Resolving the entries of this matrix requires we have $u(t, theta)$. Thus in order to integrate the adjoint ODE we will need to have already integrated the system ODE. | Finally, $ frac{ partial g}{ partial u}^{ intercal}$ is the derivative of the instantaneous loss with respect to the state. Our instantaneous loss is zero everywhere except the timepoints we observe: $$ begin{aligned} g(u(t, theta)) &amp;= left( frac{ mathrm{obs}(t) - u(t, theta)}{ sigma cdot sqrt{ mathrm{obs}(t)}} right)^2 cdot sum_{t_i in mathrm{obs}} delta(t_i-i) frac{ partial}{ partial u}g(u(t, theta)) &amp;= begin{cases} frac{2( mathrm{obs}(t) - u(t, theta))}{ sigma cdot sqrt{ mathrm{obs}(t)}} &amp; t in mathrm{obs} 0 &amp; t notin mathrm{obs} end{cases} end{aligned}$$ | . The Adjoint Method for ODEs is thus: . Integrate the system ODE $ frac{du}{dt} = f(u( theta, t), theta)$, providing $u(t, theta)$. | Integrate the adjoint ODE $- frac{d lambda^{ intercal}(t)}{dt} = frac{ partial f}{ partial u} lambda^{ intercal}(t)- frac{ partial g}{ partial u}^{ intercal}$ in reverse from $ lambda(T) = 0$ to $t_0$, providing $ lambda(t)$. | Evaluate the integral $ frac{dG(u(t, theta))}{d theta_i} = int_{t_{0}}^{T} left( frac{ partial g}{ partial theta_i}- lambda^{ intercal}(t) frac{ partial f}{ partial theta_i} right)dt$ | Inspecting this procedure, we notice the integral in step 3 can be computed concurrently with step 2 for some time-savings: $ frac{dG(u(t, theta))}{d theta_i} = int_{T}^{t_{0}} left(- frac{ partial g}{ partial theta_i}+ lambda^{ intercal}(t) frac{ partial f}{ partial theta_i} right)dt$. . Let&#39;s implement it. . # define gradient_via_euler_adjoint_method, integrate_euler_adjoint() def gradient_of_loss_via_euler_adjoint_method(u_t, θ_t): λ_t = integrate_euler_adjoint(u_t, θ_t) return λ_t[grad_cols].iloc[0].to_dict(), λ_t, u_t λ_cols = [&#39;λ_S&#39;,&#39;λ_E&#39;,&#39;λ_ES&#39;,&#39;λ_P&#39;] grad_cols = [&#39;k_on&#39;,&#39;k_off&#39;,&#39;k_cat&#39;,&#39;k_uncat&#39;] def integrate_euler_adjoint(u, θ_t, dt=dt, steps=steps): k_on, k_off, k_cat, k_uncat, *args = θ_t.values() λ = np.zeros((1, 4)) λ_traj = [] grad = np.zeros((4, 1)) grad_traj = [] for t, (S, E, ES, P) in u[::-1].iterrows(): λ_traj.append(λ[0].copy()) grad_traj.append(grad.T[0].copy()) f_u = f_u_Jacobian(S, E, ES, P, k_on, k_off, k_cat, k_uncat) dλ = λ @ f_u if t in observations.index: g_u_P = 2*(observations.loc[t] - u.loc[t, &#39;P&#39;]) dλ = dλ - np.array([[0, 0, 0, g_u_P]]) λ += dλ * dt grad += np.array([np.dot(λ, f_θ(S, E, ES, P))[0] for f_θ in [f_k_on, f_k_off, f_k_cat, f_k_uncat]]) * dt return pd.DataFrame(np.concatenate((λ_traj, grad_traj), axis=1), columns=λ_cols+grad_cols, index=u.index[::-1]).iloc[::-1] . # compute the first gradient of loss via our euler adjoint_method, from θ_0 θ_0[&#39;k_ms&#39;] = k_ms(θ_0) θ_0[&#39;k_mp&#39;] = k_mp(θ_0) start = time.process_time() grad_0, λ_0, u_0 = gradient_of_loss_via_euler_adjoint_method(integrate_euler_full(θ_0), θ_0) euler_time = time.process_time() - start . # define plot_adjoint() def plot_adjoint(u, λ): plt.rcParams[&#39;figure.figsize&#39;] = [12, 12] fig, axs = plt.subplots(3, 1, sharex=&#39;col&#39;) u.plot.line(ax=axs[0], color=color(u.columns)) traj_scipy_full.plot.line(ax=axs[0], lw=0.5, linestyle=&#39;--&#39;, legend=False, color=color(traj_scipy_full.columns)) observations.plot.line(ax=axs[0], marker=&#39;o&#39;, lw=0, color=color([&#39;P&#39;]), legend=False) λ[λ_cols].plot.line(ax=axs[1], color=color([c.split(&#39;λ_&#39;)[1] for c in λ_cols])) λ[grad_cols].plot.line(ax=axs[2], color=color(grad_cols)) λ[grad_cols].iloc[[0]].plot.line(ax=axs[2], marker=&#39;D&#39;, lw=0, legend=False, color=color(grad_cols)) for ax in axs: fig_style(ax) axs[1].set_ylabel(&#39;&#39;) axs[2].set_ylabel(&#39;&#39;) # plt.tight_layout() . plot_adjoint(u_0, λ_0) . We can check that our gradient computation via the Adjoint Method is correct by comparing it to the Finite Differences approximation of the gradient: . def cosine_distance(a, b): return 1 - np.dot(a, b)/(np.linalg.norm(a)*np.linalg.norm(b)) grad_0_fd = pd.Series(finite_differences(None, θ_0)).iloc[0:4] grad_0_adjoint_euler = pd.Series(grad_0) cosine_distance(grad_0_fd, grad_0_adjoint_euler) . 1.133973482914108e-05 . That&#39;s good news, however, . f&#39;A single step of the Adjoint Method with the naïve python Euler method takes {round(euler_time, 2)}s&#39; . &#39;A single step of the Adjoint Method with the naïve python Euler method takes 57.91s&#39; . As before, we would like to use scipy to evaluate the integrals needed to compute the gradient. This time we run into two new issues: . One reason the scipy integrate package&#39;s integrators are faster is because they use adaptive timestepping methods. In our Euler Methods, we set out timestep size dt at the outset, which remains constant throughout integration, meaning our resulting trajectory $u(t, theta)$ is really a vector of values of $u$ defined at uniformly-spaced values of $t$. Adaptive timestepping integrators yield trajectories supported on non-uniformly-spaced values of $t$, which we won&#39;t know prior to integration. If we integrate $ frac{du}{dt}$ with adaptive timestepping, and subsequently $- frac{d lambda}{dt}$, the resultant trajectories will not be supported on the same values of $t$. We can work around this issue by interpolating the trajectory of $u$ for values of $t$ between the $t$ the solution is defined at. . | Another issue arises from the fact that scipy&#39;s main integration method is not able to integrate differential equations with jump discontinuities of the sort we have in our Adjoint ODE with finite observations (as in the second plot above). Thankfully, Julia&#39;s feature-rich DifferentialEquations.jl library has bindings to python via diffeqpy, and does support this use case. . | . # import Julia&#39;s DifferentialEquations.jl python bindings # import julia # julia.install() # import diffeqpy # diffeqpy.install() from diffeqpy import de plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] . # define integrators to implement the Adjoint Method with Julia&#39;s DifferentialEquations.jl via diffeqpy def dy_julia(dy, y, p, t): # y ordered S,E,ES,P # p is ordered k_on,k_off,k_cat,k_uncat dy[0] = p[1] * y[2] - p[0] * y[1] * y[0] dy[1] = p[1] * y[2] - p[0] * y[1] * y[0] + p[2] * y[2] - p[3] * y[1] * y[3] dy[2] = p[0] * y[1] * y[0] - p[1] * y[2] - p[2] * y[2] + p[3] * y[1] * y[3] dy[3] = p[2] * y[2] - p[3] * y[1] * y[3] def integrate_julia_full(kinetic_params, initial_conditions=default_initial_conditions, dt=dt, steps=steps): y0 = list(initial_conditions.values()) t_span = (0, dt*steps) prob = ode.ODEProblem(dy_julia, y0, t_span, [*kinetic_params.values()]) try: sol = ode.solve(prob, ode.Tsit5(), tstops=list(observations.index)) return pd.DataFrame(sol.u, index=sol.t, columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;]) except: return pd.DataFrame(columns=[&#39;S&#39;, &#39;E&#39;, &#39;ES&#39;, &#39;P&#39;]) def dλ_julia(dλ, λ, p, t): t = 0.5-t u_t = p[0](t) f_u = f_u_Jacobian(*u_t, *p[1:]) dλ[0:4] = λ[0:4] @ f_u dλ[4:8] = np.array([np.dot(λ[0:4], f_θ(*u_t)) for f_θ in [f_k_on, f_k_off, f_k_cat, f_k_uncat]]).flatten() def g_u(integrator): t = np.round(0.5-integrator.t, 10) u_t = integrator.p[0](t) g_u_P = 2*(observations.loc[t] - u_t[3]) integrator.u[3] -= g_u_P def integrate_adjoint_julia(u_t_interpolant, θ_t, dt=dt, steps=steps): y0 = np.zeros(8) t_span = (0, dt*steps) prob = de.ODEProblem(dλ_julia, y0, t_span, [u_t_interpolant, *θ_t.values()]) try: sol = de.solve(prob, de.Tsit5(), tstops=list(observations.index), callback=de.PresetTimeCallback(list(observations.index), g_u)) return pd.DataFrame(sol.u, index=0.5-sol.t, columns=λ_cols+grad_cols).iloc[::-1] except: return pd.DataFrame(columns=λ_cols+grad_cols) def gradient_of_loss_via_julia_adjoint_method(u_t, θ_t): u_t_interpolant = scipy.interpolate.interp1d(u_t.index.values, u_t.values, kind=&#39;linear&#39;, axis=0, copy=False) λ_t = integrate_adjoint_julia(u_t_interpolant, θ_t) return λ_t[grad_cols].iloc[0].to_dict(), λ_t, u_t . # test our Julia-based Adjoint Method θ_0 = {k:v for k,v in θ_0.items() if k in [&#39;k_on&#39;,&#39;k_off&#39;,&#39;k_cat&#39;,&#39;k_uncat&#39;]} start = time.process_time() grad_0_adjoint_julia, λ_0_julia, u_0_julia = gradient_of_loss_via_julia_adjoint_method(integrate_julia_full(θ_0), θ_0) julia_time = time.process_time() - start plot_adjoint(u_0_julia, λ_0_julia) . We recapitulate the results from our Euler method. . julia_adjoint_grad_0 = pd.Series(grad_0_julia) cosine_distance(grad_0_fd, grad_0_adjoint_julia) . 1.7326465229228205e-06 . f&#39;A single step of the Adjoint Method with julia takes {round(julia_time, 2)}s&#39; . &#39;A single step of the Adjoint Method with julia takes 1.07s&#39; . Now we can conceive of optimizing kinetic parameters with the adjoint method. . optimization_record = optimize_by_gradient_descent(θ_0, integrate=integrate_julia_full, gradient=gradient_of_loss_via_julia_adjoint_method) plot_optimization_trajectory(optimization_record) . In principle we could use the adjoint method to compute derivatives in log space as well, but we&#39;ll &quot;leave that as an exercise for the reader&quot;. . Further Reading . We have implemented the elementary techniques from the two families of approaches for ODE parameter inference. More advanced approaches from each family bear mentioning. . Advanced Bayesian Approaches . Bayesian approaches estimate a posterior distribution over the parameters to infer. . There are more practical and scalable variants of the inference by sampling approach. We implemented Markov-Chain Monte Carlo with a Metropolis-Hastings update criterion, which is hardly ever used in practice due to its simplemindedness. . Hamiltonian Monte Carlo is used in practice for many inference tasks and is a default in most probabilistic programming languages. I would recommend A Conceptual Introduction to Hamiltonian Monte Carlo. | Gibbs Sampling is another popular approach better suited in cases in which there are a greater number of parameters to infer. | Many MCMC variants have been proposed. Here is a visualization of some of them. | . | A newer approach to estimate the posterior distribution is not driven by sampling but instead on optimizing the parameters of a surrogate distribution. This approach is named Variational Inference. As an introduction I would recommend these lecture notes. Many VI variants have been proposed, but of particular note are SVI and ADVI. . | . Advanced Frequentist Approaches . The frequentist approach is to optimize our parameters against our Loss function. We implemented Gradient Descent with Momentum using gradients computed via Forward Sensitivities and the Adjoint Method. There are more practical and scalable variants of each of those parts. . There exist many algorithms which use gradients to descend on a loss surface. Beyond momentum we could have used any of the gradient-based opimtization procedures, often applied to optimize the parameters of Neural Networks (some of which are visualized here). Alternatively, for a few more evaluations of the ODE and the loss, we could have implemented a Line Search, which may have worked quite well on our relatively simple loss surface. | Beyond gradients, optimization can be dramatically accelerated by the evaluation of local second derivatives of the loss. Newton&#39;s method iteratively approximation the loss with a quadratic (a second-order taylor expansion) and steps directly to the bottom of the paraboloid at each iteration, yielding much greater convergence rates. When the number of parameters is large, and evaluation of the full Hessian (the 2ⁿᵈ derivative) at each iteration is intractable, pseudo-second-order optimization techniques such as BFGS (and the more practical L-BFGS) approximate the curvature of the loss surface from a sequence of gradients, and can work very well in practice. | Besides optimization techniques, the problem setting may admit alternate formulations of the optimization problem. Trajectory Optimization techniques may be brought to bear, particularly Multiple Shooting and Collocation methods. | . Implementations . This blog post is pedagogical. Proper implementations of these techniques should be used in practice. . The SciML ecosystem in Julia offers the best tooling I&#39;ve found for these problems. DiffEqFlux.jl offers implementations of many of the frequentist approaches, and Turing.jl offers implementations of the Bayesian approaches. Both rely on DifferentialEquations.jl. [Disclaimer: I have the privilege of working with the people who built this tooling.] | pyPESTO appears to be the best-maintained python toolchain for parameter estimation for biological systems models. There may be good python tooling I&#39;m not aware of (reach out!) especially originating from the Neural ODE literature, which has introduced the adjoint method to the Machine Learning community. | . Conclusions . Having learned to infer the parameters of ODE models, let&#39;s now take a step back and ask whether we have accomplished something meaningful. . Do we know the right model? . Let us not pretend to the world that we will eventually have predictive models of biology in the same way we have predictive models of airplanes. . — Jeremy Gunawardena . Were we to dispense a specific number of enzyme and substrate molecules into a fixed volume of continuously mixed solvent at a known temperature, pH, and ionic concentration, then the Law of Mass Action we assumed at the outset would hold, and the form of our differential equation model would apply. However, as Lucas Pelkmans writes &quot;solution chemistry does not apply to cells, in which everything is inhomogeneous, crowded, out-of-equilibrium, and unmixed.&quot; In this post, we explored techniques to fit the parameters of a chosen differential equation model, but determining the right model to begin with may be the greater challenge. For example, in the case of enzymatic catalysis, the effective concentration of enzyme and substrate may vary substantially inside a single cell, facilitated by phase separation (see The role of liquid–liquid phase separation in regulating enzyme activity and A new phase for enzyme kinetics). This fact is incompatible with the mass-action model we started out with, as our kinetic parameters would appear to be functions of the concentrations of various intracellular metabolites rather than constants. Enzyme kinetic parameters are already functions of the pH, salt, and temperature conditions of the reaction environment, which is likely the cause for the inconsistent estimates of enzymes&#39; kinetic parameters in databases such as BRENDA. Mathematical models from analytical chemistry may simply be inadequate to address the relevant phenomena in biology, which leads us to ask: what are the right models to describe these phenomena? . Further Reading: . Models in biology: ‘accurate descriptions of our pathetic thinking’ | Some lessons about models from Michaelis and Menten | . Is a wrong model useful? . All models are wrong, but some are useful. . — George Box . Putting aside the former question, in this work, our synthetic data were explicitly generated from the Mass Action rate equations, with fixed kinetic parameters, not a biological system. Even still, our inference techniques did not recover the original kinetic parameters. Instead, they found alternate kinetic parameters which predicted the observations nearly as well. When we visualized the loss surface, we discovered a region of parameter space able to predict the observed data. This phenomenon has been called &quot;Practical Identifiability&quot; (or lack thereof) and &quot;Model Sloppiness&quot;, and may be addressible by model order reduction and parameter space compression) techniques. However, we should ask ourselves why we are concerned that the parameters of a perfectly predictive model are not unique. This question gets at the heart of scientific modeling. Our goal is to arrive at a model in which the variables and parameters have a tight correspondence with the physical phenomena they represent. If we achieve that, then our model will be general, and accurately predict the outcomes of interventions not previously observed -- it will extrapolate. Furthermore, it will be interpretable, which makes it easier to design interventions. For the time being, highly predictive black-box models are missing the hallmarks of traditional scientific models. . A highly-predictive differential equation model with aphysical parameters is only marginally more useful than an overparameterized black-box model. In the future, we will aim for models composed of physically-salient variables and parameters. . Further Reading: . The &quot;Norvig - Chomsky debate&quot; | . Is a large model useful? . With four parameters I can fit an elephant, and with five I can make him wiggle his trunk. . — John von Neumann . We alluded to the long-term aspiration of mathematical biologists to model entire cells. Cells contain millions of chemical species, so a Chemical Reaction Network model of the sort we used here would entail millions of variables, millions of reaction equations, and millions more kinetic parameters. To a physicist, a model should reveal the essence of a system, and parameters are best restricted or avoided altogether. Would a million-parameter ODE model be any more interpretable or insightful than a million parameter neural network? . I believe that it would. A large physical model is an unusual thing today:models are mostly either physical, elegant, and concise ($f = ma$), or statistical, highly predictive, and overparameterized ($f = mathrm{NN}_{ theta}( cdot)$). I contend that large physical models provide many of the advantages of each of the former categories, namely, they may be highly predictive of complex phenomena yet interpretably so. The best example of a very large, very detailed, very useful model is Google Maps. The overwhelming quantity of data in Google&#39;s model of the world is useful in large part thanks to the exceptional interactive data visualization tool they provide to browse the model. The cell not only needs modeling, but representations and visualizations to explore and interrogate that model. . Is (math) modeling biology useful? . The best material model for a cat is another, or preferably the same cat. . — Arturo Rosenblueth and Norbert Wiener . If you speak to a biologist about a &quot;model&quot;, they may assume you mean a mouse, not a system of equations. The shared use of the same term is hardly coincidental:both approaches offer surrogates to the systems we seek to understand. We should ask ourselves why to invest in mathematical models of biological systems rather than biological models of those systems. In particular, experimentalists continue to develop techniques to precisely perturb and broadly measure biological systems. If we can perfectly control the inputs and measure the outputs of a biological model, why bother with a mathematical model? . This is a serious question in light of the relative advantages of biological models, which include: . Accuracy: we continue to discover new principles governing the behavior of biological matter, meaning that even a mathematical model consolidating the entirety our present understanding of cells would not be faithful to the real thing. Meanwhile, it is tautological that cells model themselves with perfect accuracy, even if the biochemical mechanisms mapping inputs to outputs are obscure. | Cost: cells &quot;compute&quot; their destinies with extremely little energy input, whereas large mathematical models require massive computing infrastructure and megawatts of power. | Parallelism: Experimentalists have developed technologies to interrogate biology at the level of the single cell, in multiplex. It is now possible to run millions of variants of an experiment simultaneously. That scale is not feasible in silico. | . Despite those, mathematical models confer their own advantages, which justify their pursuit: . Timeliness: In silico experiments are quick to set up, and yield answers on a timescale of minutes rather than weeks. | Interpretability: The entirety of the mechanism mapping inputs to outputs is transparent to us, by default. | Reproducibility: Biological models often behave in accordance with covariates we do not measure or control. We expect mathematical models running on deterministic computers to be perfectly reproducible. | Theory: A rich body of scholarship in optimal design &amp; control theory can be brought to bear against a mathematical model, as well as many other mathematical frameworks for the analysis of differential equations from the physical sciences. | Learning from mistakes: Insofar as mathematical models fail to predict the behavior of a system, they demonstrate the inaccuracies of their assumptions and ours. | . Ultiumately, we pursue mathematical models because unlike a mouse model or a statistical model, the mathematical model alone represents understanding of the phenomenon. We apprehend the world as causes and effects, which we have formalized in the language of Differential Equations. True human understanding of the cell will be reached once we have a complete mathematical model. . Further Reading: . Theory in Biology: Figure 1 or Figure 7? | . Related Work . Fabian Fröhlich: Scalable Parameter Estimation for Genome-Scale Biochemical Reaction Networks | Christopher R. Myers: Zen and the Art of Parameter Estimation in Systems Biology | Demetri Pananos: Gradient Descent for ODEs | .",
            "url": "https://alexlenail.me/back_of_my_envelope/2021/06/23/Enzyme-Kinetic-Parameter-Inference.html",
            "relUrl": "/2021/06/23/Enzyme-Kinetic-Parameter-Inference.html",
            "date": " • Jun 23, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Intuition for Second Order Partial Derivatives and the Hessian Matrix",
            "content": "# imports # using Plots; plotlyjs() using PlotlyJS # from IPython.display import HTML # HTML(fig.to_html()) # where fig = plotly.plot(...) . Unable to load WebIO. Please make sure WebIO works for your Jupyter client. For troubleshooting, please see the WebIO/IJulia documentation. . The Hessian matrix appears in the optimization literature, but the intuition for how the Hessian and its inverse transform vectors is opaque to me. Let&#39;s review second order partial derivatives, and then try to build intuition for the Hessian matrix. . For the purpose of this intuition-building exercise, we&#39;ll work with functions $ Reals^2 mapsto Reals^1$. I&#39;ll also use partial derivative notations $ frac{ partial}{ partial y} f(x, y) = frac{ partial f}{ partial y} = f_y$ interchangeably. . 1. Partial Derivatives . Take the $ Reals^2 mapsto Reals^1$ function $f(x, y) = x^2 + 2y^2$. . A partial derivative is the change in an &quot;output&quot; variable (in our case, $f$) with respect to infinitesimal changes in an &quot;input&quot; variable (in our case, $x$ or $y$). For example, $ frac{ partial}{ partial y} f(x, y) = 4y$, which is to say, for any point in the domain, moving infinitsimally in the y direction changes f propotional to 4 times the y coordinate of the starting point point. . f(x, y) = x^2 + 2y^2 x = 6 xlim=[-10, x] ylim=[-10, 10] xs = LinRange(xlim..., 101) ys = LinRange(ylim..., 101) zs = [f(x, y) for x in xs, y in ys] y = 4 dy = 4 f_y(y) = 4y . f_y (generic function with 1 method) . # built interactive plot traces = GenericTrace[] push!(traces, PlotlyJS.surface(x=xs, y=ys, z=zs, showscale=false, opacity=0.8)) push!(traces, PlotlyJS.surface(x=[x, x+0.001], y=ylim, z=[[maximum(zs), minimum(zs)] [maximum(zs), minimum(zs)]], showscale=false, colorscale=&quot;Greys&quot;, opacity=0.2)) push!(traces, PlotlyJS.scatter3d(x=fill(x, size(ys)), y=ys, z=[x^2 + 2y^2 for y in ys], showlegend=false, mode=&quot;lines&quot;, line=attr(color=&quot;red&quot;, width=2))) for y in ys[1:5:end] push!(traces, PlotlyJS.scatter3d(x=fill(x, 2),y=[y-dy, y+dy], z=[f(x,y)-f_y(y)*dy, f(x,y)+f_y(y)*dy], visible=false, showlegend=false, mode=&quot;lines&quot;, line=attr(color=&quot;orange&quot;, width=5))) end scene = attr( xaxis = attr(range=[-10,10]), yaxis = attr(range=[-10,10]), zaxis = attr(range=[-50,300]), aspectratio = attr(x=1, y=1, z=1) ) layout = Layout( sliders=[attr( steps=[ attr( label=round(y, digits=2), method=&quot;update&quot;, args=[attr(visible=[fill(true, 3); fill(false, i-1); true; fill(false, 101-i)])] ) for (i, y) in enumerate(ys[1:5:end]) ], active = y, currentvalue_prefix=&quot;x = 6, y = &quot;, # pad_t=40 )], scene = scene, ) p = PlotlyJS.plot(traces, layout) . We can plot the function $f_y$ for every starting point: . # plot partial derivative of f with respect to y, f_y traces = GenericTrace[] push!(traces, PlotlyJS.surface(x=xs, y=ys, z=zs, showscale=false, opacity=0.8)) push!(traces, PlotlyJS.surface(x=ylim, y=ylim, z=[[0, 0] [0, 0]], showscale=false, colorscale=&quot;Greys&quot;, opacity=0.3)) push!(traces, PlotlyJS.surface(x=xs, y=ys, z=[f_y(y) for x in xs, y in ys], showscale=false)) plot(traces, Layout(scene=scene)) . We can do the exact same exercise with $f_x$: . f_x(x) = 2x . f_x (generic function with 1 method) . traces = GenericTrace[] push!(traces, PlotlyJS.surface(x=xs, y=ys, z=zs, showscale=false, opacity=0.8)) push!(traces, PlotlyJS.surface(x=ylim, y=ylim, z=[[0, 0] [0, 0]], showscale=false, colorscale=&quot;Greys&quot;, opacity=0.3)) push!(traces, PlotlyJS.surface(x=xs, y=ys, z=[f_x(x) for x in xs, y in ys], showscale=false)) plot(traces, Layout(scene=scene)) . So the way the second order partial derivative is defined is as a composition, e.g. $f_{xx} = frac{ partial}{ partial x} left( frac{ partial}{ partial x} left( f(x, y) right) right) $. As second derivatives do, it captures the [change in the [change in the [output variable]]] with respect to infinitesimal changes in the input variable. This notion coincides with the curvature of the function: a positive second derivative at a particular point indicates that the output variable is concave up at a that point, and a negative second derivative indicates the output variable is concave down at that point. . In the case of the function we&#39;ve chosen, $f_{xx} = 2$ and $f_{yy} = 4$ which informs us that $f$ is concave up everywhere in the domain, which makes sense from looking at the plot. . However, we&#39;ve omitted the &quot;mixed&quot; partial derivatives here: $f_{xy}$ and $f_{yx}$. We can compute them to both be zero for this particular function. What does that tell us? . # plot partial derivative of f with respect to y, f_y traces = GenericTrace[] push!(traces, PlotlyJS.surface(x=ylim, y=ylim, z=[[0, 0] [0, 0]], showscale=false, colorscale=&quot;Greys&quot;, opacity=0.3)) push!(traces, PlotlyJS.surface(x=xs, y=ys, z=[f_y(y) for x in xs, y in ys], showscale=false)) push!(traces, PlotlyJS.scatter3d(x=[-7, 4], y=[5, 5], z=[f_y(5), f_y(5)], showlegend=false, mode=&quot;lines&quot;, line=attr(color=&quot;orange&quot;, width=5))) p = plot(traces, Layout(scene=scene)) . It&#39;s clear from the graph above that infinitesimal changes in $x$ do not influence the value of $f_y$. Interpreting $f_{yx} = frac{ partial}{ partial x} left( frac{ partial}{ partial y} left( f(x, y) right) right)$ as $ frac{ partial}{ partial x} f_y $, it&#39;s clear $f_{yx} = 0$. But how can we interpret that in terms of the original function f? . # built interactive plot traces = GenericTrace[] push!(traces, PlotlyJS.surface(x=xs, y=ys, z=zs, showscale=false, opacity=0.8)) for x in xs[1:5:end] push!(traces, PlotlyJS.surface(x=[x, x+0.001], y=ylim, z=[[maximum(zs), minimum(zs)] [maximum(zs), minimum(zs)]], visible=false, showscale=false, colorscale=&quot;Greys&quot;, opacity=0.2)) push!(traces, PlotlyJS.scatter3d(x=fill(x, size(ys)), y=ys, z=[x^2 + 2y^2 for y in ys], visible=false, showlegend=false, mode=&quot;lines&quot;, line=attr(color=&quot;red&quot;, width=2))) push!(traces, PlotlyJS.scatter3d(x=fill(x, 2),y=[y-dy, y+dy], z=[f(x,y)-f_y(y)*dy, f(x,y)+f_y(y)*dy], visible=false, showlegend=false, mode=&quot;lines&quot;, line=attr(color=&quot;orange&quot;, width=5))) end layout = Layout( sliders=[attr( steps=[ attr( label=round(x, digits=2), method=&quot;update&quot;, args=[attr(visible=[fill(true, 1); fill(false, 3*(i-1)); fill(true, 3); fill(false, 3*(101-i))])] ) for (i, x) in enumerate(xs[1:5:end]) ], active = x, currentvalue_prefix=&quot;x = 6, y = &quot;, # pad_t=40 )], scene = scene, ) p = PlotlyJS.plot(traces, layout) . Here is where we find the intuition. The mixed second order partial derivatives tell us how the slope along one coordinate axis changes as we move infinitesimally along an orthogonal coordinate axis. In the function we&#39;ve chosen, the slice of the graph at any x coordinate is the same parabola (just vertically offset by $x^2$) and thus has the same slope for any y. The mixed second order partial derivatives could thus be said to relay information about the &quot;pucker&quot; of the graph of the function (I made that name up) which is the concavity of the graph with respect to two coordinate axes. . In order to see this more clearly, let&#39;s add a mixed term to our function, to produce non-zero mixed second order partial derivatives: . g(x, y) = x^2 + 2y^2 - x*y zs = [g(x, y) for x in xs, y in ys] g_x(x, y) = 2x - y g_y(x, y) = 4y - x . g_y (generic function with 1 method) . # built interactive plot traces = GenericTrace[] push!(traces, PlotlyJS.surface(x=xs, y=ys, z=zs, showscale=false, opacity=0.8)) for x in xs push!(traces, PlotlyJS.surface(x=[x, x+0.001], y=ylim, z=[[maximum(zs), minimum(zs)] [maximum(zs), minimum(zs)]], visible=false, showscale=false, colorscale=&quot;Greys&quot;, opacity=0.2)) push!(traces, PlotlyJS.scatter3d(x=fill(x, size(ys)), y=ys, z=[g(x, y) for y in ys], visible=false, showlegend=false, mode=&quot;lines&quot;, line=attr(color=&quot;red&quot;, width=2))) push!(traces, PlotlyJS.scatter3d(x=fill(x, 2),y=[y-dy, y+dy], z=[g(x,y)-g_y(x, y)*dy, g(x,y)+g_y(x, y)*dy], visible=false, showlegend=false, mode=&quot;lines&quot;, line=attr(color=&quot;orange&quot;, width=5))) end layout = Layout( sliders=[attr( steps=[ attr( label=round(x, digits=2), method=&quot;update&quot;, args=[attr(visible=[fill(true, 1); fill(false, 3*(i-1)); fill(true, 3); fill(false, 3*(101-i))])] ) for (i, x) in enumerate(xs) ], active = x, currentvalue_prefix=&quot;x = 6, y = &quot;, # pad_t=40 )], scene = scene, ) p = PlotlyJS.plot(traces, layout) . The slope along the y coordinate changes as we vary x. This function is &quot;puckered&quot; up. . Note: For twice-continuously differentiable functions, $f_{xy}$ = $f_{yx}$. This is called the symmetry property of second derivatives. And leads to a symmetric Hessian matrix. We&#39;ll assume that property of our functions throughout. | . 2. Hessian Matrix . Having now built intuition for each of the entries in the Hessian Matrix, we can begin to build intuition for the matrix itself: . $$ bold{H}_f = begin{bmatrix} frac{ partial^2 f}{ partial x^2} &amp; frac{ partial^2 f}{ partial x partial y} frac{ partial^2 f}{ partial y partial x} &amp; frac{ partial^2 f}{ partial y^2} end{bmatrix} = begin{bmatrix} f_{xx} &amp; f_{yx} f_{xy} &amp; f_{yy} end{bmatrix}$$In some sense, the Hessian is a matrix-valued function we can evaluate for any point $ bold{v_0} = begin{bmatrix} x_0 y_0 end{bmatrix}$ in the domain of $f$: . $$ bold{H}_f( bold{v_0}) = begin{bmatrix} f_{xx}( bold{v_0}) &amp; f_{yx}( bold{v_0}) f_{xy}( bold{v_0}) &amp; f_{yy}( bold{v_0}) end{bmatrix}$$The Hessian shows up in the quadratic approximation (second order Taylor expansion) of multivariate functions around a particular point $ bold{v_0}$: . $$ Q_f( bold{v_0}) = color{green} f( bold{v_0}) color{black} + color{blue} nabla_f( bold{v_0}) cdot ( bold{v} - bold{v_0}) color{black} + color{indigo} {1 over 2}( bold{v} - bold{v_0})^ intercal left[ bold{H}_f( bold{v_0}) right] ( bold{v} - bold{v_0})$$ . And we might ask: how does this matrix scale $( bold{v} - bold{v_0})$? Let&#39;s try to build some intuition: . Suppose we multiply some vector against that Hessian Matrix: . $$ begin{bmatrix} f_{xx}( bold{v_0}) &amp; f_{yx}( bold{v_0}) f_{xy}( bold{v_0}) &amp; f_{yy}( bold{v_0}) end{bmatrix} cdot begin{bmatrix} x y end{bmatrix} = begin{bmatrix} f_{xx} cdot x + f_{xy} cdot y f_{yy} cdot y + f_{yx} cdot x end{bmatrix} = $$$$ begin{bmatrix} ( text{the rate of change of the slope in the x direction as you move in the x direction} ) ( text{a distance in the x direction} ) + ( text{the rate of change of the slope in the x direction as you move in the y direction} ) ( text{a distance in the y direction} ) ( text{the rate of change of the slope in the y direction as you move in the y direction} ) ( text{a distance in the y direction} ) + ( text{the rate of change of the slope in the y direction as you move in the x direction} ) ( text{a distance in the x direction} ) end{bmatrix} = $$$$ begin{bmatrix} text{the approximate slope in the x direction at the distance x from }x_0 text{the approximate slope in the y direction at the distance y from }y_0 end{bmatrix} = $$ $$ text{what a second-order approximation of } f text{ suggests the gradient is at } bold{v_0} + begin{bmatrix} x y end{bmatrix} $$ . However, let&#39;s note that the quadratic approximation of $f$ includes as quadratic form $( bold{v} - bold{v_0})^ intercal left[ bold{H}_f( bold{v_0}) right] ( bold{v} - bold{v_0})$, not just a matrix-vector product. Applying this second product operation results in a scalar, which is the change in the value of the function as a result of extrapolating the (second-order) curvature of the function at $ bold{v_0}$ out towards $ bold{v} - bold{v_0}$. . 3. Newton Method . Newton&#39;s method for optimization is an iteration of . forming the quadratic approximation $Q_f( bold{v_0})$ of a function around the current point. | jumping to the min/max of the paraboloid approximation for the next iteration. | . This requires us to identify the min/max of the second-order approximation of $f$. Recall, the quadratic approximation (second order taylor expansion) of $f$ at a particular point $ bold{v_0}$ is . $$ Q_f( bold{v_0}) = color{green} f( bold{v_0}) color{black} + color{blue} nabla_f( bold{v_0}) cdot ( bold{v} - bold{v_0}) color{black} + color{indigo} {1 over 2}( bold{v} - bold{v_0})^ intercal left[ bold{H}_f( bold{v_0}) right] ( bold{v} - bold{v_0})$$ . Searching for the extrema of this approximation, we can take $ nabla left[ Q_f(v_0) right] = 0$. . $ nabla left[ color{green} f( bold{v_0}) color{black} right] = 0$ | $ nabla left[ color{blue} nabla_f( bold{v_0}) cdot ( bold{v} - bold{v_0}) color{black} right] = nabla_f( bold{v_0})$ | $ nabla left[ color{indigo} {1 over 2}( bold{v} - bold{v_0})^ intercal left[ bold{H}_f( bold{v_0}) right] ( bold{v}- bold{v_0}) color{black} right] = {1 over 2} left( left[ bold{H}_f( bold{v_0}) right] bold{v}+ left[ bold{H}_f( bold{v_0}) right]^ intercal right) bold{v}$ | . We can simplify ${1 over 2} left( left[ bold{H}_f( bold{v_0}) right] bold{v}+ left[ bold{H}_f( bold{v_0}) right]^ intercal right) bold{v}$ further, because $ left[ bold{H}_f( bold{v_0}) color{black} right] = left[ bold{H}_f( bold{v_0}) right]^ intercal$, because of the symmetry property of second derivatives, so this expression simplifies to ${1 over 2} left( 2 left[ bold{H}_f( bold{v_0}) right] right) bold{v} = left[ bold{H}_f( bold{v_0}) right] bold{v}$. . So all together, $ nabla left[ Q_f( bold{v_0}) right] = color{blue} nabla_f( bold{v_0}) color{black} + color{indigo} left[ bold{H}_f( bold{v_0}) right] bold{v}$. . Well, $ nabla_f( bold{v_0}) + left[ bold{H}_f( bold{v_0}) right] bold{v} = 0$ when: . $$ begin{aligned} left[ bold{H}_f( bold{v_0}) right] bold{v} &amp;= - nabla_f( bold{v_0}) bold{v} &amp;= - left[ bold{H}_f( bold{v_0}) right]^{-1} cdot nabla_f( bold{v_0}) end{aligned} $$So $ bold{v}$ is the vector which denotes the extremum of the quadratic approximation of $f$ around $ bold{v_0}$. The familiar Newton method expression pops out of our above derivation: . $$ bold{v_{k+1}} = bold{v_k} - left[ bold{H}_f( bold{v_k}) right]^{-1} nabla_f( bold{v_k})$$ . And now we know that this expression which seemed to come out of nowhere $ left[ bold{H}_f( bold{v_k}) right]^{-1} nabla_f( bold{v_k})$ including an inverse Hessian (!!) is really just the $ bold{v}$ which solves $ nabla left[ Q_f(v_0) right] = 0$. . References . Khan Academy: Second-Order Partial Derivatives | Walter Schreiner&#39;s course notes: intuition for second order partial derivatives | Khan Academy: The Hessian | Khan Academy: Quadratic Approximations | Kris Hauser&#39;s course notes: derivation of Newton&#39;s Method (especially page 4) | .",
            "url": "https://alexlenail.me/back_of_my_envelope/2021/05/18/Hessian-Intuition.html",
            "relUrl": "/2021/05/18/Hessian-Intuition.html",
            "date": " • May 18, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "Orthogonal Functions",
            "content": "# imports import numpy as np import pandas as pd import matplotlib.pyplot as plt import scipy.stats %matplotlib inline plt.rcParams[&#39;figure.figsize&#39;] = [12, 5] plt.rcParams[&#39;figure.dpi&#39;] = 140 π = np.pi exp = np.exp sin = np.sin cos = np.cos sqrt = np.sqrt . Fourier Basis . grid = 200 domain = [0, 2*π] dx = (domain[1]-domain[0])/grid grid = np.linspace(*domain, grid) def fourier(k, x): return sin(k*x)+cos(k*x) . n = 5 basis = pd.DataFrame({k: fourier(k, grid) for k in range(1,n)}, index=grid) ax = basis.plot.line(lw=0.4, xlim=domain) ax.axhline(0, c=&#39;black&#39;, lw=&#39;0.3&#39;) . &lt;matplotlib.lines.Line2D at 0x136a4e890&gt; . from scipy import integrate def compare_two(i, j): product = pd.Series(basis[i]*basis[j], name=&#39;product&#39;) product = pd.DataFrame([basis[i], basis[j], product]).T ax = product.plot.line(lw=0.5, color=[&#39;red&#39;, &#39;blue&#39;, &#39;purple&#39;]) ax.fill_between(grid, product[&#39;product&#39;], alpha=0.1) return integrate.trapz(product[&#39;product&#39;], x=product.index) . print(&#39;integral =&#39;, np.round(compare_two(3,4), 4)) . integral = -0.0 . &quot;fourier modes as eigenfunctions of the derivative operator&quot; What? . Polynomial Bases .",
            "url": "https://alexlenail.me/back_of_my_envelope/2020/12/04/orthogonal-functions.html",
            "relUrl": "/2020/12/04/orthogonal-functions.html",
            "date": " • Dec 4, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "",
          "url": "https://alexlenail.me/back_of_my_envelope/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
      ,"page3": {
          "title": "Old Blog",
          "content": "",
          "url": "https://alexlenail.me/back_of_my_envelope/old/",
          "relUrl": "/old/",
          "date": ""
      }
      
  

  
  

  
  

  
  

  
      ,"page7": {
          "title": "",
          "content": "{“/about/”:”http://alexlenail.me”,”/old/”:”https://alexlenail.medium.com/”} .",
          "url": "https://alexlenail.me/back_of_my_envelope/redirects.json",
          "relUrl": "/redirects.json",
          "date": ""
      }
      
  

  
  

  
      ,"page9": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://alexlenail.me/back_of_my_envelope/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}